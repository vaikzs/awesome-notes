"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[2949],{3905:function(e,a,n){n.d(a,{Zo:function(){return u},kt:function(){return d}});var t=n(7294);function l(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){l(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function p(e,a){if(null==e)return{};var n,t,l=function(e,a){if(null==e)return{};var n,t,l={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(l[n]=e[n]);return l}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=t.createContext({}),o=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},u=function(e){var a=o(e.components);return t.createElement(s.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},k=t.forwardRef((function(e,a){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),k=o(n),d=l,c=k["".concat(s,".").concat(d)]||k[d]||m[d]||r;return n?t.createElement(c,i(i({ref:a},u),{},{components:n})):t.createElement(c,i({ref:a},u))}));function d(e,a){var n=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=k;var p={};for(var s in a)hasOwnProperty.call(a,s)&&(p[s]=a[s]);p.originalType=e,p.mdxType="string"==typeof e?e:l,i[1]=p;for(var o=2;o<r;o++)i[o]=n[o];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}k.displayName="MDXCreateElement"},6280:function(e,a,n){n.r(a),n.d(a,{assets:function(){return u},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return p},metadata:function(){return o},toc:function(){return m}});var t=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],p={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Language","Haskell"]},s="Haskell Basic Notes",o={unversionedId:"language/haskell/haskellBasicNotes",id:"language/haskell/haskellBasicNotes",title:"Haskell Basic Notes",description:"Platform",source:"@site/notes/language/haskell/haskellBasicNotes.md",sourceDirName:"language/haskell",slug:"/language/haskell/haskellBasicNotes",permalink:"/awesome-notes/language/haskell/haskellBasicNotes",editUrl:"https://github.com/sabertazimi/awesome-notes/edit/main/notes/language/haskell/haskellBasicNotes.md",tags:[{label:"Language",permalink:"/awesome-notes/tags/language"},{label:"Haskell",permalink:"/awesome-notes/tags/haskell"}],version:"current",lastUpdatedBy:"sabertazimi",lastUpdatedAt:1649250539,formattedLastUpdatedAt:"4/6/2022",frontMatter:{author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Language","Haskell"]},sidebar:"sidebar",previous:{title:"Go Basic Notes",permalink:"/awesome-notes/language/go/goBasicNotes"},next:{title:"Java Basic Notes",permalink:"/awesome-notes/language/java/javaBasicNotes"}},u={},m=[{value:"Platform",id:"platform",level:2},{value:"ghci",id:"ghci",level:3},{value:"ghc",id:"ghc",level:3},{value:"Unique Mark",id:"unique-mark",level:2},{value:"Expression",id:"expression",level:2},{value:"Type",id:"type",level:2},{value:"\u57fa\u672c\u7c7b\u578b",id:"\u57fa\u672c\u7c7b\u578b",level:3},{value:"Int",id:"int",level:4},{value:"Integer",id:"integer",level:4},{value:"Float",id:"float",level:4},{value:"Double",id:"double",level:4},{value:"Bool",id:"bool",level:4},{value:"Char",id:"char",level:4},{value:"String",id:"string",level:4},{value:"Ordering",id:"ordering",level:4},{value:"Word",id:"word",level:4},{value:"Rational",id:"rational",level:4},{value:"List",id:"list",level:3},{value:"Operator",id:"operator",level:4},{value:"Function",id:"function",level:4},{value:"Range",id:"range",level:4},{value:"List Comprehension",id:"list-comprehension",level:4},{value:"Tuple",id:"tuple",level:3},{value:"\u5185\u90e8\u5dee\u5f02\u6027",id:"\u5185\u90e8\u5dee\u5f02\u6027",level:4},{value:"\u5916\u90e8\u5dee\u5f02\u6027",id:"\u5916\u90e8\u5dee\u5f02\u6027",level:4},{value:"Tuple Function",id:"tuple-function",level:4},{value:"\u4e8c\u5143\u7ec4",id:"\u4e8c\u5143\u7ec4",level:5},{value:"\u4e09\u5143\u7ec4",id:"\u4e09\u5143\u7ec4",level:5},{value:"\u6cdb\u578b",id:"\u6cdb\u578b",level:3},{value:"\u51fd\u6570\u7c7b\u578b",id:"\u51fd\u6570\u7c7b\u578b",level:3},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"As Pattern Matching",id:"as-pattern-matching",level:3},{value:"List Pattern Matching",id:"list-pattern-matching",level:3},{value:"Tuple Pattern Matching",id:"tuple-pattern-matching",level:3},{value:"Guard Pattern Matching and Where Binding",id:"guard-pattern-matching-and-where-binding",level:3},{value:"Let Binding",id:"let-binding",level:3},{value:"Case Pattern Matching",id:"case-pattern-matching",level:3},{value:"Pattern Matching Best Practice",id:"pattern-matching-best-practice",level:3},{value:"Type Class",id:"type-class",level:2},{value:"=&gt; \u7b26\u53f7",id:"-\u7b26\u53f7",level:3},{value:"Basic Type Class",id:"basic-type-class",level:3},{value:"Eq",id:"eq",level:4},{value:"Ord",id:"ord",level:4},{value:"Show",id:"show",level:4},{value:"Read",id:"read",level:4},{value:"Enum",id:"enum",level:4},{value:"Bounded",id:"bounded",level:4},{value:"Num",id:"num",level:4},{value:"Integral",id:"integral",level:4},{value:"Floating",id:"floating",level:4},{value:"<em>Functor</em>",id:"functor",level:4},{value:"Control Applicative",id:"control-applicative",level:4},{value:"Maybe",id:"maybe",level:5},{value:"Collection <code>[]</code>",id:"collection-",level:5},{value:"IO",id:"io",level:5},{value:"ZipList",id:"ziplist",level:5},{value:"Multi Functor",id:"multi-functor",level:5},{value:"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570",id:"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570",level:5},{value:"Control Monad",id:"control-monad",level:4},{value:"Maybe Monad",id:"maybe-monad",level:5},{value:"\u5b9e\u73b0",id:"\u5b9e\u73b0",level:6},{value:"do \u8868\u793a\u6cd5",id:"do-\u8868\u793a\u6cd5",level:6},{value:"List Monad",id:"list-monad",level:5},{value:"MonadPlus",id:"monadplus",level:5},{value:"Monad Algorithms",id:"monad-algorithms",level:5},{value:"\u9a6c\u8d70\u65e5",id:"\u9a6c\u8d70\u65e5",level:6},{value:"Foldable",id:"foldable",level:4},{value:"Data Monoid",id:"data-monoid",level:4},{value:"Custom Type Class",id:"custom-type-class",level:3},{value:"<code>data</code> type",id:"data-type",level:3},{value:"\u51fd\u6570\u7279\u6027",id:"\u51fd\u6570\u7279\u6027",level:4},{value:"\u8bb0\u5f55\u8bed\u6cd5(Record Syntax)",id:"\u8bb0\u5f55\u8bed\u6cd5record-syntax",level:4},{value:"\u7c7b\u578b\u53c2\u6570(Type Parameters)",id:"\u7c7b\u578b\u53c2\u6570type-parameters",level:4},{value:"Maybe value constructor",id:"maybe-value-constructor",level:5},{value:"Deriving(\u6d3e\u751f)",id:"deriving\u6d3e\u751f",level:4},{value:"type \u5b9a\u4e49",id:"type-\u5b9a\u4e49",level:4},{value:"\u9ad8\u7ea7\u6570\u636e\u7ed3\u6784",id:"\u9ad8\u7ea7\u6570\u636e\u7ed3\u6784",level:4},{value:"\u6808",id:"\u6808",level:5},{value:"\u94fe\u8868",id:"\u94fe\u8868",level:5},{value:"\u4e8c\u53c9\u6811",id:"\u4e8c\u53c9\u6811",level:5},{value:"\u51fd\u6570",id:"\u51fd\u6570",level:2},{value:"\u9012\u5f52\u51fd\u6570",id:"\u9012\u5f52\u51fd\u6570",level:3},{value:"List \u51fd\u6570",id:"list-\u51fd\u6570",level:4},{value:"\u9ad8\u9636\u51fd\u6570",id:"\u9ad8\u9636\u51fd\u6570",level:3},{value:"Curry \u5316",id:"curry-\u5316",level:4},{value:"map \u51fd\u6570",id:"map-\u51fd\u6570",level:4},{value:"filter \u51fd\u6570",id:"filter-\u51fd\u6570",level:4},{value:"fold \u51fd\u6570\u4e0e scan \u51fd\u6570",id:"fold-\u51fd\u6570\u4e0e-scan-\u51fd\u6570",level:4},{value:"lambda \u8868\u8fbe\u5f0f",id:"lambda-\u8868\u8fbe\u5f0f",level:4},{value:"<code>$</code> \u51fd\u6570",id:"-\u51fd\u6570",level:4},{value:".\u51fd\u6570\u4e0e Function composition(\u51fd\u6570\u7ec4\u5408)",id:"\u51fd\u6570\u4e0e-function-composition\u51fd\u6570\u7ec4\u5408",level:4},{value:"\u5e38\u7528\u51fd\u6570",id:"\u5e38\u7528\u51fd\u6570",level:3},{value:"\u65e0\u53c2\u51fd\u6570",id:"\u65e0\u53c2\u51fd\u6570",level:4},{value:"\u524d\u7f00\u51fd\u6570",id:"\u524d\u7f00\u51fd\u6570",level:4},{value:"\u4e2d\u7f00\u51fd\u6570",id:"\u4e2d\u7f00\u51fd\u6570",level:4},{value:"\u6570\u5b66\u51fd\u6570",id:"\u6570\u5b66\u51fd\u6570",level:4},{value:"System Random",id:"system-random",level:5},{value:"\u6570\u5b57\u51fd\u6570",id:"\u6570\u5b57\u51fd\u6570",level:4},{value:"\u6a21\u5757",id:"\u6a21\u5757",level:2},{value:"import",id:"import",level:3},{value:"\u5efa\u7acb\u6a21\u5757",id:"\u5efa\u7acb\u6a21\u5757",level:3},{value:"\u5355\u4e00\u6a21\u5757",id:"\u5355\u4e00\u6a21\u5757",level:4},{value:"\u5b50\u6a21\u5757",id:"\u5b50\u6a21\u5757",level:4},{value:"\u5e38\u7528\u57fa\u7840\u6a21\u5757",id:"\u5e38\u7528\u57fa\u7840\u6a21\u5757",level:3},{value:"Data.List",id:"datalist",level:4},{value:"\u4fee\u6b63 Prelude \u6a21\u5757",id:"\u4fee\u6b63-prelude-\u6a21\u5757",level:5},{value:"Data Char",id:"data-char",level:4},{value:"Data Map",id:"data-map",level:4},{value:"Data Set",id:"data-set",level:4},{value:"\u8f93\u5165\u4e0e\u8f93\u51fa",id:"\u8f93\u5165\u4e0e\u8f93\u51fa",level:2},{value:"IO action",id:"io-action",level:3},{value:"return",id:"return",level:4},{value:"Command Line",id:"command-line",level:3},{value:"ByteString",id:"bytestring",level:3},{value:"\u5e38\u7528\u8f93\u5165\u8f93\u51fa\u51fd\u6570",id:"\u5e38\u7528\u8f93\u5165\u8f93\u51fa\u51fd\u6570",level:3},{value:"\u8f93\u51fa",id:"\u8f93\u51fa",level:4},{value:"Output String",id:"output-string",level:5},{value:"print",id:"print",level:5},{value:"File System IO",id:"file-system-io",level:5},{value:"Write File",id:"write-file",level:6},{value:"Append File",id:"append-file",level:6},{value:"\u8f93\u5165",id:"\u8f93\u5165",level:4},{value:"getChar :: IO Char",id:"getchar--io-char",level:5},{value:"Get Contents",id:"get-contents",level:5},{value:"File",id:"file",level:5},{value:"handle",id:"handle",level:6},{value:"With File",id:"with-file",level:6},{value:"Read File",id:"read-file",level:6},{value:"Action",id:"action",level:4},{value:"When",id:"when",level:5},{value:"sequence",id:"sequence",level:5},{value:"Map",id:"map",level:5},{value:"Control Monad forever",id:"control-monad-forever",level:5},{value:"hSetBuffering",id:"hsetbuffering",level:5},{value:"hFlush",id:"hflush",level:5},{value:"Other",id:"other",level:4},{value:"lines",id:"lines",level:5},{value:"interact",id:"interact",level:5},{value:"System Directory",id:"system-directory",level:5},{value:"\u5f02\u5e38",id:"\u5f02\u5e38",level:2},{value:"catch",id:"catch",level:3},{value:"Advanced Monad",id:"advanced-monad",level:2},{value:"Writer Monad",id:"writer-monad",level:3},{value:"Control Monad Writer",id:"control-monad-writer",level:4},{value:"Reader Monad",id:"reader-monad",level:3},{value:"State Monad",id:"state-monad",level:3},{value:"Control Monad State",id:"control-monad-state",level:4},{value:"State Monad Case",id:"state-monad-case",level:4},{value:"Error Monad",id:"error-monad",level:3},{value:"liftM",id:"liftm",level:4},{value:"join",id:"join",level:4},{value:"filterM",id:"filterm",level:4},{value:"foldM",id:"foldm",level:4},{value:"<code>&lt;=&lt;</code>(\u7ec4\u5408\u51fd\u6570)",id:"\u7ec4\u5408\u51fd\u6570",level:4},{value:"Self-Defined Monad",id:"self-defined-monad",level:3},{value:"\u6ce8\u91ca",id:"\u6ce8\u91ca",level:2},{value:"\u7b26\u53f7",id:"\u7b26\u53f7",level:3},{value:"Reference",id:"reference",level:2}],k={toc:m};function d(e){var a=e.components,p=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,t.Z)({},k,p,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"haskell-basic-notes"},"Haskell Basic Notes"),(0,r.kt)("h2",{id:"platform"},"Platform"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"apt-get install haskell-Platform\napt-get install ghc-mod\natom plugins : language-haskell autocomplete-haskell ide-haskell haskell-ghc-mod\n")),(0,r.kt)("h3",{id:"ghci"},"ghci"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":l"),": load file."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":r"),": reload file."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":cd"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":edit"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"$EDITOR"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":m"),": module."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":q"),": quit."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":?"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":k"),": kind."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":t"),": type function."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":info"),": data/TypeClass.")),(0,r.kt)("h3",{id:"ghc"},"ghc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"runghc *.hs/*.lhs\n")),(0,r.kt)("h2",{id:"unique-mark"},"Unique Mark"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":+"),": \u590d\u6570\u7b26, ",(0,r.kt)("inlineCode",{parentName:"li"},"2 :+ 3 -> 2+3i"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_"),": \u6cdb\u5339\u914d\u7b26, \u8868\u793a\u4e0d\u5173\u5fc3\u6b64\u90e8\u5206\u5177\u4f53\u5185\u5bb9."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<-"),": \u5c5e\u4e8e\u7b26\u53f7, \u7528\u4e8e ListRange \u4e2d."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"=>"),": \u7c7b\u578b\u7ea6\u675f\u5206\u9694\u7b26")),(0,r.kt)("h2",{id:"expression"},"Expression"),(0,r.kt)("p",null,"if \u8bed\u53e5\u4e5f\u662f\u8868\u8fbe\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"doubleSmallNumber' x = (if x > 100 then x else x*2) + 1\n")),(0,r.kt)("h2",{id:"type"},"Type"),(0,r.kt)("h3",{id:"\u57fa\u672c\u7c7b\u578b"},"\u57fa\u672c\u7c7b\u578b"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t 'a'\n'a' :: Char\n\nghci> :t True\nTrue :: Bool\n\nghci> :t \"HELLO!\"\n\"HELLO!\" :: [Char]\n\nghci> :t (True, 'a')\n(True, 'a') :: (Bool, Char)\n")),(0,r.kt)("h4",{id:"int"},"Int"),(0,r.kt)("p",null,"\u6709\u9650\u6574\u6570"),(0,r.kt)("h4",{id:"integer"},"Integer"),(0,r.kt)("p",null,"\u65e0\u9650\u6574\u6570(\u6548\u7387\u4f4e)"),(0,r.kt)("h4",{id:"float"},"Float"),(0,r.kt)("p",null,"\u5355\u7cbe\u5ea6\u6d6e\u70b9\u6570"),(0,r.kt)("h4",{id:"double"},"Double"),(0,r.kt)("p",null,"\u53cc\u7cbe\u5ea6\u6d6e\u70b9\u6570"),(0,r.kt)("h4",{id:"bool"},"Bool"),(0,r.kt)("p",null,"True/False"),(0,r.kt)("h4",{id:"char"},"Char"),(0,r.kt)("h4",{id:"string"},"String"),(0,r.kt)("h4",{id:"ordering"},"Ordering"),(0,r.kt)("p",null,"LT,GT,EQ"),(0,r.kt)("h4",{id:"word"},"Word"),(0,r.kt)("p",null,"Data.Word - unsigned int"),(0,r.kt)("h4",{id:"rational"},"Rational"),(0,r.kt)("p",null,"\u6709\u7406\u6570\u7c7b\u578b,\u7528\u4e8e\u9ad8\u7cbe\u5ea6\u6570\u5b66\u8fd0\u7b97"),(0,r.kt)("h3",{id:"list"},"List"),(0,r.kt)("h4",{id:"operator"},"Operator"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"++"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"!!"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},">"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"<"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"=="),".")),(0,r.kt)("h4",{id:"function"},"Function"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"head List \u9996\u5143\u7d20."),(0,r.kt)("li",{parentName:"ul"},"last List \u5c3e\u5143\u7d20."),(0,r.kt)("li",{parentName:"ul"},"init List \u9664\u53bb\u5c3e\u5143\u7d20\u7684\u90e8\u5206."),(0,r.kt)("li",{parentName:"ul"},"tail List \u9664\u53bb\u9996\u5143\u7d20\u7684\u90e8\u5206."),(0,r.kt)("li",{parentName:"ul"},"length List \u957f\u5ea6.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Tips"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fromIntegral (length [1,2,3,4]) + 3.2\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"null List BestPractice: \u68c0\u67e5\u4e00\u4e2a List \u662f\u5426\u4e3a\u7a7a")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> null [1,2,3]\nFalse\nghci> null []\nTrue\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"reverse List \u53cd\u8f6c"),(0,r.kt)("li",{parentName:"ul"},"take num List \u8fd4\u56de List \u524d num \u4e2a\u5143\u7d20\u7ec4\u6210\u7684 List")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> take 3 [5,4,3,2,1]\n[5,4,3]\nghci> take 5 [1,2]\n[1,2]\nghci> take 0 [6,6,6]\n[]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"drop num List \u5220\u9664 List \u524d num \u4e2a\u5143\u7d20")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> drop 3 [8,4,2,1,5,6]\n[1,5,6]\nghci> drop 0 [1,2,3,4]\n[1,2,3,4]\nghci> drop 100 [1,2,3,4]\n[]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"maximum List \u8fd4\u56de\u6700\u5927\u5143\u7d20")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"minimum List \u8fd4\u56de\u6700\u5c0f\u5143\u7d20")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"sum List \u8fd4\u56de List \u5143\u7d20\u548c")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"product List \u8fd4\u56de List \u5143\u7d20\u79ef")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"elem ",(0,r.kt)("inlineCode",{parentName:"p"},"elem")," List \u5224\u65ad\u5143\u7d20\u5b58\u5728\u6027"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> 4 `elem` [3,4,5,6]\nTrue\nghci> 10 `elem` [3,4,5,6]\nFalse\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"cycle List \u8fd4\u56de\u5faa\u73af\u65e0\u9650\u6570\u7ec4(",(0,r.kt)("em",{parentName:"li"},"Haskell \u60f0\u6027\u7279\u6027"),")"),(0,r.kt)("li",{parentName:"ul"},"repeat Elem \u8fd4\u56de\u5faa\u73af\u65e0\u9650\u6570\u7ec4(",(0,r.kt)("em",{parentName:"li"},"Haskell \u60f0\u6027\u7279\u6027"),")"),(0,r.kt)("li",{parentName:"ul"},"replicate num Elem \u8fd4\u56de\u5faa\u73af\u65e0\u9650\u6570\u7ec4")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"take 10 (cycle [1,2,3]) -> [1,2,3,1,2,3,1,2,3,1]\ntake 10 (repeat 5)      -> [5,5,5,5,5,5,5,5,5,5]\nreplicate 3 10          -> [10,10,10]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"takeWhile :: (a -> Bool) -> ",(0,r.kt)("inlineCode",{parentName:"li"},"[a]")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"[a]")," \u9047\u5230\u4e0d\u7b26\u5408\u9650\u5236\u6761\u4ef6\u7684\u5143\u7d20\u4fbf\u505c\u6b62\u904d\u5386 List")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))\n166650\n")),(0,r.kt)("h4",{id:"range"},"Range"),(0,r.kt)("p",null,"\u4e09\u8981\u7d20: ",(0,r.kt)("inlineCode",{parentName:"p"},",")," \u4e0e ",(0,r.kt)("inlineCode",{parentName:"p"},"..")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u4e0a\u9650"),(0,r.kt)("li",{parentName:"ul"},"\u4e0b\u9650"),(0,r.kt)("li",{parentName:"ul"},"\u6b65\u957f(",(0,r.kt)("em",{parentName:"li"},"\u4ec5\u53ef\u6807\u660e\u4e00\u6b21"),")")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"\u4e0a\u4e0b\u9650: [1..20]\n\u6b65\u957f\u4e3a2: [2,4..20]\n\u6b65\u957f\u4e3a13\u65e0\u9650List: [13,26..]\ntake 24 [13,26..]\n")),(0,r.kt)("h4",{id:"list-comprehension"},"List Comprehension"),(0,r.kt)("p",null,"\u7531\u7c7b\u4f3c\u96c6\u5408\u5b9a\u4e49\u7684\u79bb\u6563\u6570\u5b66\u5b9a\u4e49,\u6765\u5b9a\u4e49\u590d\u6742\u7684 List:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[expression | filter]")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[expression | x <- Range, Predicate(\u65ad\u8a00/\u9650\u5236\u6761\u4ef6)]")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Range: ",(0,r.kt)("inlineCode",{parentName:"li"},","),"\u5206\u9694\u591a\u4e2a Range(\u4e00\u822c\u4e3a List)"),(0,r.kt)("li",{parentName:"ul"},"Predicate: ",(0,r.kt)("inlineCode",{parentName:"li"},","),"\u5206\u9694\u591a\u4e2a\u65ad\u8a00;\u6bcf\u4e2a\u65ad\u8a00\u5747\u4e3a Boolean \u8868\u8fbe\u5f0f")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> [x*2 | x <- [1..10], x*2 >= 12]\n[12,14,16,18,20]\n\nghci> [ x | x <- [50..100], x `mod` 7 == 3]\n[52,59,66,73,80,87,94]\n\n\nboomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]\n\nghci> boomBangs [7..13]\n["BOOM!","BOOM!","BANG!","BANG!"]\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u591a\u4e2a Range")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]\n[16,20,22,40,50,55,80,100,110]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5d4c\u5957 Comprehension")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]\n\nghci> [ [ x | x <- xs, even x ] | xs <- xxs]\n[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]\n")),(0,r.kt)("h3",{id:"tuple"},"Tuple"),(0,r.kt)("h4",{id:"\u5185\u90e8\u5dee\u5f02\u6027"},"\u5185\u90e8\u5dee\u5f02\u6027"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u540c\u4e00 Tuple \u91cc\u53ef\u5b58\u653e\u4e0d\u540c Type \u7684\u9879")),(0,r.kt)("h4",{id:"\u5916\u90e8\u5dee\u5f02\u6027"},"\u5916\u90e8\u5dee\u5f02\u6027"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6570\u76ee\u4e0d\u540c\u6216\u67d0\u9879\u4e0d\u540c\u7684 Tuple \u5c5e\u4e8e\u4e0d\u540c Type",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u4e0d\u53ef\u7f6e\u4e8e\u540c\u4e00 List \u4e2d"),(0,r.kt)("li",{parentName:"ul"},"\u4e0d\u540c\u957f\u5ea6\u7684 Tuple \u4e0d\u53ef\u6bd4\u8f83(\u6bd4\u8f83\u7b26\u53ea\u53ef\u7528\u4e8e\u76f8\u540c Type)")))),(0,r.kt)("h4",{id:"tuple-function"},"Tuple Function"),(0,r.kt)("h5",{id:"\u4e8c\u5143\u7ec4"},"\u4e8c\u5143\u7ec4"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fst/snd tuple"),": \u8fd4\u56de\u9996\u9879/\u5c3e\u9879."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"zip List1 List2"),": \u5bf9\u5e94\u9879\u914d\u5bf9, \u7ec4\u6210\u4e8c\u5143\u7ec4 List.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]\n[(5,"im"),(3,"a"),(2,"turtle")]\n\nghci> zip [1..] ["apple", "orange", "cherry", "mango"]\n[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]\n')),(0,r.kt)("h5",{id:"\u4e09\u5143\u7ec4"},"\u4e09\u5143\u7ec4"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"first :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_, _, z) = z\n")),(0,r.kt)("h3",{id:"\u6cdb\u578b"},"\u6cdb\u578b"),(0,r.kt)("p",null,"\u8fd0\u7528 Type \u53d8\u91cf (\u53ea\u53ef\u4e3a",(0,r.kt)("strong",{parentName:"p"},"\u5355\u5b57\u7b26"),"), \u5b9e\u73b0\u6cdb\u578b\u53c2\u6570\u4e0e\u591a\u6001\u51fd\u6570."),(0,r.kt)("p",null,"\u501f\u52a9 TypeClass \u53ef\u8f7b\u677e\u5b9e\u73b0\u591a\u6001\u51fd\u6570:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t head\nhead :: [a] -> a\n\n-- a \u548c b \u53ef\u4e3a\u540c\u7c7b\u578b\n-- \u7b2c\u4e00\u4e2a\u53c2\u6570\u4e0e\u8fd4\u56de\u503c\u5fc5\u987b\u540c\u7c7b\u578b\nghci> :t fst\nfst :: (a, b) -> a\n\n-- \u6240\u6709\u53c2\u6570\u5fc5\u987b\u540c\u7c7b\u578b,\u4e14\u5fc5\u987b\u4e3aNum\u6210\u5458\nghci> :t (*)\n(*) :: (Num a) => a -> a -> a\n")),(0,r.kt)("h3",{id:"\u51fd\u6570\u7c7b\u578b"},"\u51fd\u6570\u7c7b\u578b"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5355\u4e2a\u53c2\u6570")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"removeNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u591a\u4e2a\u53c2\u6570")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"addThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n")),(0,r.kt)("h2",{id:"pattern-matching"},"Pattern Matching"),(0,r.kt)("p",null,"\u5f53\u51fd\u6570\u62e5\u6709\u591a\u4e2a\u51fd\u6570\u4f53(\u6a21\u5f0f)\u65f6,\u4f1a\u4ece\u4e0a\u81f3\u4e0b\u8fdb\u884c\u5339\u914d\u5404\u6a21\u5f0f,\u4e00\u65e6\u5339\u914d\u5219\u53ea\u5e94\u7528\u8fd9\u4e00\u51fd\u6570\u4f53."),(0,r.kt)("h3",{id:"as-pattern-matching"},"As Pattern Matching"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"all@(pattern)"),": all \u4e3a\u6307\u5411 pattern \u6574\u4f53\u7684\u5f15\u7528."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"all@(x:y:xs) -- \u5176\u4e2dall\u4e0e(x:y:xs)\u7b49\u4ef7\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'capital :: String -> String\ncapital "" = "Empty string, whoops!"\ncapital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]\n')),(0,r.kt)("h3",{id:"list-pattern-matching"},"List Pattern Matching"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x:xs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x:y:z:xs"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"head' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dummy!\"\nhead' (x:_) = x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"length' :: (Num b) => [a] -> b\nlength' [] = 0\nlength' (_:xs) = 1 + length' xs\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"sum' :: (Num a) => [a] -> a\nsum' [] = 0\nsum' (x:xs) = x + sum' xs\n")),(0,r.kt)("h3",{id:"tuple-pattern-matching"},"Tuple Pattern Matching"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"(x, y)"),(0,r.kt)("li",{parentName:"ul"},"(x, y, z)")),(0,r.kt)("h3",{id:"guard-pattern-matching-and-where-binding"},"Guard Pattern Matching and Where Binding"),(0,r.kt)("p",null,"\u5b50\u6a21\u5f0f\u5339\u914d: \u8fd0\u7528\u5e03\u5c14\u8868\u8fbe\u5f0f\u5b9e\u73b0\u5224\u65ad, \u5e94\u7528\u5bf9\u5e94\u51fd\u6570\u4f53:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5173\u952e\u7b26\u53f7: | \u4e0e where."),(0,r.kt)("li",{parentName:"ul"},"| \u5206\u9694\u51fd\u6570\u4f53."),(0,r.kt)("li",{parentName:"ul"},"where:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u53ef\u89c1\u6027: \u5b9a\u4e49\u53ea\u5bf9\u672c\u6a21\u5f0f\u53ef\u89c1\u7684 (\u79c1\u6709) \u540d\u5b57\u4e0e (\u79c1\u6709) \u51fd\u6570."),(0,r.kt)("li",{parentName:"ul"},"where \u5b9a\u4e49\u5728\u6700\u5916\u5c42, \u4f7f\u5f97\u5404\u6a21\u5f0f\u5171\u4eab (\u79c1\u6709) \u540d\u5b57\u4e0e (\u79c1\u6709) \u51fd\u6570."),(0,r.kt)("li",{parentName:"ul"},"\u540d\u5b57\u5b9a\u4e49\u65f6\u53ef\u4f7f\u7528\u6a21\u5f0f\u5339\u914d ",(0,r.kt)("inlineCode",{parentName:"li"},"where (head:_) = firstName"),".")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'bmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | bmi <= skinny = "You\'re underweight, you emo, you!"\n    | bmi <= normal = "You\'re supposedly normal. Pet, I bet you\'re ugly!"\n    | bmi <= fat    = "You\'re fat! Lose some weight, fatty!"\n    | otherwise     = "You\'re a whale, congratulations!"\n    where bmi = weight / height ^ 2\n          skinny = 18.5\n          normal = 25.0\n          fat = 30.0\n')),(0,r.kt)("h3",{id:"let-binding"},"Let Binding"),(0,r.kt)("p",null,"\u7c7b\u4f3c where, \u7ed1\u5b9a\u5bf9\u8c61\u4e3a\u8868\u8fbe\u5f0f/\u51fd\u6570:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"let bindings\nin  expressions\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"let sideArea = 2 * pi * r * h\n    topArea = pi * r ^2\nin  sideArea + 2 * topArea\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u53ef\u89c1\u6027: in \u4f5c\u7528\u57df, \u53ea\u5bf9\u672c guard \u53ef\u89c1."),(0,r.kt)("li",{parentName:"ul"},"\u53ef\u4f7f\u7528\u6a21\u5f0f\u5339\u914d."),(0,r.kt)("li",{parentName:"ul"},"\u53ef\u7528\u4e8e List Range \u4e2d.")),(0,r.kt)("h3",{id:"case-pattern-matching"},"Case Pattern Matching"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6a21\u5f0f\u5339\u914d\u662f case \u8868\u8fbe\u5f0f\u7684\u7279\u6b8a\u60c5\u51b5(\u8bed\u6cd5\u7cd6:\u7b80\u5316\u5199\u6cd5)."),(0,r.kt)("li",{parentName:"ul"},"\u5728\u51fd\u6570\u4e2d, \u6a21\u5f0f\u5339\u914d\u53ea\u80fd\u7528\u4e8e\u53c2\u6570\u5b9a\u4e49\u4e2d, case \u8868\u8fbe\u5f0f\u53ef\u7528\u4e8e\u5176\u4ed6\u5730\u65b9\n(let/where \u7ed1\u5b9a, \u666e\u901a\u8868\u8fbe\u5f0f, guard \u8bed\u53e5).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"case expression of pattern -> result\n                   pattern -> result\n                   pattern -> result\n                   ...\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'describeList :: [a] -> String\ndescribeList xs = "The list is " ++ case xs of [] -> "empty."\n                                               [x] -> "a singleton list."\n                                               xs -> "a longer list."\n')),(0,r.kt)("h3",{id:"pattern-matching-best-practice"},"Pattern Matching Best Practice"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u4ee3\u66ff if-else/switch \u8bed\u53e5"),(0,r.kt)("li",{parentName:"ul"},"\u9012\u5f52\u7b97\u6cd5(\u5c06\u9012\u5f52\u57fa\u7840\u4f5c\u4e3a\u9996\u6a21\u5f0f,\u9012\u5f52\u51fd\u6570\u4f53\u4f5c\u4e3a\u5c3e\u6a21\u5f0f)"),(0,r.kt)("li",{parentName:"ul"},"List Range \u4e2d\u4ea6\u53ef\u4f7f\u7528\u6a21\u5f0f\u5339\u914d")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n")),(0,r.kt)("h2",{id:"type-class"},"Type Class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t (==)\n(==) :: (Eq a) => a -> a -> Bool\n\nghci> :t fromIntegral\nfromIntegral :: (Integral a, Num b) => a -> b\n")),(0,r.kt)("h3",{id:"-\u7b26\u53f7"},"=> \u7b26\u53f7"),(0,r.kt)("p",null,"=> \u5de6\u90e8: \u7c7b\u7ea6\u675f(Class Constraint)\n=> \u53f3\u90e8: \u51fd\u6570\u7c7b\u578b(\u53c2\u6570/\u8fd4\u56de\u503c\u7c7b\u578b),\u5176\u4e2d\u53c2\u6570\u7c7b\u578b\u540c\u5c5e Class"),(0,r.kt)("h3",{id:"basic-type-class"},"Basic Type Class"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"ghci> :info typeClassName")),(0,r.kt)("h4",{id:"eq"},"Eq"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u53ef\u5224\u65ad\u76f8\u7b49\u6027"),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"),(0,r.kt)("li",{parentName:"ul"},"\u65b9\u6cd5: == \u4e0e /= \u51fd\u6570")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class Eq a where\n    (==) :: a -> a -> Bool\n    (/=) :: a -> a -> Bool\n    x == y = not (x /= y)\n    x /= y = not (x == y)\n")),(0,r.kt)("h4",{id:"ord"},"Ord"),(0,r.kt)("p",null,"Ord \u6210\u5458\u5fc5\u4e3a Eq \u6210\u5458: class (Eq a) => Ord a where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u53ef\u6392\u5e8f"),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"),(0,r.kt)("li",{parentName:"ul"},"\u65b9\u6cd5:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"< > <= >= \u51fd\u6570"),(0,r.kt)("li",{parentName:"ul"},"compare \u51fd\u6570 (Ord a) => a -> a -> Ordering")))),(0,r.kt)("h4",{id:"show"},"Show"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u53ef\u7528\u5b57\u7b26\u4e32\u8868\u793a"),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"),(0,r.kt)("li",{parentName:"ul"},"\u65b9\u6cd5: show \u51fd\u6570 (Show a) => a -> String")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Tips"),": \u7ed3\u5408 Read, \u53ef\u7528\u4e8e\u5b57\u7b26\u4e32\u4e0e\u6570\u503c\u4e4b\u95f4\u7684\u8f6c\u5316"),(0,r.kt)("h4",{id:"read"},"Read"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u53ef\u4ee5\u5c06\u5b57\u4e32\u8f6c\u4e3a Read \u67d0\u6210\u5458\u7c7b\u578b"),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"),(0,r.kt)("li",{parentName:"ul"},"\u65b9\u6cd5: read \u51fd\u6570 (Read a) => String -> a")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Tips"),": \u7ed3\u5408 Show, \u53ef\u7528\u4e8e\u5b57\u7b26\u4e32\u4e0e\u6570\u503c\u4e4b\u95f4\u7684\u8f6c\u5316"),(0,r.kt)("h4",{id:"enum"},"Enum"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u8fde\u7eed\u6027(\u53ef\u679a\u4e3e), \u5176\u6210\u5458\u7c7b\u578b\u53ef\u7528\u4e8e",(0,r.kt)("strong",{parentName:"li"},"Range"),"\u4e2d"),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: () Bool Char Ordering Int Integer Float Double")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"[Thursday .. Sunday]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> succ Monday\nTuesday\nghci> pred Saturday\nFriday\n")),(0,r.kt)("h4",{id:"bounded"},"Bounded"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u4e0a\u4e0b\u9650"),(0,r.kt)("li",{parentName:"ul"},"\u65b9\u6cd5: minBound/maxBound \u51fd\u6570 (Bounded a) => a ",(0,r.kt)("em",{parentName:"li"},"\u65e0\u53c2\u591a\u6001\u5e38\u91cf/\u5b9a\u4e49"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> minBound :: Day\nMonday\nghci> maxBound :: Day\nSunday\n")),(0,r.kt)("h4",{id:"num"},"Num"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u6570\u5b57\u7279\u5f81."),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u5b9e\u6570 \u6574\u6570 (",(0,r.kt)("inlineCode",{parentName:"li"},"Int"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"Integer"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"Float"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"Double"),")."),(0,r.kt)("li",{parentName:"ul"},"\u65b9\u6cd5: ",(0,r.kt)("inlineCode",{parentName:"li"},"+"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"-"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"*"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"abs")," \u51fd\u6570."),(0,r.kt)("li",{parentName:"ul"},"\u5b9e\u4f8b: \u6240\u6709\u6570\u5b57\u90fd\u662f\u591a\u6001\u5e38\u91cf/\u5b9a\u4e49(\u53ef\u89c6\u4e3a\u51fd\u6570).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t 20\n20 :: (Num t) => t\n")),(0,r.kt)("h4",{id:"integral"},"Integral"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u6570\u5b57\u7279\u5f81"),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u6574\u578b - Int Integer")),(0,r.kt)("h4",{id:"floating"},"Floating"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u6570\u5b57\u7279\u5f81"),(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u6d6e\u70b9\u578b - Float Double")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"TypeClass"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Method Feature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Functor"),(0,r.kt)("td",{parentName:"tr",align:"left"},"f a + (a -> b) -> f b")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Applicative"),(0,r.kt)("td",{parentName:"tr",align:"left"},"f a + f (a -> b) -> f b")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Monad"),(0,r.kt)("td",{parentName:"tr",align:"left"},"m a + (a -> m b) -> m b")))),(0,r.kt)("h4",{id:"functor"},(0,r.kt)("em",{parentName:"h4"},"Functor")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: Maybe a, [], Either a, IO",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458 kind \u5fc5\u987b\u4e3a ",(0,r.kt)("inlineCode",{parentName:"li"},"* -> *")),(0,r.kt)("li",{parentName:"ul"},"f ",(0,r.kt)("em",{parentName:"li"},"\u4e00\u5143\u7c7b\u578b\u6784\u9020\u7b26(type constructor)")))),(0,r.kt)("li",{parentName:"ul"},"\u5fc5\u987b\u9075\u5b88\u51c6\u5219:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"fmap id = id"),(0,r.kt)("li",{parentName:"ul"},"fmap (f . g) F = fmap f (fmap g F)")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :info Functor\nclass Functor (f :: * -> *) where\n    fmap :: (a -> b) -> f a -> f b\n    ($) :: a -> f b -> f a\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Functor [] where\n    fmap = map\n\ninstance Functor Maybe where\n    fmap f (Just x) = Just (f x)\n    fmap f Nothing = Nothing\n\ninstance Functor (Either a) where\n    fmap f (Right x) = Right (f x)\n    fmap f (Left x) = Left x\n\ninstance Functor IO where\n    fmap f action = do\n        result <- action\n        return (f result)\n")),(0,r.kt)("h4",{id:"control-applicative"},"Control Applicative"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: ",(0,r.kt)("inlineCode",{parentName:"li"},"f :: * -> *")," ",(0,r.kt)("em",{parentName:"li"},"\u4e00\u5143\u7c7b\u578b\u6784\u9020\u7b26 (Type Constructor)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<*>"),": \u53c2\u6570\u4e3a 2 \u4e2a functor \u5b9e\u4f8b, \u5176\u4e2d\u4e00\u4e2a\u5305\u542b\u4e00\u4e2a\u51fd\u6570.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(<$>) :: (Functor f) => (a -> b) -> f a -> f b\nf <$> x = fmap f x\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u4f5c\u7528: \u53ef\u4ee5\u7528\u5355\u4e00\u4e00\u4e2a\u51fd\u6570\u64cd\u4f5c\u591a\u4e2a functor")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class (Functor f) => Applicative f where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n")),(0,r.kt)("h5",{id:"maybe"},"Maybe"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Applicative Maybe where\n    pure = Just\n    Nothing <*> _ = Nothing\n    (Just f) <*> something = fmap f something\n")),(0,r.kt)("h5",{id:"collection-"},"Collection ",(0,r.kt)("inlineCode",{parentName:"h5"},"[]")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Applicative [] where\n    pure x = [x]\n    fs <*> xs = [f x | f <- fs, x <- xs]\n")),(0,r.kt)("h5",{id:"io"},"IO"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Applicative IO where\n    pure = return\n    a <*> b = do\n        f <- a\n        x <- b\n        return (f x)\n")),(0,r.kt)("h5",{id:"ziplist"},"ZipList"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Applicative ZipList where\n        pure x = ZipList (repeat x)\n        ZipList fs <*> ZipList xs = ZipList (zipWith (\\f x -> f x) fs xs)\n")),(0,r.kt)("h5",{id:"multi-functor"},"Multi Functor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> pure (+) <*> Just 3 <*> Just 5\nJust 8\nghci> pure (+) <*> Just 3 <*> Nothing\nNothing\nghci> pure (+) <*> Nothing <*> Just 5\nNothing\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> (*) <$> [2,5,10] <*> [8,10,11]\n[16,20,22,40,50,55,80,100,110]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"myAction :: IO String\nmyAction = (++) <$> getLine <*> getLine\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]\n[5,3,3,4]\n")),(0,r.kt)("h5",{id:"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570"},"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"liftA2"),", \u5bf9\u4e24\u4e2a applicative \u8fd0\u7528\u4e8c\u5143\u51fd\u6570:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f a b = f <$> a <*> b\n\nghci> liftA2 (:) (Just 3) (Just [4])\nJust [3,4]\nghci> (:) <$> Just 3 <*> Just [4]\nJust [3,4]\n")),(0,r.kt)("h4",{id:"control-monad"},"Control Monad"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u7c7b\u578b\u6784\u9020\u7b26(type constructor)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class Monad m where\n    return :: a -> m a\n\n{- bind -}(>>=) :: m a -> (a -> m b) -> m b\n\n    (>>) :: m a -> m b -> m b\n    x >> y = x >>= _ -> y\n\n    fail :: String -> m a\n    fail msg = error msg\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u7279\u6027: \u5141\u8bb8\u8fd4\u56de\u503c\u4e4b\u95f4\u5177\u6709\u5f39\u6027\u4ea4\u4e92")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"{- \u5f53\u51fa\u73b0\u5f02\u5e38\u540e,\u4e4b\u540e\u6240\u6709\u7684\u503c\u90fd\u53d8\u4e3aNothing -}\nghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2\nJust (2,4)\nghci> return (0,0) >>= landLeft 1 >>= landRight 4\n  \\ >>= landLeft (-1) >>= landRight (-2)\nNothing\n")),(0,r.kt)("p",null,"Monad Laws:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"return \u6ee1\u8db3 Left identity: ",(0,r.kt)("inlineCode",{parentName:"li"},"return x >>= f \u7b49\u4e8e f x")),(0,r.kt)("li",{parentName:"ul"},"return \u6ee1\u8db3 right identity: ",(0,r.kt)("inlineCode",{parentName:"li"},"m >>= return \u7b49\u4e8e m")),(0,r.kt)("li",{parentName:"ul"},"Associativity: \u7ed3\u5408\u5f8b ",(0,r.kt)("inlineCode",{parentName:"li"},"(m >>= f) >>= g \u7b49\u4e8e m >>= (\\x -> f x >>= g)"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> return 3 >>= (\\x -> Just (x+100000))\nJust 100003\nghci> (\\x -> Just (x+100000)) 3\nJust 100003\n\nghci> Just "move on up" >>= (\\x -> return x)\nJust "move on up"\nghci> [1,2,3,4] >>= (\\x -> return x)\n[1,2,3,4]\nghci> putStrLn "Wah!" >>= (\\x -> return x)\nWah!\n\n{-Tips: \u5229\u7528\u7ed3\u5408\u5f8b\u5408\u5e76\u4e24\u4e2a Monadic Function-}\n(<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = (\\x -> g x >>= f)\nghci> let f x = [x,-x]\nghci> let g x = [x*3,x*2]\nghci> let h = f <=< g\nghci> h 3\n[9,-9,6,-6]\n')),(0,r.kt)("h5",{id:"maybe-monad"},"Maybe Monad"),(0,r.kt)("p",null,"\u5177\u6709\u5931\u8d25\u53ef\u80fd\u6027\u7684 context \u5c01\u88c5,\u7075\u6d3b\u5904\u7406\u5f02\u5e38(\u8fd4\u56de\u503c\u4e3a Nothing)"),(0,r.kt)("h6",{id:"\u5b9e\u73b0"},"\u5b9e\u73b0"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\napplyMaybe Nothing f  = Nothing\napplyMaybe (Just x) f = f x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monad Maybe where\n    return x = Just x\n    Nothing >>= f = Nothing\n    Just x >>= f  = f x\n    fail _ = Nothing\n")),(0,r.kt)("h6",{id:"do-\u8868\u793a\u6cd5"},"do \u8868\u793a\u6cd5"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5728 do expression \u4e2d\uff0c\u6bcf\u4e00\u884c\u90fd\u662f\u4e00\u4e2a monadic value"),(0,r.kt)("li",{parentName:"ul"},"\u68c0\u67e5\u8fd4\u56de\u503c\uff0c\u4f7f\u7528 <-")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'foo :: Maybe String\nfoo = do\n    x <- Just 3\n    y <- Just "!"\n    Just (show x ++ y)\n\nfoo :: Maybe String\nfoo = Just 3   >>= (\\x ->\n      Just "!" >>= (\\y ->\n      Just (show x ++ y)))\n\nroutine :: Maybe Pole\nroutine = do\n    start <- return (0,0)\n    first <- landLeft 2 start\n    Nothing\n    second <- landRight 2 first\n    landLeft 1 second\n')),(0,r.kt)("h5",{id:"list-monad"},"List Monad"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"non-determinism(\u4e0d\u786e\u5b9a\u6027)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> (*) <$> [1,2,3] <*> [10,100,1000]\n[10,100,1000,20,200,2000,30,300,3000]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5b9e\u73b0")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monad [] where\n    return x = [x]\n    xs >>= f = concat (map f xs)\n    fail _ = []\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u8fd4\u56de\u503c\u4ea4\u4e92: \u4e0b\u4f8b\u4e2d n \u4e0e return (n, ch) \u8fdb\u884c\u4ea4\u4e92",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"list comprehension \u4e0e do \u8868\u793a\u6cd5 \u5747\u662f >>= \u7684\u8bed\u6cd5\u7cd6"))),(0,r.kt)("li",{parentName:"ul"},"list comprehension: <- \u4e0e \u6761\u4ef6\u8868\u8fbe\u5f0f"),(0,r.kt)("li",{parentName:"ul"},"do \u8868\u793a\u6cd5: <- \u4e0e guard \u51fd\u6570")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> [1,2] >>= \\n -> ['a','b'] >>= \\ch -> return (n,ch)\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n\n{- do \u8868\u793a\u6cd5 -}\nlistOfTuples :: [(Int,Char)]\nlistOfTuples = do\n    n <- [1,2]\n    ch <- ['a','b']\n    return (n,ch)\n\nsevensOnly :: [Int]\nsevensOnly = do\n    x <- [1..50]\n    guard ('7' `elem` show x)\n    return x\n\n{- list comprehension -}\nghci> [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n")),(0,r.kt)("h5",{id:"monadplus"},"MonadPlus"),(0,r.kt)("p",null,"\u4f7f Monad \u5177\u6709 Monoid \u7684\u6027\u8d28(\u4e8c\u5143\u5c01\u95ed\u8fd0\u7b97)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance MonadPlus [] where\n    mzero = []\n    mplus = (++)\n")),(0,r.kt)("h5",{id:"monad-algorithms"},"Monad Algorithms"),(0,r.kt)("h6",{id:"\u9a6c\u8d70\u65e5"},"\u9a6c\u8d70\u65e5"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u8ba1\u7b97\u51fa\u53ef\u79fb\u52a8\u4f4d\u7f6e")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"moveKnight :: KnightPos -> [KnightPos]\nmoveKnight (c,r) = do\n    (c',r') <- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)\n                ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)\n                ]\n    guard (c' `elem` [1..8] && r' `elem` [1..8])\n    return (c',r')\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5229\u7528 >>= \u5411\u540e\u4f20\u9012\u591a\u4e2a\u53ef\u4ea4\u4e92\u7684\u4f4d\u7f6e")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight\n\nin3 :: KnightPos -> [KnightPos]\nin3 start = do\n    first <- moveKnight start\n    second <- moveKnight first\n    moveKnight second\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6700\u540e\u5b8c\u6210\u5b8c\u6574\u51fd\u6570: \u4ea7\u751f\u6240\u6709\u4e09\u6b65\u7684\u53ef\u80fd\u4f4d\u7f6e\uff0c\u68c0\u67e5\u5176\u4e2d\u4e00\u4e2a\u4f4d\u7f6e\u662f\u5426\u5728\u91cc\u9762")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"canReachIn3 :: KnightPos -> KnightPos -> Bool\ncanReachIn3 start end = end `elem` in3 start\n")),(0,r.kt)("h4",{id:"foldable"},"Foldable"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Data.Foldable as F\n\nfoldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance F.Foldable Tree where\n    foldMap f Empty = mempty\n    foldMap f (Node x l r) = F.foldMap f l `mappend`\n                                f x           `mappend`\n                                F.foldMap f r\n")),(0,r.kt)("h4",{id:"data-monoid"},"Data Monoid"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6210\u5458: \u5fc5\u987b\u4e3a\u5177\u4f53\u7c7b\u578b (",(0,r.kt)("strong",{parentName:"li"},"\u4e0d\u53ef\u662f\u7c7b\u578b\u6784\u9020\u7b26 (Type Constructor)"),")."),(0,r.kt)("li",{parentName:"ul"},"\u51c6\u5219 (Monoid Law):",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"\u7ed3\u5408\u5f8b")," ",(0,r.kt)("inlineCode",{parentName:"li"},"a\xb7(b\xb7c) = (a\xb7b)\xb7c"),"."),(0,r.kt)("li",{parentName:"ul"},"\u65e0\u9700\u6ee1\u8db3 ",(0,r.kt)("inlineCode",{parentName:"li"},"a mappend b == b mappend a"),".")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class Monoid m where\n    mempty :: m             -- identity\n    mappend :: m -> m -> m\n    mconcat :: [m] -> m\n    mconcat = foldr mappend mempty\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5b9e\u4f8b")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monoid [a] where\n    mempty = []\n    mappend = (++)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype Product a =  Product { getProduct :: a }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Num a => Monoid (Product a) where\n    mempty = Product 1\n    Product x `mappend` Product y = Product (x * y)\n\nghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2\n24\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype Any = Any { getAny :: Bool }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Monoid Any where\n    mempty = Any False\n    Any x `mappend` Any y = Any (x || y)\n\nghci> getAny . mconcat . map Any $ [False, False, False, True]\nTrue\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype All = All { getAll :: Bool }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Monoid All where\n    mempty = All True\n    All x `mappend` All y = All (x && y)\n\nghci> getAll . mconcat . map All $ [True, True, False]\nFalse\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'instance Monoid Ordering where\n    mempty = EQ\n    LT `mappend` _ = LT\n    EQ `mappend` y = y\n    GT `mappend` _ = GT\n\n-- Tips:\n-- mappend \u5728\u5de6\u8fb9\u4e0d\u7b49\u4e8e EQ \u7684\u60c5\u51b5\u4e0b\u90fd\u4f1a\u56de\u4f20\u5de6\u8fb9\u7684\u503c\u3002\u76f8\u53cd\u5730\u5219\u56de\u4f20\u53f3\u8fb9\u7684\u503c\n-- \u53ef\u4ee3\u66ff\u591a\u4e2a if/else \u8bed\u53e5\nimport Data.Monoid\n\nlengthCompare :: String -> String -> Ordering\nlengthCompare x y = (length x `compare` length y) `mappend`\n                    (vowels x `compare` vowels y) `mappend`\n                    (x `compare` y)\n    where vowels = length . filter (`elem` "aeiou")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monoid a => Monoid (Maybe a) where\n    mempty = Nothing\n    Nothing `mappend` m = m\n    m `mappend` Nothing = m\n    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)\n\ninstance Monoid (First a) where\n    mempty = First Nothing\n    First (Just x) `mappend` _ = First (Just x)\n    First Nothing `mappend` x = x\n\nghci> getFirst $ First (Just 'a') `mappend` First Nothing\nJust 'a'\n")),(0,r.kt)("h3",{id:"custom-type-class"},"Custom Type Class"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u521b\u5efa\u65b0\u7c7b: ",(0,r.kt)("em",{parentName:"li"},"\u53ef\u4ee5\u53ea\u6709\u58f0\u660e\u6ca1\u6709\u5b9e\u73b0"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class ClassName where\n    defining code\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u521b\u5efa\u5df2\u6709\u7c7b\u7684\u5b9e\u4f8b: ",(0,r.kt)("em",{parentName:"li"},"\u5fc5\u987b\u5b9e\u73b0\u6240\u6709\u5df2\u58f0\u660e\u51fd\u6570"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u4f5c\u7528\u7b49\u540c\u4e8e deriving(\u81ea\u7531\u5ea6\u66f4\u5927)"),(0,r.kt)("li",{parentName:"ul"},"\u53ef\u4ee5\u91cd\u5199\u51fd\u6570,\u53bb\u9664\u9ed8\u8ba4\u51fd\u6570\u5904\u7406,\u8fbe\u5230\u7279\u5b9a\u76ee\u7684")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'- \u5148\u521b\u5efa\u65b0\u7c7b\u578b\ndata TrafficLight = Red | Yellow | Green\n\ninstance Eq TrafficLight where\n    Red == Red = True\n    Green == Green = True\n    Yellow == Yellow = True\n    _ == _ = False\n\ninstance Show TrafficLight where\n    show Red = "Red light"\n    show Yellow = "Yellow light"\n    show Green = "Green light"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u521b\u5efa\u65b0\u7c7b\u548c\u5b9e\u73b0\u5b9e\u4f8b\u65f6,\u4f7f\u7528 class constraint",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u53ef\u8fbe\u5230",(0,r.kt)("strong",{parentName:"li"},"\u7c7b\u4f3c\u4e8e"),"\u7ee7\u627f\u7684\u6548\u679c"),(0,r.kt)("li",{parentName:"ul"},"\u53ef\u8fbe\u5230\u9650\u5236\u7c7b\u578b\u7684\u6548\u679c")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class (Eq a) => Num a where\n    ...\n\ninstance (Eq m) => Eq (Maybe m) where\n    Just x == Just y = x == y\n    Nothing == Nothing = True\n    _ == _ = False\n")),(0,r.kt)("h3",{id:"data-type"},(0,r.kt)("inlineCode",{parentName:"h3"},"data")," type"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data SelfDefinedTypeName =\n  ValueConstructorName ValueType .. | .. deriving (TypeClass, ..)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"data \u8303\u4f8b")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Point = Point Float Float deriving (Show)\ndata Shape = Circle Point Float | Rectangle Point Point deriving (Show)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5bfc\u51fa data")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"module Shapes\n( Point(..)\n, Shape(..)\n) where\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u540e\u6784\u9020\u5668 > \u524d\u6784\u9020\u5668")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"e.g True > False")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Bool = False | True deriving (Ord)\n")),(0,r.kt)("h4",{id:"\u51fd\u6570\u7279\u6027"},"\u51fd\u6570\u7279\u6027"),(0,r.kt)("p",null,"data type \u4e5f\u662f\u51fd\u6570,\u82e5\u7701\u7565\u53c2\u6570\u4ea6\u4f1a\u9020\u6210 Curry \u5316."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"e.g map fx list")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> map (Circle 10 20) [4,5,6,6]\n[Circle 10.0 20.0 4.0,\nCircle 10.0 20.0 5.0,\nCircle 10.0 20.0 6.0,\nCircle 10.0 20.0 6.0\n]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Value Constructor:\u4f7f\u7528",(0,r.kt)("inlineCode",{parentName:"li"},"ValueConstructorName ValueType .."),"\u53ef\u6784\u9020\u51fa\u4e00\u4e2a\u8be5\u7c7b\u578b\u7684\u5b9a\u4e49/\u540d\u5b57")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci > Circle 10 20 30\nCircle 10 20 30\n")),(0,r.kt)("h4",{id:"\u8bb0\u5f55\u8bed\u6cd5record-syntax"},"\u8bb0\u5f55\u8bed\u6cd5(Record Syntax)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5b9a\u4e49")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     , height :: Float\n                     , phoneNumber :: String\n                     , flavor :: String\n                     } deriving (Show)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Car {company="Ford", model="Mustang", year=1967}\nCar {company = "Ford", model = "Mustang", year = 1967}\n')),(0,r.kt)("h4",{id:"\u7c7b\u578b\u53c2\u6570type-parameters"},"\u7c7b\u578b\u53c2\u6570(Type Parameters)"),(0,r.kt)("p",null,"\u63d0\u9ad8\u4ee3\u7801\u7684\u590d\u7528\u6027"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Car a b c = Car { company :: a\n                       , model :: b\n                       , year :: c\n                        } deriving (Show)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'tellCar :: (Show a) => Car String String a -> String\ntellCar (Car {company = c, model = m, year = y}) =\n  "This " ++ c ++ " " ++ m ++ " was made in " ++ show y\n')),(0,r.kt)("h5",{id:"maybe-value-constructor"},"Maybe value constructor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Maybe a = Nothing | Just a\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Just \u53ef\u5b9e\u73b0\u8f6c\u5316:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Just :: a -> Maybe a\n")),(0,r.kt)("h4",{id:"deriving\u6d3e\u751f"},"Deriving(\u6d3e\u751f)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday\n           deriving (Eq, Ord, Show, Read, Bounded, Enum)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Wednesday\nWednesday\nghci> show Wednesday\n"Wednesday"\nghci> read "Saturday" :: Day\nSaturday\n\nghci> Saturday == Sunday\nFalse\nghci> Saturday == Saturday\nTrue\nghci> Saturday > Friday\nTrue\nghci> Monday `compare` Wednesday\nLT\n\nghci> minBound :: Day\nMonday\nghci> maxBound :: Day\nSunday\n\nghci> succ Monday\nTuesday\nghci> pred Saturday\nFriday\nghci> [Thursday .. Sunday]\n[Thursday,Friday,Saturday,Sunday]\n\nghci> [minBound .. maxBound] :: [Day]\n[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]\n')),(0,r.kt)("h4",{id:"type-\u5b9a\u4e49"},"type \u5b9a\u4e49"),(0,r.kt)("p",null,"\u4e3a data \u58f0\u660e\u522b\u540d - ",(0,r.kt)("inlineCode",{parentName:"p"},"typedef")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"type String = [Char]\ntype PhoneNumber = String\ntype Name = String\ntype PhoneBook = [(Name,PhoneNumber)]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"type \u7c7b\u578b\u53c2\u6570: \u5339\u914d data \u7c7b\u578b\u53c2\u6570")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"type AssocList k v = [(k,v)]\n\ntype IntMap v = Map.Map Int v\ntype IntMap = Map.Map Int\n")),(0,r.kt)("p",null,"\u7c7b\u578b\u522b\u540d,\u53ea\u53ef\u4ee5\u5728 Haskell \u7684\u7c7b\u578b\u90e8\u5206\u4e2d\u4f7f\u7528:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5b9a\u4e49\u65b0\u7c7b\u578b"),(0,r.kt)("li",{parentName:"ul"},"\u7c7b\u578b\u58f0\u660e"),(0,r.kt)("li",{parentName:"ul"},"\u7c7b\u578b\u6ce8\u91ca(::)"),(0,r.kt)("li",{parentName:"ul"},"\u7981\u6b62: \u5b9a\u4e49\u540d\u5b57/\u5b9a\u4e49 ",(0,r.kt)("em",{parentName:"li"},"AssocList ","[(1,2),(4,5),(7,9)]"))),(0,r.kt)("h4",{id:"\u9ad8\u7ea7\u6570\u636e\u7ed3\u6784"},"\u9ad8\u7ea7\u6570\u636e\u7ed3\u6784"),(0,r.kt)("h5",{id:"\u6808"},"\u6808"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"type Stack = [Int]\n\npop :: Stack -> (Int,Stack)\npop (x:xs) = (x,xs)\n\npush :: Int -> Stack -> ((),Stack)\npush a xs = ((),a:xs)\n")),(0,r.kt)("h5",{id:"\u94fe\u8868"},"\u94fe\u8868"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)\ndata List a = Empty\n  | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)\n")),(0,r.kt)("h5",{id:"\u4e8c\u53c9\u6811"},"\u4e8c\u53c9\u6811"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"singleton :: a -> Tree a\nsingleton x = Node x EmptyTree EmptyTree\n\ntreeInsert :: (Ord a) => a -> Tree a -> Tree a\ntreeInsert x EmptyTree = singleton x\ntreeInsert x (Node a left right)\n      | x == a = Node x left right\n      | x < a  = Node a (treeInsert x left) right\n      | x > a  = Node a left (treeInsert x right)\n\ntreeElem :: (Ord a) => a -> Tree a -> Bool\ntreeElem x EmptyTree = False\ntreeElem x (Node a left right)\n    | x == a = True\n    | x < a  = treeElem x left\n    | x > a  = treeElem x right\n\nghci> let nums = [8,6,4,1,7,3,5]\nghci> let numsTree = foldr treeInsert EmptyTree nums\n")),(0,r.kt)("h2",{id:"\u51fd\u6570"},"\u51fd\u6570"),(0,r.kt)("h3",{id:"\u9012\u5f52\u51fd\u6570"},"\u9012\u5f52\u51fd\u6570"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u8fb9\u754c\u6761\u4ef6"),(0,r.kt)("li",{parentName:"ul"},"\u9012\u5f52\u57fa\u7840"),(0,r.kt)("li",{parentName:"ul"},"\u9012\u5f52\u51fd\u6570\u4f53")),(0,r.kt)("h4",{id:"list-\u51fd\u6570"},"List \u51fd\u6570"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u8fb9\u754c\u6761\u4ef6: \u7a7a List"),(0,r.kt)("li",{parentName:"ul"},"\u9012\u5f52\u51fd\u6570\u4f53: x:xs \u53d6\u51fa\u9996\u5143\u7d20\u8fdb\u884c\u4e00\u822c\u64cd\u4f5c,\u5bf9\u5c3e\u90e8\u8fdb\u884c\u9012\u5f52\u64cd\u4f5c.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"maximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"maximum of empty list\"\nmaximum' [x] = x\n{-\nmaximum' (x:xs)\n    | x > maxTail = x\n    | otherwise = maxTail\n    where maxTail = maximum' xs\n-}\nmaximum' (x:xs) = max x (maximum' xs)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"replicate' :: (Num i, Ord i) => i -> a -> [a]\nreplicate' n x\n    | n <= 0    = []\n    | otherwise = x:replicate' (n-1) x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"take' :: (Num i, Ord i) => i -> [a] -> [a]\ntake' n _\n    | n <= 0   = []\ntake' _ []     = []\ntake' n (x:xs) = x : take' (n-1) xs\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"reverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"repeat' :: a -> [a]\nrepeat' x = x:repeat' x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"zip' :: [a] -> [b] -> [(a,b)]\nzip' _ [] = []\nzip' [] _ = []\nzip' (x:xs) (y:ys) = (x,y):zip' xs ys\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"elem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs)\n    | a == x    = True\n    | otherwise = a `elem'` xs\n")),(0,r.kt)("p",null,"Awesome Quick Sort"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"quicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted\n")),(0,r.kt)("h3",{id:"\u9ad8\u9636\u51fd\u6570"},"\u9ad8\u9636\u51fd\u6570"),(0,r.kt)("h4",{id:"curry-\u5316"},"Curry \u5316"),(0,r.kt)("p",null,"\u5f53\u4f20\u5165\u4e0d\u5168\u53c2\u6570\u65f6,\u4f1a\u6539\u53d8\u51fd\u6570\u7684\u7c7b\u578b,",(0,r.kt)("em",{parentName:"p"},"\u8fd4\u56de\u503c\u4ece\u5355\u7c7b\u578b\u53d8\u6210\u51fd\u6570\u7c7b\u578b"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5f53\u4f20\u5165\u4e0d\u5168\u53c2\u6570\u65f6:"),(0,r.kt)("li",{parentName:"ul"},"compare \u7684\u7c7b\u578b\u53d8\u4e3a (Ord a) => a -> (a -> Ordering)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"compareWithHundred :: (Num a, Ord a) => a -> Ordering\ncompareWithHundred x = compare 100 x\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u901a\u8fc7\u7ed9\u4e8c\u5143\u4e2d\u7f00\u51fd\u6570\u4f20\u9012\u552f\u4e00\u53c2\u6570:"),(0,r.kt)("li",{parentName:"ul"},"\u4e2d\u7f00\u51fd\u6570\u7c7b\u578b\u7531 a -> a -> a \u8f6c\u4e3a a -> a")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"divideByTen :: (Floating a) => a -> a\ndivideByTen = (/10)\n\nghci> :t (/10)\n(/10) :: (Fractional a) => a -> a\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5305\u88c5\u51fd\u6570:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u4f20\u5165\u4e00\u4e2a\u4e8c\u5143\u51fd\u6570\u4f5c\u4e3a\u53c2\u6570,\u4fbf\u53ef\u5b9e\u73b0 zipWithFunc"),(0,r.kt)("li",{parentName:"ul"},"\u82e5\u5728\u5b9a\u4e49\u65f6\u4fbf\u4f20\u5165\u4e00\u4e2a\u51fd\u6570\u53c2\u6570,\u4fbf\u53ef\u5b9e\u73b0 Curry \u5316")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'zipWith\' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith\' _ [] _ = []\nzipWith\' _ _ [] = []\nzipWith\' f (x:xs) (y:ys) = f x y : zipWith\' f xs ys\n\n\nghci> zipWith\' (+) [4,2,5,6] [2,6,2,3]\n[6,8,7,9]\nghci> zipWith\' max [6,3,2,1] [7,3,1,5]\n[7,3,2,5]\nghci> zipWith\' (++) ["foo "\uff0c"bar "\uff0c"baz "] ["fighters"\uff0c"hoppers"\uff0c"aldrin"]\n["foo fighters","bar hoppers","baz aldrin"]\nghci> zipWith\' (*) (replicate 5 2) [1..]\n[2,4,6,8,10]\nghci> zipWith\' (zipWith\' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]\n[[3,4,6],[9,20,30],[10,12,12]]\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u901a\u8fc7 Curry \u5316,\u8fd8\u53ef\u7701\u7565\u53c2\u6570")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"foo a = bar b a ->\nfoo = bar b\n")),(0,r.kt)("h4",{id:"map-\u51fd\u6570"},"map \u51fd\u6570"),(0,r.kt)("p",null,"\u6620\u5c04\u51fd\u6570 - List Comprehension \u7684\u51fd\u6570\u5316"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"map :: (a -> b) -> [a] -> [b]\nmap _ [] = []\nmap f (x:xs) = f x : map f xs\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5982\u679c map \u4f20\u5165\u7684\u51fd\u6570\u53c2\u6570\u7684\u7c7b\u578b\u4e3a a -> a -> a,\u5219\u8fd4\u56de\u7684 List \u7c7b\u578b\u4e3a",(0,r.kt)("inlineCode",{parentName:"li"},"[a -> a]"),"(f x \u4f20\u53c2\u4e0d\u5b8c\u5168,\u9020\u6210\u4e86 Curry \u5316).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> let listOfFun = map (*) [0..]\nghci> (listOfFun !! 4) 5\n20\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> map (+3) [1,5,3,1,6]\n[4,8,6,4,9]\nghci> map (++ "!") ["BIFF"\uff0c"BANG"\uff0c"POW"]\n["BIFF!","BANG!","POW!"]\nghci> map (replicate 3) [3..6]\n[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]\nghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]\n[[1,4],[9,16,25,36],[49,64]]\nghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]\n[1,3,6,2,2]\n')),(0,r.kt)("h4",{id:"filter-\u51fd\u6570"},"filter \u51fd\u6570"),(0,r.kt)("p",null,"\u8fc7\u6ee4\u51fd\u6570 - Comprehension \u7684\u51fd\u6570\u5316"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"filter :: (a -> Bool) -> [a] -> [a]\nfilter _ [] = []\nfilter p (x:xs)\n    | p x       = x : filter p xs\n    | otherwise = filter p xs\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]\n[5,6,4]\nghci> filter (==3) [1,2,3,4,5]\n[3]\nghci> filter even [1..10]\n[2,4,6,8,10]\nghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]\n[[1,2,3],[3,4,5],[2,2]]\nghci> filter (`elem` ['a'..'z']) \"u LaUgH aT mE BeCaUsE I aM diFfeRent\"\n\"uagameasadifeent\"\nghci> filter (`elem` ['A'..'Z']) \"i lauGh At You BecAuse u r aLL the Same\"\n\"GAYBALLS\"\n")),(0,r.kt)("h4",{id:"fold-\u51fd\u6570\u4e0e-scan-\u51fd\u6570"},"fold \u51fd\u6570\u4e0e scan \u51fd\u6570"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"\u6298\u53e0\u51fd\u6570",src:n(1779).Z,width:"172",height:"348"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u5982\u56fe\u4e2d\u6240\u793a,\u5de6\u6298\u53e0\u65f6\u5c06 acc \u89c6\u4e3a\u7b2c 0 \u4e2a\u5143\u7d20;\u53f3\u6298\u53e0\u65f6\u5c06 acc \u89c6\u4e3a\u6700\u540e\u4e00\u4e2a\u5143\u7d20.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u4e09\u8981\u7d20:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u4e8c\u5143\u51fd\u6570 \\acc x -> function \u6216 \\x acc -> function"),(0,r.kt)("li",{parentName:"ul"},"\u521d\u59cb\u7d2f\u52a0\u503c"),(0,r.kt)("li",{parentName:"ul"},"\u5f85\u6298\u53e0 List"))),(0,r.kt)("li",{parentName:"ul"},"\u5de5\u4f5c\u539f\u7406:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"\u4e0d\u65ad\u4ece List \u4e2d\u53d6\u51fa\u5143\u7d20,\u8fdb\u884c\u4e8c\u5143\u51fd\u6570\u8c03\u7528,\u76f4\u81f3 List \u88ab\u53d6\u7a7a"),(0,r.kt)("li",{parentName:"ul"},"\u8c03\u7528\u53c2\u6570\u5206\u522b\u4e3a \u65b0\u53d6\u51fa\u5143\u7d20 x \u4e0e \u4e4b\u524d n \u6b21\u8c03\u7528\u540e\u7684\u7d2f\u52a0\u503c acc"),(0,r.kt)("li",{parentName:"ul"},"\u8fd4\u56de\u503c\u4f5c\u4e3a\u4e0b\u6b21\u8c03\u7528\u7684\u7d2f\u52a0\u503c acc"))),(0,r.kt)("li",{parentName:"ul"},"\u5de6\u6298\u53e0\u51fd\u6570",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"foldl ",(0,r.kt)("inlineCode",{parentName:"li"},"\\acc x ->")),(0,r.kt)("li",{parentName:"ul"},"foldl1: \u53d6 List \u9996\u5143\u7d20\u4f5c\u4e3a\u521d\u59cb\u7d2f\u52a0\u503c")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"foldl :: (Foldable t) => (b -> a -> b) -> b -> t a -> b\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"sum' :: (Num a) => [a] -> a\nsum' xs = foldl (\\acc x -> acc + x) 0 xs\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u53f3\u6298\u53e0\u51fd\u6570",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"foldr ",(0,r.kt)("inlineCode",{parentName:"li"},"\\x acc ->")),(0,r.kt)("li",{parentName:"ul"},"foldr1: \u53d6 List \u5c3e\u5143\u7d20\u4f5c\u4e3a\u521d\u59cb\u7d2f\u52a0\u503c")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"foldr :: (Foldable t) => (a -> b -> b) -> b -> t a -> b\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"map' :: (a -> b) -> [a] -> [b]\nmap' f xs = foldr (\\x acc -> f x : acc) [] xs\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u66f4\u591a\u8303\u4f8b")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"maximum' :: (Ord a) => [a] -> a\nmaximum' = foldr1 (\\x acc -> if x > acc then x else acc)\n\nreverse' :: [a] -> [a]\nreverse' = foldl (\\acc x -> x : acc) []\n\nproduct' :: (Num a) => [a] -> a\nproduct' = foldr1 (*)\n\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' p = foldr (\\x acc -> if p x then x : acc else acc) []\n\nhead' :: [a] -> a\nhead' = foldr1 (\\x _ -> x)\n\nlast' :: [a] -> a\nlast' = foldl1 (_ x -> x)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"scanl/scanr/scanl1/scanr1 \u51fd\u6570\u4f1a\u5c06\u6bcf\u6b21\u6298\u53e0\u7684\u7ed3\u679c\u90fd\u8bb0\u5f55\u5728\u4e00\u4e2a List \u4e2d")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> scanl (+) 0 [3,5,2,1]\n[0,3,8,10,11]\nghci> scanr (+) 0 [3,5,2,1]\n[11,8,3,1,0]\nghci> scanl1 (\\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]\n[3,4,5,5,7,9,9,9]\nghci> scanl (flip (:)) [] [3,2,1]\n[[],[3],[2,3],[1,2,3]]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u9006\u6ce2\u5170\u8868\u8fbe\u5f0f")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import Data.List\n\nsolveRPN :: String -> Float\nsolveRPN = head . foldl foldingFunction [] . words\nwhere   foldingFunction (x:y:ys) "*" = (x * y):ys\n        foldingFunction (x:y:ys) "+" = (x + y):ys\n        foldingFunction (x:y:ys) "-" = (y - x):ys\n        foldingFunction (x:y:ys) "/" = (y / x):ys\n        foldingFunction (x:y:ys) "^" = (y ** x):ys\n        foldingFunction (x:xs) "ln" = log x:xs\n        foldingFunction xs "sum" = [sum xs]\n        foldingFunction xs numberString = read numberString:xs\n')),(0,r.kt)("h4",{id:"lambda-\u8868\u8fbe\u5f0f"},"lambda \u8868\u8fbe\u5f0f"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"\\args -> function")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> zipWith (\\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]\n[153.0,61.5,31.0,15.75,6.6]\n\nghci> map (\\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]\n[3,8,9,8,7]\n\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f = \\x y -> f y x\n")),(0,r.kt)("h4",{id:"-\u51fd\u6570"},(0,r.kt)("inlineCode",{parentName:"h4"},"$")," \u51fd\u6570"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"($) :: (a -> b) -> a -> b")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u7279\u6027: \u4f18\u5148\u7ea7\u6700\u4f4e,\u53f3\u7ed3\u5408"),(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u6539\u53d8\u4f18\u5148\u7ea7,\u76f8\u5f53\u4e8e\u5728\u53f3\u65b9\u6dfb\u52a0\u62ec\u53f7")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"f (g (z x)) <-> f $ g $ z x\n")),(0,r.kt)("h4",{id:"\u51fd\u6570\u4e0e-function-composition\u51fd\u6570\u7ec4\u5408"},".\u51fd\u6570\u4e0e Function composition(\u51fd\u6570\u7ec4\u5408)"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"(.) :: (b -> c) -> (a -> b) -> a -> c")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"f . g = \\x -> f (g x)")," - f \u7684\u53c2\u6570\u7c7b\u578b\u5fc5\u987b\u4e0e g \u7684\u8fd4\u56de\u503c\u7c7b\u578b\u76f8\u540c"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u529f\u80fd: \u53ef\u4ee5\u53bb\u9664\u51fd\u6570\u8c03\u7528\u62ec\u53f7")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fn x = ceiling (negate (tan (cos (max 50 x))))\n-> \u53bb\u62ec\u53f7: fn x = ceiling . negate . tan . cos . max 50 x\n-> Curry\u5316: fn = ceiling . negate . tan . cos . max 50\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Best Practice: \u4e09\u79cd\u4e0d\u540c\u7684\u51fd\u6570\u5199\u6cd5")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"oddSquareSum :: Integer\noddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))\n\noddSquareSum :: Integer\noddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]\n\noddSquareSum :: Integer\noddSquareSum =\n    let oddSquares = filter odd $ map (^2) [1..]\n        belowLimit = takeWhile (<10000) oddSquares\n    in  sum belowLimit\n")),(0,r.kt)("h3",{id:"\u5e38\u7528\u51fd\u6570"},"\u5e38\u7528\u51fd\u6570"),(0,r.kt)("h4",{id:"\u65e0\u53c2\u51fd\u6570"},"\u65e0\u53c2\u51fd\u6570"),(0,r.kt)("p",null,"\u201c\u5b9a\u4e49\u201d(\u6216\u8005\u201c\u540d\u5b57\u201d)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'sabertaz = "It\'s a-me, sabertaz!"\n')),(0,r.kt)("h4",{id:"\u524d\u7f00\u51fd\u6570"},"\u524d\u7f00\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"> succ 8\n9\n")),(0,r.kt)("p",null,"`","FunctionName","`"," - \u53ef\u4f7f\u524d\u7f00\u51fd\u6570\u53d8\u4e3a\u4e2d\u7f00\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"> 92 `div` 10\n9\n")),(0,r.kt)("h4",{id:"\u4e2d\u7f00\u51fd\u6570"},"\u4e2d\u7f00\u51fd\u6570"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"+"),": \u4ece\u7c7b\u578b\u5b9a\u4e49\u53ef\u4ee5\u770b\u51fa,+\u5de6\u53f3\u4e24\u8fb9\u53c2\u6570\u5fc5\u987b\u4e3a\u540c\u7c7b\u578b"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t (+)\n(+) :: (Num a) => a -> a -> a\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"++"),": List \u8fde\u63a5\u7b26,\u904d\u5386\u524d\u4e00 List"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> [1,2,3,4] ++ [9,10,11,12]\n[1,2,3,4,9,10,11,12]\nghci> "hello" ++ " " ++ "world"\n"hello world"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},":"),": \u8fde\u63a5\u5355\u4e2a\u5143\u7d20"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> \'A\':" SMALL CAT"\n"A SMALL CAT"\nghci> 5:[1,2,3,4,5]\n[5,1,2,3,4,5]\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"!!"),": \u5f15\u7528\u7b26"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> [9.4,33.2,96.2,11.2,23.25] !! 1\n33.2\n")),(0,r.kt)("h4",{id:"\u6570\u5b66\u51fd\u6570"},"\u6570\u5b66\u51fd\u6570"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"x ",(0,r.kt)("inlineCode",{parentName:"li"},"mod")," y"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"even arg")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"odd arg"))),(0,r.kt)("h5",{id:"system-random"},"System Random"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"random :: (RandomGen g, Random a) => g -> (a, g)")),(0,r.kt)("li",{parentName:"ul"},"getStdGen"),(0,r.kt)("li",{parentName:"ul"},"newStdGen")),(0,r.kt)("h4",{id:"\u6570\u5b57\u51fd\u6570"},"\u6570\u5b57\u51fd\u6570"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"fromInteger \u51fd\u6570 (Num a) => Integer -> a"),(0,r.kt)("li",{parentName:"ul"},"fromIntegral \u51fd\u6570 (Integral a, Num b) => a -> b")),(0,r.kt)("h2",{id:"\u6a21\u5757"},"\u6a21\u5757"),(0,r.kt)("h3",{id:"import"},"import"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import Data.List\nimport Data.List (nub\uff0csort)\nimport Data.List hiding (nub)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Data.Map\n")),(0,r.kt)("p",null,"\u8c03\u7528 Map \u4e2d\u7684 filter \u65f6,\u5fc5\u987b\u4f7f\u7528 Data.Map.filter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Data.Map as M\n\nData.Map.filter <-> M.filter\n")),(0,r.kt)("h3",{id:"\u5efa\u7acb\u6a21\u5757"},"\u5efa\u7acb\u6a21\u5757"),(0,r.kt)("h4",{id:"\u5355\u4e00\u6a21\u5757"},"\u5355\u4e00\u6a21\u5757"),(0,r.kt)("p",null,"\u65b0\u5efa\u4e00\u4e2a ",(0,r.kt)("inlineCode",{parentName:"p"},"Geometry.hs")," \u7684\u6587\u4ef6"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"module Geometry\n( sphereVolume\n\uff0csphereArea\n\uff0ccubeVolume\n\uff0ccubeArea\n\uff0ccuboidArea\n\uff0ccuboidVolume\n) where\n\nsphereVolume :: Float -> Float\nsphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)\n\nsphereArea :: Float -> Float\nsphereArea radius = 4 * pi * (radius ^ 2)\n\ncubeVolume :: Float -> Float\ncubeVolume side = cuboidVolume side side side\n\ncubeArea :: Float -> Float\ncubeArea side = cuboidArea side side side\n\ncuboidVolume :: Float -> Float -> Float -> Float\ncuboidVolume a b c = rectangleArea a b * c\n\ncuboidArea :: Float -> Float -> Float -> Float\ncuboidArea a b c =\n  rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2\n\nrectangleArea :: Float -> Float -> Float\nrectangleArea a b = a * b\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import Geometry\n")),(0,r.kt)("h4",{id:"\u5b50\u6a21\u5757"},"\u5b50\u6a21\u5757"),(0,r.kt)("p",null,"\u628a ",(0,r.kt)("inlineCode",{parentName:"p"},"Geometry")," \u5206\u6210\u4e09\u4e2a\u5b50\u6a21\u5757"),(0,r.kt)("p",null,"\u5efa\u7acb\u4e00\u4e2a ",(0,r.kt)("inlineCode",{parentName:"p"},"Geometry")," \u6587\u4ef6\u5939(\u6ce8\u610f",(0,r.kt)("strong",{parentName:"p"},"\u9996\u5b57\u6bcd"),"\u8981\u5927\u5199),\u65b0\u5efa\u4e09\u4e2a\u6587\u4ef6"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"sphere.hs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"module Geometry.Sphere\n( volume\n\uff0carea\n) where\n\nvolume :: Float -> Float\nvolume radius = (4.0 / 3.0) * pi * (radius ^ 3)\n\narea :: Float -> Float\narea radius = 4 * pi * (radius ^ 2)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"cuboid.hs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"module Geometry.Cuboid\n( volume\n\uff0carea\n) where\n\nvolume :: Float -> Float -> Float -> Float\nvolume a b c = rectangleArea a b * c\n\narea :: Float -> Float -> Float -> Float\narea a b c =\n  rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2\n\nrectangleArea :: Float -> Float -> Float\nrectangleArea a b = a * b\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"cube.hs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"module Geometry.Cube\n( volume\n\uff0carea\n) where\n\nimport qualified Geometry.Cuboid as Cuboid\n\nvolume :: Float -> Float\nvolume side = Cuboid.volume side side side\n\narea :: Float -> Float\narea side = Cuboid.area side side side\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import Geometry.Sphere\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Geometry.Sphere as Sphere\nimport qualified Geometry.Cuboid as Cuboid\nimport qualified Geometry.Cube as Cube\n")),(0,r.kt)("h3",{id:"\u5e38\u7528\u57fa\u7840\u6a21\u5757"},"\u5e38\u7528\u57fa\u7840\u6a21\u5757"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/MnO2/learnyouahaskell-zh/blob/develop/zh-cn/ch07/module.md"},"Learn you a haskell for great good")),(0,r.kt)("h4",{id:"datalist"},"Data.List"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"intersperse"),(0,r.kt)("li",{parentName:"ul"},"intercalate"),(0,r.kt)("li",{parentName:"ul"},"transpose")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> transpose [[1,2,3],[4,5,6],[7,8,9]]\n[[1,4,7],[2,5,8],[3,6,9]]\nghci> transpose ["hey","there","guys"]\n["htg","ehu","yey","rs","e"]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]\n[18,8,6,17]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"foldl'")," \u548c ",(0,r.kt)("strong",{parentName:"p"},"foldl1'")," \u662f\u5b83\u4eec\u5404\u81ea\u60f0\u6027\u5b9e\u73b0\u7684\u4e25\u683c\u7248\u672c,\u53ef",(0,r.kt)("strong",{parentName:"p"},"\u9632\u6b62\u6ea2\u51fa"),"\u95ee\u9898."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"concat")," - \u79fb\u9664\u4e00\u7ea7\u5d4c\u5957"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> concat ["foo","bar","car"]\n"foobarcar"\nghci> concat [[3,4,5],[2,3,4],[2,1,1]]\n[3,4,5,2,3,4,2,1,1]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"concatMap")," \u51fd\u6570\u4e0e ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," \u4e00\u4e2a List \u4e4b\u540e\u518d ",(0,r.kt)("inlineCode",{parentName:"p"},"concat")," \u5b83\u7b49\u4ef7"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> concatMap (replicate 4) [1..3]\n[1,1,1,1,2,2,2,2,3,3,3,3]\n")),(0,r.kt)("p",null,"and"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> and $ map (>4) [5,6,7,8]\nTrue\nghci> and $ map (==4) [4,4,4,3,4]\nFalse\n")),(0,r.kt)("p",null,"or"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> or $ map (==4) [2,3,4,5,6,1]\nTrue\nghci> or $ map (>4) [1,2,3]\nFalse\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"any")," \u548c ",(0,r.kt)("strong",{parentName:"p"},"all")," \u4f7f\u7528 ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," \u6216 ",(0,r.kt)("inlineCode",{parentName:"p"},"all")," \u4f1a\u66f4\u591a\u4e9b"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> any (==4) [2,3,5,6,1,4]\nTrue\nghci> all (>4) [6,9,10]\nTrue\nghci> all (`elem` ['A'..'Z']) \"HEYGUYSwhatsup\"\nFalse\nghci> any (`elem` ['A'..'Z']) \"HEYGUYSwhatsup\"\nTrue\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"iterate")," \u53d6\u4e00\u4e2a\u51fd\u6570\u548c\u4e00\u4e2a\u503c\u4f5c\u53c2\u6570\u3002\u5b83\u4f1a\u7528\u8be5\u503c\u53bb\u8c03\u7528\u8be5\u51fd\u6570\u5e76\u7528\u6240\u5f97\u7684\u7ed3\u679c\u518d\u6b21\u8c03\u7528\u8be5\u51fd\u6570\uff0c\u4ea7\u751f\u4e00\u4e2a\u65e0\u9650\u7684 List."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> take 10 $ iterate (*2) 1\n[1,2,4,8,16,32,64,128,256,512]\nghci> take 3 $ iterate (++ "haha") "haha"\n["haha","hahahaha","hahahahahaha"]\n')),(0,r.kt)("p",null,"splitAt"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> splitAt 3 "heyman"\n("hey","man")\nghci> splitAt 100 "heyman"\n("heyman","")\nghci> splitAt (-3) "heyman"\n("","heyman")\nghci> let (a,b) = splitAt 3 "foobar" in b ++ a\n"barfoo"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"takeWhile")," \u4e00\u65e6\u9047\u5230\u4e0d\u7b26\u5408\u6761\u4ef6\u7684\u67d0\u5143\u7d20\u5c31\u505c\u6b62"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]\n[6,5,4]\nghci> takeWhile (/=\' \') "This is a sentence"\n"This"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> sum $ takeWhile (<10000) $ map (^3) [1..]\n53361\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"dropWhile")," \u6254\u6389\u7b26\u5408\u6761\u4ef6\u7684\u5143\u7d20\u3002\u4e00\u65e6\u9650\u5236\u6761\u4ef6\u8fd4\u56de ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),"\uff0c\u5b83\u5c31\u8fd4\u56de List \u7684\u4f59\u4e0b\u90e8\u5206"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> dropWhile (/=\' \') "This is a sentence"\n" is a sentence"\nghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]\n[3,4,5,4,3,2,1]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"span")," - \u6269\u5c55",(0,r.kt)("inlineCode",{parentName:"p"},"takeWhile")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> let (fw\uff0crest) = span (/=\' \')\n\\ "This is a sentence" in "First word:" ++ fw ++ "\uff0cthe rest:" ++ rest\n"First word: This\uff0cthe rest: is a sentence"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"break")," - \u53d6\u53cd",(0,r.kt)("inlineCode",{parentName:"p"},"span")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> break (==4) [1,2,3,4,5,6,7]\n([1,2,3],[4,5,6,7])\nghci> span (/=4) [1,2,3,4,5,6,7]\n([1,2,3],[4,5,6,7])\n")),(0,r.kt)("p",null,"sort"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> sort [8,5,3,2,1,6,4,2]\n[1,2,2,3,4,5,6,8]\nghci> sort "This will be sorted soon"\n" Tbdeehiillnooorssstw"\n')),(0,r.kt)("p",null,"group"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]\n[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> map (\\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]\n[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"inits")," \u548c ",(0,r.kt)("strong",{parentName:"p"},"tails")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> inits "w00t"\n["","w","w0","w00","w00t"]\nghci> tails "w00t"\n["w00t","00t","0t","t",""]\nghci> let w = "w00t" in zip (inits w) (tails w)\n[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"isInfixOf")," \u4ece\u4e00\u4e2a List \u4e2d\u641c\u7d22\u4e00\u4e2a\u5b50 List"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"search :: (Eq a) => [a] -> [a] -> Bool\nsearch needle haystack =\n  let nLen = length needle\n  in foldl (\\acc x -> if take nLen x == needle then True else acc) False (tails haystack)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> "cat" `isInfixOf` "im a cat burglar"\nTrue\nghci> "Cat" `isInfixOf` "im a cat burglar"\nFalse\nghci> "cats" `isInfixOf` "im a cat burglar"\nFalse\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"isPrefixOf")," \u4e0e ",(0,r.kt)("strong",{parentName:"p"},"isSuffixOf")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> "hey" `isPrefixOf` "hey there!"\nTrue\nghci> "hey" `isPrefixOf` "oh hey there!"\nFalse\nghci> "there!" `isSuffixOf` "oh hey there!"\nTrue\nghci> "there!" `isSuffixOf` "oh hey there"\nFalse\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"elem")," \u4e0e ",(0,r.kt)("strong",{parentName:"p"},"notElem")),(0,r.kt)("p",null,"partition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> partition (`elem` [\'A\'..\'Z\']) "BOBsidneyMORGANeddy"\n("BOBMORGAN","sidneyeddy")\nghci> partition (>3) [1,3,5,6,3,2,1,0,3,7]\n([5,6,7],[1,3,3,2,1,0,3])\n')),(0,r.kt)("p",null,"find"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> find (>4) [1,2,3,4,5,6]\nJust 5\nghci> find (>9) [1,2,3,4,5,6]\nNothing\nghci> :t find\nfind :: (a -> Bool) -> [a] -> Maybe a\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"elemIndex")," '\u53ef\u80fd' (Maybe)\u8fd4\u56de\u6211\u4eec\u627e\u7684\u5143\u7d20\u7684\u7d22\u5f15,\u82e5\u8fd9\u4e00\u5143\u7d20\u4e0d\u5b58\u5728\uff0c\u5c31\u8fd4\u56de ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t elemIndex\nelemIndex :: (Eq a) => a -> [a] -> Maybe Int\nghci> 4 `elemIndex` [1,2,3,4,5,6]\nJust 3\nghci> 10 `elemIndex` [1,2,3,4,5,6]\nNothing\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"elemIndices")," \u4e0e",(0,r.kt)("inlineCode",{parentName:"p"},"elemIndex"),"\u76f8\u4f3c."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> ' ' `elemIndices` \"Where are the spaces?\"\n[5,9,13]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"findIndex")," \u4e0e ",(0,r.kt)("inlineCode",{parentName:"p"},"find")," \u76f8\u4f3c.\n",(0,r.kt)("strong",{parentName:"p"},"findIndices")," \u8fd4\u56de\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684\u7d22\u5f15."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> findIndex (==4) [5,3,2,1,6,4]\nJust 5\nghci> findIndex (==7) [5,3,2,1,6,4]\nNothing\nghci> findIndices (`elem` ['A'..'Z']) \"Where Are The Caps?\"\n[0,6,10,14]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> zipWith3 (\\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3]\n[7,9,8]\nghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]\n[(2,2,5,2),(3,2,5,2),(3,2,3,2)]\n")),(0,r.kt)("p",null,"\u5728\u5904\u7406\u6765\u81ea\u6587\u4ef6\u6216\u5176\u5b83\u5730\u65b9\u7684\u8f93\u5165\u65f6\uff0c",(0,r.kt)("strong",{parentName:"p"},"lines")," \u4f1a\u975e\u5e38\u6709\u7528."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> lines "first line\\nsecond line\\nthird line"\n["first line","second line","third line"]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"unlines")," \u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"lines")," \u7684\u53cd\u51fd\u6570."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> unlines ["first line"\uff0c"second line"\uff0c"third line"]\n"first line\\nsecond line\\nthird line\\n"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"words")," \u548c ",(0,r.kt)("strong",{parentName:"p"},"unwords")," \u53ef\u4ee5\u628a\u4e00\u4e2a\u5b57\u4e32\u5206\u4e3a\u4e00\u7ec4\u5355\u8bcd\u6216\u6267\u884c\u76f8\u53cd\u7684\u64cd\u4f5c."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> words "hey these are the words in this sentence"\n["hey","these","are","the","words","in","this","sentence"]\nghci> words "hey these are the words in this\\nsentence"\n["hey","these","are","the","words","in","this","sentence"]\nghci> unwords ["hey","there","mate"]\n"hey there mate"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"nub")," \u53ef\u4ee5\u5c06\u4e00\u4e2a List \u4e2d\u7684\u91cd\u590d\u5143\u7d20\u5168\u90e8\u7b5b\u6389."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> nub [1,2,3,4,3,2,1,2,3,4,3,2,1]\n[1,2,3,4]\nghci> nub "Lots of words and stuff"\n"Lots fwrdanu"\n')),(0,r.kt)("p",null,"delete"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> delete 'h' \"hey there ghang!\"\n\"ey there ghang!\"\nghci> delete 'h' . delete 'h' $ \"hey there ghang!\"\n\"ey tere ghang!\"\nghci> delete 'h' . delete 'h' . delete 'h' $ \"hey there ghang!\"\n\"ey tere gang!\"\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\\")," \u5dee\u96c6"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> [1..10] \\\\ [2,5,9]\n[1,3,4,6,7,8,10]\nghci> "Im a big baby" \\\\ "big"\n"Im a  baby"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"union")," \u5e76\u96c6"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> "hey man" `union` "man what\'s up"\n"hey manwt\'sup"\nghci> [1..7] `union` [5..10]\n[1,2,3,4,5,6,7,8,9,10]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"intersection")," \u4ea4\u96c6"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> [1..7] `intersect` [5..10]\n[5,6,7]\n")),(0,r.kt)("p",null,"insert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> insert 4 [1,2,3,5,6,7]\n[1,2,3,4,5,6,7]\nghci> insert 'g' $ ['a'..'f'] ++ ['h'..'z']\n\"abcdefghijklmnopqrstuvwxyz\"\nghci> insert 3 [1,2,4,3,2,1]\n[1,2,3,4,3,2,1]\n")),(0,r.kt)("h5",{id:"\u4fee\u6b63-prelude-\u6a21\u5757"},"\u4fee\u6b63 Prelude \u6a21\u5757"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"length"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"take"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"drop"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"splitAt"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"!!")," \u548c ",(0,r.kt)("inlineCode",{parentName:"p"},"replicate"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"Data.List")," \u4e2d\u5305\u542b\u4e86\u66f4\u901a\u7528\u7684\u66ff\u4ee3\u7248,\u5982:\n",(0,r.kt)("inlineCode",{parentName:"p"},"genericLength\uff0cgenericTake\uff0cgenericDrop\uff0cgenericSplitAt\uff0cgenericIndex")," \u548c ",(0,r.kt)("inlineCode",{parentName:"p"},"genericReplicate")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"nub"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"delete"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"union"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"intsect")," \u548c ",(0,r.kt)("inlineCode",{parentName:"p"},"group")," \u51fd\u6570\n\u4e5f\u6709\u5404\u81ea\u7684\u901a\u7528\u66ff\u4ee3\u7248 ",(0,r.kt)("inlineCode",{parentName:"p"},"nubBy"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"deleteBy"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"unionBy"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"intersectBy")," \u548c ",(0,r.kt)("inlineCode",{parentName:"p"},"groupBy"),"\uff0c\n\u5b83\u4eec\u7684\u533a\u522b\u5c31\u662f\u524d\u4e00\u7ec4\u51fd\u6570\u4f7f\u7528 ",(0,r.kt)("inlineCode",{parentName:"p"},"(==)")," \u6765\u6d4b\u8bd5\u662f\u5426\u76f8\u7b49\uff0c\u800c\u5e26 ",(0,r.kt)("inlineCode",{parentName:"p"},"By")," \u7684\u90a3\u7ec4\u5219\u53d6\u4e00\u4e2a\u51fd\u6570\u4f5c\u53c2\u6570\u6765\u5224\u5b9a\u76f8\u7b49\u6027."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> let values = [-4.3\uff0c-2.4\uff0c-1.2\uff0c0.4\uff0c2.3\uff0c5.9\uff0c10.5\uff0c29.1\uff0c5.3\uff0c-2.4\uff0c-14.5\uff0c2.9\uff0c2.3]\nghci> groupBy (\\x y -> (x > 0) == (y > 0)) values\n[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\nf `on` g = \\x y -> f (g x) (g y)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> groupBy ((==) `on` (> 0)) values\n[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"sort"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"insert"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"maximum")," \u548c ",(0,r.kt)("inlineCode",{parentName:"p"},"min")," \u90fd\u6709\u5404\u81ea\u7684\u901a\u7528\u7248\u672c\u3002\n\u5982 ",(0,r.kt)("inlineCode",{parentName:"p"},"groupBy")," \u7c7b\u4f3c\uff0c",(0,r.kt)("strong",{parentName:"p"},"sortBy"),"\uff0c",(0,r.kt)("strong",{parentName:"p"},"insertBy"),"\uff0c",(0,r.kt)("strong",{parentName:"p"},"maximumBy"),"\n\u548c ",(0,r.kt)("strong",{parentName:"p"},"minimumBy")," \u90fd\u53d6\u4e00\u4e2a\u51fd\u6570\u6765\u6bd4\u8f83\u4e24\u4e2a\u5143\u7d20\u7684\u5927\u5c0f."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]\nghci> sortBy (compare `on` length) xs\n[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]\n")),(0,r.kt)("h4",{id:"data-char"},"Data Char"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isControl")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u662f\u63a7\u5236\u5b57\u7b26\u3002"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isSpace")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u662f\u7a7a\u683c\u5b57\u7b26\uff0c\u5305\u62ec\u7a7a\u683c\uff0ctab\uff0c\u6362\u884c\u7b26\u7b49."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isLower")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5c0f\u5199."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isUpper")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5927\u5199\u3002"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isAlpha")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5b57\u6bcd."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isAlphaNum")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5b57\u6bcd\u6216\u6570\u5b57."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isPrint")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u662f\u53ef\u6253\u5370\u7684."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isDigit")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u6570\u5b57."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isOctDigit")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u516b\u8fdb\u5236\u6570\u5b57."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isHexDigit")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5341\u516d\u8fdb\u5236\u6570\u5b57."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isLetter")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5b57\u6bcd."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isMark")," \u5224\u65ad\u662f\u5426\u4e3a unicode \u6ce8\u97f3\u5b57\u7b26\uff0c\u4f60\u5982\u679c\u662f\u6cd5\u56fd\u4eba\u5c31\u4f1a\u7ecf\u5e38\u7528\u5230\u7684."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isNumber")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u6570\u5b57."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isPunctuation")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u6807\u70b9\u7b26\u53f7."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isSymbol"),"\u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u8d27\u5e01\u7b26\u53f7."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isSeparator")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a unicode \u7a7a\u683c\u6216\u5206\u9694\u7b26."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isAscii")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u5728 unicode \u5b57\u6bcd\u8868\u7684\u524d 128 \u4f4d\u3002"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isLatin1")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u5728 unicode \u5b57\u6bcd\u8868\u7684\u524d 256 \u4f4d."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isAsciiUpper")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5927\u5199\u7684 ascii \u5b57\u7b26."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"isAsciiLower")," \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\u5c0f\u5199\u7684 ascii \u5b57\u7b26.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> all isAlphaNum "bobby283"\nTrue\nghci> all isAlphaNum "eddy the fish!"\nFalse\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> words "hey guys its me"\n["hey","guys","its","me"]\nghci> groupBy ((==) `on` isSpace) "hey guys its me"\n["hey"," ","guys"," ","its"," ","me"]\nghci>\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"\n["hey","guys","its","me"]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> generalCategory ' '\nSpace\nghci> generalCategory 'A'\nUppercaseLetter\nghci> generalCategory 'a'\nLowercaseLetter\nghci> generalCategory '.'\nOtherPunctuation\nghci> generalCategory '9'\nDecimalNumber\nghci> map generalCategory \" \\t\\nA9?|\"\n[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"toUpper")," \u5c06\u4e00\u4e2a\u5b57\u7b26\u8f6c\u4e3a\u5927\u5199\u5b57\u6bcd\uff0c\u82e5\u8be5\u5b57\u7b26\u4e0d\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u5c31\u6309\u539f\u503c\u8fd4\u56de."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"toLower")," \u5c06\u4e00\u4e2a\u5b57\u7b26\u8f6c\u4e3a\u5c0f\u5199\u5b57\u6bcd\uff0c\u82e5\u8be5\u5b57\u7b26\u4e0d\u662f\u5927\u5199\u5b57\u6bcd\uff0c\u5c31\u6309\u539f\u503c\u8fd4\u56de."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"toTitle")," \u5c06\u4e00\u4e2a\u5b57\u7b26\u8f6c\u4e3a title-case\uff0c\u5bf9\u5927\u591a\u6570\u5b57\u5143\u800c\u8a00\uff0ctitle-case \u5c31\u662f\u5927\u5199."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"digitToInt")," \u5c06\u4e00\u4e2a\u5b57\u7b26\u8f6c\u4e3a Int \u503c\uff0c\u800c\u8fd9\u4e00\u5b57\u7b26\u5fc5\u987b\u5f97\u5728 ",(0,r.kt)("inlineCode",{parentName:"li"},"'1'..'9','a'..'f'"),"\u6216",(0,r.kt)("inlineCode",{parentName:"li"},"'A'..'F'")," \u7684\u8303\u56f4\u4e4b\u5185.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> map digitToInt "34538"\n[3,4,5,3,8]\nghci> map digitToInt "FF85AB"\n[15,15,8,5,10,11]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> intToDigit 15\n'f'\nghci> intToDigit 5\n'5'\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"ord")," \u4e0e ",(0,r.kt)("strong",{parentName:"p"},"char")," \u51fd\u6570\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e0e\u5176\u5bf9\u5e94\u7684\u6570\u5b57\u76f8\u4e92\u8f6c\u6362."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> ord 'a'\n97\nghci> chr 97\n'a'\nghci> map ord \"abcdefgh\"\n[97,98,99,100,101,102,103,104]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"encode :: Int -> String -> String\nencode shift msg =\n  let ords = map ord msg\n      shifted = map (+ shift) ords\n  in map chr shifted\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"decode :: Int -> String -> String\ndecode shift msg = encode (negate shift) msg\n")),(0,r.kt)("h4",{id:"data-map"},"Data Map"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"findKey :: (Eq k) => k -> [(k,v)] -> v\nfindKey key xs = snd . head . filter (\\(k,v) -> key == k) $ xs\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"findKey :: (Eq k) => k -> [(k,v)] -> Maybe v\nfindKey key [] = Nothing\nfindKey key ((k,v):xs) =\n     if key == k then\n         Just v\n     else\n         findKey key xs\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"findKey :: (Eq k) => k -> [(k,v)] -> Maybe v\nfindKey key = foldr (\\(k,v) acc -> if key == k then Just v else acc) Nothing\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"fromList")," \u53d6\u4e00\u4e2a\u5173\u8054\u5217\u8868\uff0c\u8fd4\u56de\u4e00\u4e2a\u4e0e\u4e4b\u7b49\u4ef7\u7684 Map\u3002"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Map.fromList :: (Ord k) => [(k\uff0cv)] -> Map.Map k v\n")),(0,r.kt)("p",null,"\u82e5\u5176\u4e2d\u5b58\u5728\u91cd\u590d\u7684\u952e,\u5c31\u5c06\u5176\u5ffd\u7565."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.empty\nfromList []\n")),(0,r.kt)("p",null,"insert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))\nfromList [(3,100),(4,200),(5,600)]\nghci> Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty\nfromList [(3,100),(4,200),(5,600)]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fromList' :: (Ord k) => [(k,v)] -> Map.Map k v\nfromList' = foldr (\\(k,v) acc -> Map.insert k v acc) Map.empty\n")),(0,r.kt)("p",null,"null"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.null Map.empty\nTrue\n")),(0,r.kt)("p",null,"size"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]\n5\n")),(0,r.kt)("p",null,"singleton"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.singleton 3 9\nfromList [(3,9)]\nghci> Map.insert 5 9 $ Map.singleton 3 9\nfromList [(3,9),(5,9)]\n")),(0,r.kt)("p",null,"lookup"),(0,r.kt)("p",null,"member"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]\nTrue\nghci> Map.member 3 $ Map.fromList [(2,5),(4,5)]\nFalse\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"map")," \u4e0e ",(0,r.kt)("strong",{parentName:"p"},"filter")," \u4e0e\u5176\u5bf9\u5e94\u7684 ",(0,r.kt)("inlineCode",{parentName:"p"},"List")," \u7248\u672c\u76f8\u4f3c"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"toList")," \u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"fromList")," \u7684\u53cd\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.toList . Map.insert 9 2 $ Map.singleton 4 3\n[(4,3),(9,2)]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"keys")," \u4e0e ",(0,r.kt)("strong",{parentName:"p"},"elems")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'phoneBook =\n    [("betty","555-2938")\n    ,("betty","342-2492")\n    ,("bonnie","452-2928")\n    ,("patsy","493-2928")\n    ,("patsy","943-2929")\n    ,("patsy","827-9162")\n    ,("lucille","205-2928")\n    ,("wendy","939-8282")\n    ,("penny","853-2492")\n    ,("penny","555-2111")\n    ]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'phoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String\nphoneBookToMap xs = Map.fromListWith\n  (\\number1 number2 -> number1 ++ ", " ++ number2) xs\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Map.lookup "patsy" $ phoneBookToMap phoneBook\n"827-9162, 943-2929, 493-2928"\nghci> Map.lookup "wendy" $ phoneBookToMap phoneBook\n"939-8282"\nghci> Map.lookup "betty" $ phoneBookToMap phoneBook\n"342-2492\uff0c555-2938"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'phoneBookToMap :: (Ord k) => [(k\uff0ca)] -> Map.Map k [a]\nphoneBookToMap xs = Map.fromListWith (++) $ map (\\(k,v) -> (k,[v])) xs\nghci> Map.lookup "patsy" $ phoneBookToMap phoneBook\n["827-9162","943-2929","493-2928"]\n')),(0,r.kt)("p",null,"\u5728\u9047\u5230\u91cd\u590d\u5143\u7d20\u65f6\uff0c\u5355\u9009\u6700\u5927\u7684\u90a3\u4e2a\u503c."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]\nfromList [(2,100),(3,29),(4,22)]\n")),(0,r.kt)("p",null,"\u5c06\u76f8\u540c\u952e\u7684\u503c\u90fd\u52a0\u5728\u4e00\u8d77."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]\nfromList [(2,108),(3,62),(4,37)]\n")),(0,r.kt)("p",null,"insertWith"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]\nfromList [(3,104),(5,103),(6,339)]\n")),(0,r.kt)("h4",{id:"data-set"},"Data Set"),(0,r.kt)("p",null,"\u5185\u90e8\u5143\u7d20\u6392\u5e8f\u4e14\u552f\u4e00"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Data.Set as Set\n")),(0,r.kt)("p",null,"fromList"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> let set1 = Set.fromList text1\nghci> let set2 = Set.fromList text2\nghci> set1\nfromList " .?AIRadefhijlmnorstuy"\nghci> set2\nfromList " !Tabcdefghilmnorstuvwy"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Set.intersection set1 set2\nfromList " adefhilmnorstuy"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"difference")," \u5dee\u96c6"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Set.difference set1 set2\nfromList ".?AIRj"\nghci> Set.difference set2 set1\nfromList "!Tbcgvw"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"union")," \u5e76\u96c6"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Set.union set1 set2\nfromList " !.?AIRTabcdefghijlmnorstuvwy"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"null"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"size"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"member"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"empty"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"singleton"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"insert"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"delete")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Set.null Set.empty\nTrue\nghci> Set.null $ Set.fromList [3,4,5,5,4,3]\nFalse\nghci> Set.size $ Set.fromList [3,4,5,3,4,5]\n3\nghci> Set.singleton 9\nfromList [9]\nghci> Set.insert 4 $ Set.fromList [9,3,8,1]\nfromList [1,3,4,8,9]\nghci> Set.insert 8 $ Set.fromList [5..10]\nfromList [5,6,7,8,9,10]\nghci> Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]\nfromList [3,5]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]\nTrue\nghci> Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]\nTrue\nghci> Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]\nFalse\nghci> Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]\nFalse\n")),(0,r.kt)("p",null,"\u6267\u884c ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," \u548c ",(0,r.kt)("inlineCode",{parentName:"p"},"filter"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]\nfromList [3,5,7]\nghci> Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]\nfromList [3,4,5,6,7,8]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5220\u9664\u91cd\u590d\u5143\u7d20")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> let setNub xs = Set.toList $ Set.fromList xs\nghci> setNub "HEY WHATS CRACKALACKIN"\n" ACEHIKLNRSTWY"\nghci> nub "HEY WHATS CRACKALACKIN"\n"HEY WATSCRKLIN"\n')),(0,r.kt)("h2",{id:"\u8f93\u5165\u4e0e\u8f93\u51fa"},"\u8f93\u5165\u4e0e\u8f93\u51fa"),(0,r.kt)("h3",{id:"io-action"},"IO action"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"name <- IO action"),": \u5c06 action \u7ed1\u5b9a\u81f3\u540d\u5b57\u4e0a,IO String -> String"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"name <- getLine\nname <- return String\n\nname <- putStrLn String\n")),(0,r.kt)("p",null,"\u5728\u4e00\u4e2a",(0,r.kt)("inlineCode",{parentName:"p"},"do block"),"\u4e2d,\u6700\u540e\u4e00\u4e2a",(0,r.kt)("inlineCode",{parentName:"p"},"action"),"\u4e0d\u80fd\u7ed1\u5b9a\u4efb\u4f55\u540d\u5b57,\u5b83\u4f1a\u88ab\u7ed1\u5b9a\u6210\u4e3a",(0,r.kt)("inlineCode",{parentName:"p"},"do block"),"\u7684\u7ed3\u679c\u503c."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'main = do\n    foo <- putStrLn "Hello, what\'s your name?"\n    name <- getLine\n    putStrLn ("Hey " ++ name ++ ", you rock!")\n')),(0,r.kt)("h4",{id:"return"},"return"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"return \u529f\u80fd:\u5c06 pure value \u5305\u6210 I/O actions,\u4e0d\u4f1a\u7ec8\u6b62\u51fd\u6570/\u7a0b\u5e8f"),(0,r.kt)("li",{parentName:"ul"},"return \u4f5c\u7528:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if condition then I/O action else I/O action"),(0,r.kt)("li",{parentName:"ul"},"\u6539\u53d8",(0,r.kt)("inlineCode",{parentName:"li"},"do block\u5f62\u6210\u7684I/O action"),"\u7684\u7ed3\u679c\u503c: otherIOAction -> return pureValue")))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'e.g return "haha" - String -> IO String')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"main = do\n    line <- getLine\n    if null line\n        then return ()\n        else do\n            putStrLn $ reverseWords line\n            main\n\nreverseWords :: String -> String\nreverseWords = unwords . map reverse . words\n")),(0,r.kt)("h3",{id:"command-line"},"Command Line"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"System.Environment")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"getArgs: ",(0,r.kt)("inlineCode",{parentName:"li"},"getArgs :: IO [String]")),(0,r.kt)("li",{parentName:"ul"},"getProgName: ",(0,r.kt)("inlineCode",{parentName:"li"},"getProgName :: IO String"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import System.Environment\nimport Data.List\n\nmain = do\n    args <- getArgs\n    progName <- getProgName\n    mapM putStrLn args\n    putStrLn progName\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import System.Environment\nimport System.Directory\nimport System.IO\nimport Data.List\n\ndispatch :: [(String, [String] -> IO ())]\ndispatch =  [ ("add", add)\n            , ("view", view)\n            , ("remove", remove)\n            ]\n\nmain = do\n    (command:args) <- getArgs\n    let (Just action) = lookup command dispatch\n    action args\n\nadd :: [String] -> IO ()\nadd [fileName, todoItem] = appendFile fileName (todoItem ++ "\\n")\n\nview :: [String] -> IO ()\nview [fileName] = do\n    contents <- readFile fileName\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ " - " ++ line) [0..] todoTasks\n    putStr $ unlines numberedTasks\n\nremove :: [String] -> IO ()\nremove [fileName, numberString] = do\n    handle <- openFile fileName ReadMode\n    (tempName, tempHandle) <- openTempFile "." "temp"\n    contents <- hGetContents handle\n    let number = read numberString\n        todoTasks = lines contents\n        newTodoItems = delete (todoTasks !! number) todoTasks\n    hPutStr tempHandle $ unlines newTodoItems\n    hClose handle\n    hClose tempHandle\n    removeFile fileName\n    renameFile tempName fileName\n')),(0,r.kt)("h3",{id:"bytestring"},"ByteString"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Data.ByteString")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Data.ByteString.Lazy"))),(0,r.kt)("p",null,"lazy byteStrings \u50cf\u88c5\u4e86\u4e00\u5806\u5927\u5c0f\u4e3a 64K \u7684 strict byteStrings \u7684 list"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Data.ByteString.Lazy as B\nimport qualified Data.ByteString as S\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pack/unpack"),(0,r.kt)("li",{parentName:"ul"},"fromChunks/toChunks"),(0,r.kt)("li",{parentName:"ul"},"cons/empty/head/tail/init/null/length/map/reverse/foldl/foldr/concat/takeWhile/filter")),(0,r.kt)("h3",{id:"\u5e38\u7528\u8f93\u5165\u8f93\u51fa\u51fd\u6570"},"\u5e38\u7528\u8f93\u5165\u8f93\u51fa\u51fd\u6570"),(0,r.kt)("h4",{id:"\u8f93\u51fa"},"\u8f93\u51fa"),(0,r.kt)("h5",{id:"output-string"},"Output String"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"putChar"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"putStr"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"putStrLn"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"putStr :: String -> IO ()\nputStr [] = return ()\nputStr (x:xs) = do\n    putChar x\n    putStr xs\n")),(0,r.kt)("h5",{id:"print"},"print"),(0,r.kt)("p",null,"print = putStrLn . show"),(0,r.kt)("h5",{id:"file-system-io"},"File System IO"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hPutStr")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hPutStrLn"))),(0,r.kt)("h6",{id:"write-file"},"Write File"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"writefile :: FilePath -> String -> IO ()")," - WriteMode, not AppendMode"),(0,r.kt)("h6",{id:"append-file"},"Append File"),(0,r.kt)("h4",{id:"\u8f93\u5165"},"\u8f93\u5165"),(0,r.kt)("h5",{id:"getchar--io-char"},"getChar :: IO Char"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"main = do\n    c <- getChar\n    if c /= ' '\n        then do\n            putChar c\n            main\n        else return ()\n")),(0,r.kt)("h5",{id:"get-contents"},"Get Contents"),(0,r.kt)("p",null,"getContents :: IO String (Lazy I/O) - \u5185\u5bb9\u6682\u5b58\u5728\u6587\u4ef6,\u9700\u8981\u4f7f\u7528\u65f6\u8bfb\u53d6\u81f3\u5185\u5b58\u533a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import Data.Char\n\nmain = do\n    contents <- getContents\n    putStr (map toUpper contents)\n")),(0,r.kt)("h5",{id:"file"},"File"),(0,r.kt)("h6",{id:"handle"},"handle"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"openFile :: FilePath(String) -> IOMode -> IO Handle"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"hGetContents :: Handle -> IO String"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"hClose :: Handle -> IO ()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"hGetChar"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"hGetLine")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import System.IO\n\nmain = do\n    handle <- openFile "girlfriend.txt" ReadMode\n    contents <- hGetContents handle\n    putStr contents\n    hClose handle\n')),(0,r.kt)("h6",{id:"with-file"},"With File"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import System.IO\n\nmain = do\n    withFile "girlfriend.txt" ReadMode (\\handle -> do\n            contents <- hGetContents handle\n            putStr contents)\n')),(0,r.kt)("h6",{id:"read-file"},"Read File"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'contents <- readFile "girlfriend.txt"\n')),(0,r.kt)("h4",{id:"action"},"Action"),(0,r.kt)("h5",{id:"when"},"When"),(0,r.kt)("p",null,"Control.Monad.when :: (Applicative f) => Bool -> f () -> f ()"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"when bool\u8868\u8fbe\u5f0f I/O-Action")," - \u771f\u65f6\u8fd4\u56de Action,\u5047\u65f6",(0,r.kt)("inlineCode",{parentName:"p"},"return ()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import Control.Monad\n\nmain = do\n    c <- getChar\n    when (c /= ' ') $ do\n        putChar c\n        main\n")),(0,r.kt)("h5",{id:"sequence"},"sequence"),(0,r.kt)("p",null,"sequence :: ",(0,r.kt)("inlineCode",{parentName:"p"},"[IO a]")," -> IO ",(0,r.kt)("inlineCode",{parentName:"p"},"[a]")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"main = do\n    rs <- sequence [getLine, getLine, getLine]\n    print rs\n")),(0,r.kt)("h5",{id:"map"},"Map"),(0,r.kt)("p",null,"mapM, Control.Monad.forM:"),(0,r.kt)("p",null,"= sequence . map"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> mapM print [1,2,3]\n1\n2\n3\n[(),(),()]\nghci> mapM_ print [1,2,3]\n1\n2\n3\n")),(0,r.kt)("h5",{id:"control-monad-forever"},"Control Monad forever"),(0,r.kt)("p",null,"\u63a5\u53d7\u4e00\u4e2a I/O action \u5e76\u56de\u4f20\u4e00\u4e2a\u6c38\u8fdc\u4f5c\u540c\u4e00\u4ef6\u4e8b\u7684 I/O action"),(0,r.kt)("p",null,"\u4ee5\u4e0b\u4ee3\u7801\u5b9e\u73b0\u4e86\u5faa\u73af\u7ed3\u6784:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import Control.Monad\nimport Data.Char\n\nmain = forever $ do\n    putStr "Give me some input: "\n    l <- getLine\n    putStrLn $ map toUpper l\n')),(0,r.kt)("h5",{id:"hsetbuffering"},"hSetBuffering"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"hSetBuffering :: Handle -> BufferMode -> IO ()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'main = do\n    withFile "something.txt" ReadMode (\\handle -> do\n        hSetBuffering handle $ BlockBuffering (Just 2048)\n        contents <- hGetContents handle\n        putStr contents)\n')),(0,r.kt)("h5",{id:"hflush"},"hFlush"),(0,r.kt)("h4",{id:"other"},"Other"),(0,r.kt)("h5",{id:"lines"},"lines"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"lines :: String -> [String]")," - \u6309\u6362\u884c\u7b26\u5c06\u6bb5\u843d\u5207\u5272\u6210\u53e5\u5b50"),(0,r.kt)("h5",{id:"interact"},"interact"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"arguments: String -> String \u7684\u51fd\u6570"),(0,r.kt)("li",{parentName:"ul"},"return: \u4e00\u4e2a I/O action"),(0,r.kt)("li",{parentName:"ul"},"function: I/O action \u4f1a\u8bfb\u53d6\u8f93\u5165\uff0c\u8c03\u7528\u63d0\u4f9b\u7684\u51fd\u6570\uff0c\u7136\u540e\u628a\u51fd\u6570\u7684\u7ed3\u679c\u6253\u5370\u51fa\u6765")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"main = interact shortLinesOnly\n\nshortLinesOnly :: String -> String\nshortLinesOnly input =\n    let allLines = lines input\n        shortLines = filter (\\line -> length line < 10) allLines\n        result = unlines shortLines\n    in result\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"main = interact $ unlines . filter ((<10) . length) . lines\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'respondPalindromes = unlines . map (\\xs ->\n    if isPalindrome xs then "palindrome" else "not a palindrome") . lines\n        where isPalindrome xs = xs == reverse xs\n')),(0,r.kt)("h5",{id:"system-directory"},"System Directory"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"removeFile"),(0,r.kt)("li",{parentName:"ul"},"renameFile")),(0,r.kt)("h2",{id:"\u5f02\u5e38"},"\u5f02\u5e38"),(0,r.kt)("p",null,"System.IO.Error"),(0,r.kt)("h3",{id:"catch"},"catch"),(0,r.kt)("p",null,"catch :: IO a -> (IOError -> IO a) -> IO a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import System.Environment\nimport System.IO\nimport System.IO.Error\n\nmain = toTry `catch` handler\n\ntoTry :: IO ()\ntoTry = do (fileName:_) <- getArgs\n            contents <- readFile fileName\n            putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"\n\nhandler :: IOError -> IO ()\nhandler e\n    | isDoesNotExistError e = putStrLn "The file doesn\'t exist!"\n    | isFullError e = freeSomeSpace\n    | isIllegalOperation e = notifyCops\n    | otherwise = ioError e\n')),(0,r.kt)("h2",{id:"advanced-monad"},"Advanced Monad"),(0,r.kt)("h3",{id:"writer-monad"},"Writer Monad"),(0,r.kt)("p",null,"Writer \u53ef\u4ee5\u8ba9\u6211\u4eec\u5728\u8ba1\u7b97\u7684\u540c\u65f6\u641c\u96c6\u6240\u6709 log \u7eaa\u5f55\uff0c\u5e76\u6c47\u96c6\u6210\u4e00\u4e2a log \u5e76\u9644\u52a0\u5728\u7ed3\u679c\u4e0a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"applyLog :: (a,String) -> (a -> (b,String)) -> (b,String)\napplyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> (30, "A freaking platoon.") `applyLog` isBigGang\n(True,"A freaking platoon.Compared gang size to 9")\nghci> ("BathCat","Got outlaw name.") `applyLog` (\\x -> (length x, "Applied length"))\n(7,"Got outlaw name.Applied length")\n')),(0,r.kt)("h4",{id:"control-monad-writer"},"Control Monad Writer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance (Monoid w) => Monad (Writer w) where\n    return x = Writer (x, mempty)\n    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import Control.Monad.Writer\n\nlogNumber :: Int -> Writer [String] Int\nlogNumber x = Writer (x, ["Got number: " ++ show x])\n\nmultiWithLog :: Writer [String] Int\nmultiWithLog = do\n    a <- logNumber 3\n    b <- logNumber 5\n    return (a*b)\n')),(0,r.kt)("h3",{id:"reader-monad"},"Reader Monad"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monad ((->) r) where\n    return x = _ -> x\n    h >>= f = \\w -> f (h w) w\n")),(0,r.kt)("h3",{id:"state-monad"},"State Monad"),(0,r.kt)("h4",{id:"control-monad-state"},"Control Monad State"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype State s a = State { runState :: s -> (a,s) }\n\ninstance Monad (State s) where\n    return x = State $ \\s -> (x,s)\n    (State h) >>= f = State $ \\s -> let (a, newState) = h s\n                                        (State g) = f a\n                                    in  g newState\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"get = State $ \\s -> (s,s)\nput newState = State $ \\s -> ((),newState)\n")),(0,r.kt)("h4",{id:"state-monad-case"},"State Monad Case"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import Control.Monad.State\n\npop :: State Stack Int\npop = State $ \\(x:xs) -> (x,xs)\n\npush :: Int -> State Stack ()\npush a = State $ \\xs -> ((),a:xs)\n\nstackManipulation :: State Stack Int\nstackManipulation = do\n  push 3\n  a <- pop\n  pop\n")),(0,r.kt)("h3",{id:"error-monad"},"Error Monad"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance (Error e) => Monad (Either e) where\n    return x = Right x\n    Right x >>= f = f x\n    Left err >>= f = Left err\n    fail msg = Left (strMsg msg)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> :t strMsg\nstrMsg :: (Error a) => String -> a\nghci> strMsg "boom!" :: String\n"boom!"\n')),(0,r.kt)("h4",{id:"liftm"},"liftM"),(0,r.kt)("h4",{id:"join"},"join"),(0,r.kt)("h4",{id:"filterm"},"filterM"),(0,r.kt)("h4",{id:"foldm"},"foldM"),(0,r.kt)("h4",{id:"\u7ec4\u5408\u51fd\u6570"},(0,r.kt)("inlineCode",{parentName:"h4"},"<=<"),"(\u7ec4\u5408\u51fd\u6570)"),(0,r.kt)("h3",{id:"self-defined-monad"},"Self-Defined Monad"),(0,r.kt)("h2",{id:"\u6ce8\u91ca"},"\u6ce8\u91ca"),(0,r.kt)("h3",{id:"\u7b26\u53f7"},"\u7b26\u53f7"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"--")," \u5355\u884c\u6ce8\u91ca"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"{- -}")," \u5757\u6ce8\u91ca"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"{-# #-}")," (\u6587\u4ef6\u5934\u90e8)\u7f16\u8bd1\u5668\u53c2\u6570")),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/MnO2/learnyouahaskell-zh"},"Haskell Book"))))}d.isMDXComponent=!0},1779:function(e,a){a.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKwAAAFcCAMAAABiCqVHAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAMAUExURdavsZibp4uNlywySC0JCxcaJrjCaUkwMaWost2VmYaOTXmBPpCQkMVJUevu1a5YXTAwMGBgYBcZBFtlEnBwcISIZ2ZpTlBQUG10NUpOLXF1hkpMVW5KTNLUw5p5e1dbaKlkaLaYmrK0o2cjJ41qbB0gLyAgIJhUWAAAAKSlqz1DWTYYGhAQEIZDR5OVnKk+RWVlaSIkEzM0OTo8RRIUHXR1eyksNjA3T70qM5OjHEBAQPPz89nZ2cDAwICAgObm5szMzPDw8CQpOwwNE9DQ0ODg4F4VGY0fJqCgoLCwsBcFBklRDgsCA256FSQoB7EnL1ISFgYGCXYaH0YPE4mYGqUkLGoXHAkKDvn5+ZkiKezs7GRpe+/v7yElNjsND9/f34EcI9zc3HeEFgkKAdLS0vz8/A8RGCcsQDc9CtXV1VJbD+Li4szN08/Pz+bm6UBHDPPz9O/KzPb29unp6S0yCICOGq66VeToyGVwE/vy836Ckc1fZvPX2fn68ffl5r/ByLK0vZmoKisiI8E3P+avsyYmKcnRjvL040pQZNR6f6uio9vS06CuOBkaEWxtc+vi44ZPU9Fsc4uCg7OztMnKzrelpicVFtDXnOKipt3iuDk6MYODhKe0RqOjpENDROi8vq+xuGIuMYmKgTQ5S2tiY9na3jQ4F8PDxFlaXtfFxtbW2at9f9fdqqSoh0sdH1JUXePHyRkaHpttb1dFRquulcLLf7+ztLq7rVBXHDE1Rry9w5uSk5manruNj2lqYWlqbndlZktCQ7U0PDsyM1YfIxsSE8vCw1laUZ5ITVhdb7S4l2c8PnonLHNXWYKEjTs+JZGSlrJydpeFhnY/Q4KLP6mqoakyOdPT1F1iOGtufImKjjk6PnyAX0ZJUXtyc3l6cVJUQ1tSU5OWfcnKwamqrs6FicaPk9qHjCkqLqKrX4YqL4o3PJ0vNnh7hId1diosG9TYt6Zvcz1CGMTIp8LEs83SqCUoMpY6P9afo9rcyy8xOK2yiJWgQ2dVVqOHif///wX7ZP8AAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAAAcB0lEQVR42uydB3zb1p3HbROM4xROAYoNE9uNkzpEXmK0TRy1ACEBMghuUSIpSqQka1myJdmWLQ858WjsxI6bpBlN0zR7NN37uq7jmrbXvXu9vZobvT16vX3XW7j3HgBOgCZFioDv9D7JJzEtAl89/N///94f7/f+a9Qmmih+8Mib1Pa1NU18V0oQyXTqhUsCliZ4PjURuf9SgKUjPGzRxHn7YWWSBQCwsjXrAI9bMmU3rEzf2ts3GAjsv/VKi+/50horT3zbZtgwOx/AbRA8a/G9tyR12Mwam2GFpYDeQOBeiy8CASRh7w4wNrsuERwvwt5h/r04oONUkh/aLtoMK/Qizo7pWrDQyyZzqdw3QqrNsOC/ECvz3SKsbOIVhOgQwcZUm2FjHsQKxDuKsAL0YmETWIIAQthWWKojEOhjfdIdhQEWAgqnVBonSCFnkEozso2wMoAOtl+KUxos+oTxAc5NimIZbyKq+a4BJmQfbLw/EJiGoQv8PYJ9ELldSWVc7oyigFLaiQEjLJD2wUrQFyzS0CY/Cq3Bczu2YgbMcRw3ly+F/XUjhg0I9sEKJwIBTxxCXwVh+9+MrCDjD7o4N6B8peb5ADsQ/duNEHYkccY2WGoaRllVg+1Ygs4gTAEg5LnxyllN3Cew21DXgg22wQLYoejB+q6G5vA541PGNUdVD3uRwLBvsxO2V4IPn4URrP8nxqchCpQP+iNHkDFnMex5O2GXYGCi+9GkyzLYegmQ/fb955BHSAHevgHWF+inJcEDvW2v9TgX3nI6nSQSiDWbXTEzCF0M1rsYOC5JP74bdqzns5aXiTPef5iKDESjkQSxYqswCQha83lfMocNoT7FbelLNS4UlrTr0NevnOMS/EGtjSsf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"}}]);