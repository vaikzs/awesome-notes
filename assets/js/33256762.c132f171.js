"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[4816],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return c}});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var u=a.createContext({}),s=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,u=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=s(t),c=l,g=m["".concat(u,".").concat(c)]||m[c]||p[c]||i;return t?a.createElement(g,r(r({ref:n},d),{},{components:t})):a.createElement(g,r({ref:n},d))}));function c(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=m;var o={};for(var u in n)hasOwnProperty.call(n,u)&&(o[u]=n[u]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var s=2;s<i;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7433:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return u},default:function(){return c},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return p}});var a=t(7462),l=t(3366),i=(t(7294),t(3905)),r=["components"],o={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Language","Verilog"]},u="Verilog Basic Notes",s={unversionedId:"language/verilog/verilogBasicNotes",id:"language/verilog/verilogBasicNotes",title:"Verilog Basic Notes",description:"General Flow",source:"@site/notes/language/verilog/verilogBasicNotes.md",sourceDirName:"language/verilog",slug:"/language/verilog/verilogBasicNotes",permalink:"/awesome-notes/language/verilog/verilogBasicNotes",editUrl:"https://github.com/sabertazimi/awesome-notes/edit/main/notes/language/verilog/verilogBasicNotes.md",tags:[{label:"Language",permalink:"/awesome-notes/tags/language"},{label:"Verilog",permalink:"/awesome-notes/tags/verilog"}],version:"current",lastUpdatedBy:"sabertazimi",lastUpdatedAt:1649250539,formattedLastUpdatedAt:"4/6/2022",frontMatter:{author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Language","Verilog"]},sidebar:"sidebar",previous:{title:"Rust Basic Notes",permalink:"/awesome-notes/language/rust/rustBasicNotes"},next:{title:"Angular Basic Notes",permalink:"/awesome-notes/web/angular/angularBasicNotes"}},d={},p=[{value:"General Flow",id:"general-flow",level:2},{value:"Create Project",id:"create-project",level:3},{value:"RTL Analysis",id:"rtl-analysis",level:3},{value:"Simulate Design",id:"simulate-design",level:3},{value:"Synthesize Design",id:"synthesize-design",level:3},{value:"Implement Design",id:"implement-design",level:3},{value:"Post-Implementation Timing Simulate Design",id:"post-implementation-timing-simulate-design",level:3},{value:"Generate Bit Stream",id:"generate-bit-stream",level:3},{value:"Testing and Verification",id:"testing-and-verification",level:3},{value:"Timing in Circuits",id:"timing-in-circuits",level:2},{value:"Combination Circuit Timing",id:"combination-circuit-timing",level:3},{value:"Sequential Circuit Timing",id:"sequential-circuit-timing",level:3},{value:"Key Words",id:"key-words",level:2},{value:"Module",id:"module",level:2},{value:"\u5916\u90e8\u7aef\u53e3",id:"\u5916\u90e8\u7aef\u53e3",level:3},{value:"function",id:"function",level:2},{value:"task",id:"task",level:3},{value:"Data Structure",id:"data-structure",level:2},{value:"\u5e38\u91cf",id:"\u5e38\u91cf",level:3},{value:"\u5411\u91cf",id:"\u5411\u91cf",level:3},{value:"\u90e8\u5206\u4f4d\u9009",id:"\u90e8\u5206\u4f4d\u9009",level:4},{value:"\u6570\u5b57",id:"\u6570\u5b57",level:3},{value:"\u6709\u7b26\u53f7\u6570",id:"\u6709\u7b26\u53f7\u6570",level:4},{value:"\u65e0\u7b26\u53f7\u6570",id:"\u65e0\u7b26\u53f7\u6570",level:4},{value:"Register",id:"register",level:3},{value:"integer",id:"integer",level:4},{value:"real",id:"real",level:4},{value:"Net",id:"net",level:3},{value:"Gate Level",id:"gate-level",level:2},{value:"Basic Gate",id:"basic-gate",level:3},{value:"Use Gate",id:"use-gate",level:3},{value:"Self-Defined Gate(\u7528\u6237\u81ea\u5b9a\u4e49\u539f\u8bed)",id:"self-defined-gate\u7528\u6237\u81ea\u5b9a\u4e49\u539f\u8bed",level:3},{value:"Dataflow Level",id:"dataflow-level",level:2},{value:"Operators",id:"operators",level:3},{value:"\u6574\u6570\u63d0\u5347",id:"\u6574\u6570\u63d0\u5347",level:3},{value:"{ }",id:"-",level:4},{value:"Behavior Level",id:"behavior-level",level:2},{value:"\u65f6\u5ef6\u63a7\u5236",id:"\u65f6\u5ef6\u63a7\u5236",level:3},{value:"\u4e8b\u4ef6\u63a7\u5236",id:"\u4e8b\u4ef6\u63a7\u5236",level:3},{value:"\u8bed\u53e5\u5185/\u95f4\u63a7\u5236",id:"\u8bed\u53e5\u5185\u95f4\u63a7\u5236",level:3},{value:"always",id:"always",level:3},{value:"if-else",id:"if-else",level:3},{value:"Case Statement",id:"case-statement",level:3},{value:"for",id:"for",level:3},{value:"repeat loop",id:"repeat-loop",level:3},{value:"forever loop",id:"forever-loop",level:3},{value:"Force and Release",id:"force-and-release",level:3},{value:"Blocking and Non-Blocking",id:"blocking-and-non-blocking",level:3},{value:"disable",id:"disable",level:3},{value:"\u7ed3\u6784\u5efa\u6a21",id:"\u7ed3\u6784\u5efa\u6a21",level:2},{value:"generate \u8bed\u53e5",id:"generate-\u8bed\u53e5",level:3},{value:"Delay(\u65f6\u5ef6)",id:"delay\u65f6\u5ef6",level:2},{value:"\u9884\u7f16\u8bd1\u6307\u4ee4",id:"\u9884\u7f16\u8bd1\u6307\u4ee4",level:2},{value:"define \u5b8f",id:"define-\u5b8f",level:3},{value:"Data Path",id:"data-path",level:2},{value:"Multiplexer",id:"multiplexer",level:3},{value:"Adder",id:"adder",level:3},{value:"Register Data Path",id:"register-data-path",level:3},{value:"Memory",id:"memory",level:3},{value:"Demos",id:"demos",level:2},{value:"Binary Multiplier",id:"binary-multiplier",level:3},{value:"Multi-Hz",id:"multi-hz",level:3},{value:"Tips",id:"tips",level:2},{value:"\u4e0d\u53ef\u7efc\u5408\u7ed3\u6784",id:"\u4e0d\u53ef\u7efc\u5408\u7ed3\u6784",level:3},{value:"\u6df7\u5408\u7f16\u7a0b",id:"\u6df7\u5408\u7f16\u7a0b",level:3},{value:"\u4e0a\u5347\u6cbf/\u4e0b\u964d\u6cbf",id:"\u4e0a\u5347\u6cbf\u4e0b\u964d\u6cbf",level:3},{value:"Parameter",id:"parameter",level:3},{value:"Overload Method",id:"overload-method",level:4},{value:"Constant Variable",id:"constant-variable",level:4},{value:"Test Bench",id:"test-bench",level:4},{value:"\u6709\u9650\u72b6\u6001\u673a(FSM)",id:"\u6709\u9650\u72b6\u6001\u673afsm",level:2},{value:"\u7b97\u672f\u72b6\u6001\u673a(ASM)",id:"\u7b97\u672f\u72b6\u6001\u673aasm",level:2},{value:"System Verilog",id:"system-verilog",level:2},{value:"Enum",id:"enum",level:3},{value:"Struct and Union",id:"struct-and-union",level:3},{value:"Procedural Block",id:"procedural-block",level:3},{value:"Interface",id:"interface",level:3},{value:"Testing",id:"testing",level:3},{value:"U280 Platform",id:"u280-platform",level:2},{value:"Host Application",id:"host-application",level:3},{value:"Basic Flow",id:"basic-flow",level:4},{value:"TLP",id:"tlp",level:4},{value:"U280 Tools",id:"u280-tools",level:3},{value:"GDB Based Debugging",id:"gdb-based-debugging",level:4},{value:"XCL Binary Util",id:"xcl-binary-util",level:4},{value:"XOCC",id:"xocc",level:4},{value:"XBUtil",id:"xbutil",level:4},{value:"dmesg",id:"dmesg",level:4},{value:"ILA Trigger",id:"ila-trigger",level:4},{value:"AXI Protocol",id:"axi-protocol",level:2},{value:"AXI Channels",id:"axi-channels",level:3},{value:"Read Address Channel",id:"read-address-channel",level:4},{value:"Read Data Channel",id:"read-data-channel",level:4},{value:"Write Address Channel",id:"write-address-channel",level:4},{value:"Write Data Channel",id:"write-data-channel",level:4},{value:"Write Response Channel",id:"write-response-channel",level:4},{value:"AXI Burst",id:"axi-burst",level:3},{value:"Read Burst",id:"read-burst",level:4},{value:"Write Burst",id:"write-burst",level:4},{value:"Verilog Components",id:"verilog-components",level:2},{value:"Clock Unit",id:"clock-unit",level:3},{value:"Signal Unit",id:"signal-unit",level:3},{value:"ALU Unit",id:"alu-unit",level:3},{value:"Memory Unit",id:"memory-unit",level:3}],m={toc:p};function c(e){var n=e.components,o=(0,l.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},m,o,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"verilog-basic-notes"},"Verilog Basic Notes"),(0,i.kt)("h2",{id:"general-flow"},"General Flow"),(0,i.kt)("h3",{id:"create-project"},"Create Project"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".v")," (sources)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},".xdc")," (constraints)")),(0,i.kt)("h3",{id:"rtl-analysis"},"RTL Analysis"),(0,i.kt)("p",null,"Schematic"),(0,i.kt)("h3",{id:"simulate-design"},"Simulate Design"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_tb.v"),": test bench"),(0,i.kt)("li",{parentName:"ul"},"simulation options: 500ns"),(0,i.kt)("li",{parentName:"ul"},"Scopes -> dut -> swt/led"),(0,i.kt)("li",{parentName:"ul"},"Schematic")),(0,i.kt)("h3",{id:"synthesize-design"},"Synthesize Design"),(0,i.kt)("p",null,"Schematic"),(0,i.kt)("h3",{id:"implement-design"},"Implement Design"),(0,i.kt)("p",null,"Schematic"),(0,i.kt)("h3",{id:"post-implementation-timing-simulate-design"},"Post-Implementation Timing Simulate Design"),(0,i.kt)("h3",{id:"generate-bit-stream"},"Generate Bit Stream"),(0,i.kt)("h3",{id:"testing-and-verification"},"Testing and Verification"),(0,i.kt)("p",null,"low-level (circuit) simulation is much slower than high-level (C, HDL) simulation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"check only functionality at high level (C, HDL)"),(0,i.kt)("li",{parentName:"ul"},"check only timing, power at low level (circuit)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},'module testBench();\n  reg         clk, reset;           // clock and reset are internal\n  reg         a, b, c, yExpected;   // values from testVectors\n  wire        y;                    // output of circuit\n  reg  [31:0] vectorNum, errors;    // bookkeeping variables\n  reg  [3:0]  testVectors[10000:0]; // array of testVectors\n\n  // instantiate device under test\n  sillyFunction dut(.a(a), .b(b), .c(c), .y(y) );\n\n  // generate clock\n  always     // no sensitivity list, so it always executes\n    begin\n      clk = 1; #5; clk = 0; #5;     // 10ns period\n    end\n\n  // at start of test, load vectors and pulse reset\n  initial   // Only executes once\n  begin\n    $readmemb("example.tv", testVectors); // Read vectors: e.g 000_0 001_1 ... xxx_x\n    vectorNum = 0; errors = 0;            // Initialize\n    reset = 1; #27; reset = 0;            // Apply reset wait\n  end\n\n  // Note: $readmemh reads testVector files written in\n  // hexadecimal\n  // apply test vectors on rising edge of clk\n  always @(posedge clk)\n  begin\n    #1; {a, b, c, yExpected} = testVectors[vectorNum];\n  end\n\n  always @(negedge clk)\n  begin\n    if (~reset) // don\u2019t test during reset\n    begin\n      if (y !== yExpected)\n      begin\n        $display("Error: inputs = %b", {a, b, c});\n        $display("  outputs = %b (%b exp)",y,yExpected);\n        errors = errors + 1;\n      end\n\n      // increment array index and read next testVector\n      vectorNum = vectorNum + 1;\n\n      if (testVectors[vectorNum] === 4\'bx)\n      begin\n        $display("%d tests completed with %d errors", vectorNum, errors);\n        $finish;                 // End simulation\n      end\n    end\n  end\nendmodule\n')),(0,i.kt)("h2",{id:"timing-in-circuits"},"Timing in Circuits"),(0,i.kt)("h3",{id:"combination-circuit-timing"},"Combination Circuit Timing"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"contamination delay (",(0,i.kt)("inlineCode",{parentName:"li"},"t_cd"),"): minimum path in circuits, outputs start to change"),(0,i.kt)("li",{parentName:"ul"},"propagation delay (",(0,i.kt)("inlineCode",{parentName:"li"},"t_pd"),"): maximum path in circuits, outputs complete change"),(0,i.kt)("li",{parentName:"ul"},"(delay) heavy dependence on ",(0,i.kt)("strong",{parentName:"li"},"voltage")," and ",(0,i.kt)("strong",{parentName:"li"},"temperature"))),(0,i.kt)("h3",{id:"sequential-circuit-timing"},"Sequential Circuit Timing"),(0,i.kt)("p",null,"minimize clock skew time:\nrequires intelligent ",(0,i.kt)("strong",{parentName:"p"},"clock network")," across a chip,\nmaking clock arrives at all locations at roughly the same time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"T_clock >= T_pcq + T_pd + (T_setup + T_skew)\nT_ccq + T_cd > (T_hold + T_skew)\n")),(0,i.kt)("h2",{id:"key-words"},"Key Words"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module\ninput, output, inout\nwire, reg, parameter\nalways@(), assign\nposedge, negedge\nif-else, case, begin ... end\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"port, signal\n")),(0,i.kt)("h2",{id:"module"},"Module"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Inout(Net) -> (Net)Module(Net) -> Inout(Net)"),(0,i.kt)("li",{parentName:"ul"},"Input(Net/Register) -> (Net)Module(Net/Register) -> Output(Net)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module moduleName( In1, In2, Out1, Out2, InOut1);\n    // \u8f93\u5165\u8f93\u51fa\u5b9a\u4e49: \u8bf4\u660e\u7aef\u53e3\u662f\u8f93\u5165\u8fd8\u662f\u8f93\u51fa\n    input In1, In2;\n    output Out1, Out2;\n    inout InOut1;\n\n    // \u6570\u636e\u7c7b\u578b\u5b9a\u4e49: \u8bf4\u660e\u7aef\u53e3\u6570\u636e\u7c7b\u578b - Net/Register\n    wire In1, In2, Out1;\n    wire InOut1;\n    reg Out2;\n    // Instantiation of lower level modules\n    Design u_2(.(\u7aef\u53e3(\u4fe1\u53f71), .(\u7aef\u53e32(\u4fe1\u53f72), .(\u7aef\u53e33(\u4fe1\u53f73));\n\n    // Functionality\n\n    // \u4e09\u79cd\u5c42\u6b21\u7684\u63cf\u8ff0: \u903b\u8f91\u5c42\u6b21(Gate Level), \u6570\u636e\u6d41\u5c42\u6b21(Dataflow Level), \u884c\u4e3a\u5c42\u6b21(Behavior Level)\n    // and/or - gate level\n    and and1( Out1, In1, In2);\n    // assign - dataflow level\n    assign #2 Out1 = In1 & In2;\n    // always/initial - behavior level\n    always @(*)\n        begin\n            Out2 = In1 & In2\n        end\n\n    // Timing specification\n\nendmodule\n")),(0,i.kt)("h3",{id:"\u5916\u90e8\u7aef\u53e3"},"\u5916\u90e8\u7aef\u53e3"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5c01\u88c5\u5185\u90e8\u7aef\u53e3,\u88c5\u9970\u8005\u6a21\u5f0f"),(0,i.kt)("li",{parentName:"ul"},"\u4e00\u4e2a\u5185\u90e8\u7aef\u53e3\u53ef\u4e0e\u591a\u4e2a\u5916\u90e8\u7aef\u53e3\u76f8\u8fde")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module scram_b (\n    .data(arb),\n    .control(ctrl),\n    .mem_word(mem_blk),\n    .addr(byte)\n);\n\n    input [0:3] arb;\n    input ctrl;\n    input [8:0] mem_blk;\n    output [0:3] byte;\n\nendmodule\n")),(0,i.kt)("h2",{id:"function"},"function"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u4e0d\u542b\u65f6\u95f4/\u4e8b\u4ef6\u63a7\u5236"),(0,i.kt)("li",{parentName:"ul"},"\u81f3\u5c11 1 \u4e2a\u8f93\u5165"),(0,i.kt)("li",{parentName:"ul"},"\u81f3\u591a 1 \u4e2a\u8f93\u51fa"),(0,i.kt)("li",{parentName:"ul"},"\u53ea\u542b\u884c\u4e3a\u6a21\u5757"),(0,i.kt)("li",{parentName:"ul"},"\u53ea\u542b\u963b\u585e\u8d4b\u503c\u8bed\u53e5")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"function  [7: 0]  aligned_word;    // function declaration\n    input  [7: 0]  word;\n    begin\n      aligned_word = word;\n      if (aligned_word != 0)\n        while (aligned_word[7] == 0) aligned_word = aligned_word << 1;\n    end\n  endfunction\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module arithmetic_unit (result_1, result_2, operand_1, operand_2,);\n  output   [4: 0] result_1;\n  output  [3: 0] result_2;\n  input   [3: 0] operand_1, operand_2;\n  assign result_1 = sum_of_operands (operand_1, operand_2);\n  assign result_2 = larger_operand (operand_1, operand_2);\n\n  function [4: 0] sum_of_operands(input [3:0] operand_1, operand_2);\n    sum_of_operands = operand_1 + operand_2;\n  endfunction\n\n  function [3: 0] larger_operand(input [3:0] operand_1, operand_2);\n    larger_operand = (operand_1 >= operand_2) ? operand_1 : operand_2;\n  endfunction\nendmodule\n")),(0,i.kt)("h3",{id:"task"},"task"),(0,i.kt)("p",null,"\u5c06\u6d4b\u8bd5\u6d41\u7a0b\u5206\u4e3a\u591a\u4e2a\u4efb\u52a1:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u521d\u59cb\u5316\u4efb\u52a1"),(0,i.kt)("li",{parentName:"ul"},"\u6a21\u62df\u751f\u6210\u4efb\u52a1"),(0,i.kt)("li",{parentName:"ul"},"\u81ea\u6211\u68c0\u67e5\u4efb\u52a1")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module adder_task (c_out, sum, clk, reset, c_in, data_a, data_b);\n  output reg [3: 0]  sum;\n  output reg  c_out;\n  input  [3: 0]  data_a, data_b;\n  input   clk, reset, c_in;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) {c_out, sum} <= 0;\n    else add_values (sum, c_out, data_a, data_b, c_in); // invoke task\n  end\n  task add_values; // task declaration\n    output reg [3: 0]  SUM;\n    output reg  C_OUT;\n    input  [3: 0]  DATA_A, DATA_B;\n    input   C_IN;\n            {C_OUT, SUM} = DATA_A + (DATA_B + C_IN);\n   endtask\nendmodule\n")),(0,i.kt)("p",null,'\u5e38\u7528\u7684 task \u6709: $display("fmt", ...), $monitor("fmt", ...), $time, $finish'),(0,i.kt)("h2",{id:"data-structure"},"Data Structure"),(0,i.kt)("h3",{id:"\u5e38\u91cf"},"\u5e38\u91cf"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"0: \u903b\u8f91 0"),(0,i.kt)("li",{parentName:"ul"},"1: \u903b\u8f91 1"),(0,i.kt)("li",{parentName:"ul"},"x/X: Unknown/Floating"),(0,i.kt)("li",{parentName:"ul"},"z/Z: \u9ad8\u963b\u6297\u72b6\u6001(High Impedance)"),(0,i.kt)("li",{parentName:"ul"},"parameter: #define")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"localparam idle = 2'b00;\nparameter Bit = 8, cnt_up = 1'b1;\n\noutput [Bit - 1:0] A;\nreg [Bit - 1:0] A;\n\nA = A + cnt_up;\n")),(0,i.kt)("h3",{id:"\u5411\u91cf"},"\u5411\u91cf"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"[MSB: LSB] \u6216 [LSB: MSB]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"output [3:0] A;    // 4 bit\nreg [0:3] B, C;    // 4 bit\nwire [63:0] D;    // 64 bit\nwire E;               // 1 bit\n\nA[2:1] = B[0] & C[1:2];    // A[2] = 0 & C[1], A[1] = B[0] & C[2]\nB[0:1] = 0;\nC = 4'b1011;                   // C[0] = 1, C[1] = 0, C[2] = 1, C[3] = 1\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"integer [7:0] A [3:0];        // 4\u5143\u7d20\u6570\u7ec4. \u6bcf\u4e2a\u5143\u7d20\u4e3a16bit\u5143\nreg B [3:0] [15:0];            // arr[4][16]\u6570\u7ec4, \u6bcf\u4e2a\u5143\u7d20\u4e3a1bit\u5143\nreg [7:0] C [3:0] [15:0];    // arr[4][16]\u6570\u7ec4, \u6bcf\u4e2a\u5143\u7d20\u4e3a8bit\u5143\n\nA[3] = 0;                     // \u7f6e\u96f6A\u4e2d\u7b2c\u4e09\u4e2a\u5143\u7d20(8 bit)\nA = 0;                        // \u7f6e\u96f6A\nB[1][0] = 1;                  // B[1][0](1 bit)\u7f6e1\nC[0][0][3:0] = 4'b0010;      // C[0][0] \u4f4e4bit\u4e3a0010\nC[2][8][5] = 1;               // C[2][8] \u7b2c5bit\u4e3a1\n")),(0,i.kt)("h4",{id:"\u90e8\u5206\u4f4d\u9009"},"\u90e8\u5206\u4f4d\u9009"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"vector[base_expr+: const_width];\nvector[base_expr-: const_width];\n\ninst_mode[mark+:2]; // => mark,mark+1\ngpio_mode[mark-:4]; // => mark,mark-1,mark-2,mark-3\n")),(0,i.kt)("h3",{id:"\u6570\u5b57"},"\u6570\u5b57"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// size ' signed base value\n<Bits\u957f\u5ea6>'[signed]<\u8fdb\u5236><\u6570\u503c>\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u4f4d\u957f\u4e0d\u80fd\u7528\u8868\u8fbe\u5f0f\u8868\u793a,\u53ea\u53ef\u7528\u56fa\u5b9a\u7684 parameter")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"Num = 5'b01101;               // \u4e8c\u8fdb\u5236\nNum = 22;                     // \u5341\u8fdb\u5236\nNum = 12'b0000_1111_0000;    // \u53ef\u8bfb\u6027\nNum = 4'hf;                  // \u5341\u516d\u8fdb\u5236(1111)\nNum = 4'bxxx1;              // \u524d\u4e09\u4f4d\u672a\u77e5\nNum = 4'bz01;               // \u524d\u4e24\u4f4d\u4e3az, \u540e\u4e24\u4f4d\u4e3a01\n")),(0,i.kt)("h4",{id:"\u6709\u7b26\u53f7\u6570"},"\u6709\u7b26\u53f7\u6570"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"signed reg"),(0,i.kt)("li",{parentName:"ul"},"signed wire"),(0,i.kt)("li",{parentName:"ul"},"integer"),(0,i.kt)("li",{parentName:"ul"},"'sxx")),(0,i.kt)("h4",{id:"\u65e0\u7b26\u53f7\u6570"},"\u65e0\u7b26\u53f7\u6570"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"reg"),(0,i.kt)("li",{parentName:"ul"},"wire"),(0,i.kt)("li",{parentName:"ul"},"'xx")),(0,i.kt)("h3",{id:"register"},"Register"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"reg/integer/time/real/realtime"),(0,i.kt)("li",{parentName:"ul"},"\u6709\u8bb0\u5fc6\u6027"),(0,i.kt)("li",{parentName:"ul"},"\u9ed8\u8ba4\u503c: x")),(0,i.kt)("h4",{id:"integer"},"integer"),(0,i.kt)("p",null,"\u957f\u5ea6\u4e3a 32 Bit, \u8865\u7801\u8868\u793a, \u5e38\u7528\u4e8e\u8ba1\u6570\u5668"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always @(posedge CLK)\n    begin\n        integer i;\n        for (i = 0;i <= 7; i = i + 1) tmp[i] = In;\n    end\n")),(0,i.kt)("h4",{id:"real"},"real"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"real \u9ed8\u8ba4\u503c\u4e3a 0,\u4e0d\u53ef\u4e3a x/z"),(0,i.kt)("li",{parentName:"ul"},"\u4e0d\u53ef\u58f0\u660e\u4f4d\u5bbd")),(0,i.kt)("h3",{id:"net"},"Net"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"wire/wand/wor"),(0,i.kt)("li",{parentName:"ul"},"\u5c40\u90e8\u53d8\u91cf, \u6ca1\u6709\u8bb0\u5fc6\u6027"),(0,i.kt)("li",{parentName:"ul"},"\u9ed8\u8ba4\u503c: z"),(0,i.kt)("li",{parentName:"ul"},"wire \u95f4\u4e0d\u53ef\u76f4\u63a5\u76f8\u8fde, wand/wor \u95f4\u8bfe\u76f4\u63a5\u76f8\u8fde"),(0,i.kt)("li",{parentName:"ul"},"\u53ef\u7528 wire \u5b9a\u4e49\u5c40\u90e8\u53d8\u91cf")),(0,i.kt)("h2",{id:"gate-level"},"Gate Level"),(0,i.kt)("h3",{id:"basic-gate"},"Basic Gate"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"and"),(0,i.kt)("li",{parentName:"ul"},"nand(\u4e0e\u975e)"),(0,i.kt)("li",{parentName:"ul"},"or"),(0,i.kt)("li",{parentName:"ul"},"nor(\u6216\u975e)"),(0,i.kt)("li",{parentName:"ul"},"xor(\u5f02\u6216)"),(0,i.kt)("li",{parentName:"ul"},"xnor(\u540c\u6216)")),(0,i.kt)("h3",{id:"use-gate"},"Use Gate"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u540c\u4e00\u6a21\u5757\u4e2d, \u5b9e\u4f8b\u540d\u4e0d\u80fd\u4e0e\u7ebf\u7f51\u540d\u76f8\u540c")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"and (w1, In1, In2);        // w1 = Int and In2\nor or1(w2, w1, In2);      // w2 = w1 or In2\nxor xor(Out, w1, w2);    // Out = w1 xor w2\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5b9e\u4f8b\u6570\u7ec4")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"wire [3:0] irq, ctrl, sense;\n\n/*\n * =>\n * nand\n *      u8nand3 (irq[3], ctrl[3], sense[3]);\n *      u8nand2 (irq[2], ctrl[2], sense[2]);\n *      u8nand1 (irq[1], ctrl[1], sense[1]);\n *      u8nand0 (irq[0], ctrl[0], sense[0]);\n */\nnand u8nand [3:0] (irq, ctrl, sense);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"parameter NUM_BITS = 4;\nwire [NUM_BITS - 1 : 0] gated_d, din;\nwire bypass;\n\nand #(1, 2) u0and [NUM_BITS - 1: 0] (gated_d, din, bypass);\n")),(0,i.kt)("h3",{id:"self-defined-gate\u7528\u6237\u81ea\u5b9a\u4e49\u539f\u8bed"},"Self-Defined Gate(\u7528\u6237\u81ea\u5b9a\u4e49\u539f\u8bed)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u53ef\u4ee5\u6709\u4e00\u4e2a/\u591a\u4e2a\u8f93\u5165"),(0,i.kt)("li",{parentName:"ul"},"\u53ea\u80fd\u6709\u4e00\u4e2a\u8f93\u51fa"),(0,i.kt)("li",{parentName:"ul"},"\u7b2c\u4e00\u4e2a\u7aef\u53e3\u5fc5\u987b\u662f\u8f93\u51fa\u7aef\u53e3"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-"),' \u8868\u793a \u503c"\u65e0\u53d8\u5316"')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"primitive XOR2 (D_OUT, X1, X2);\n    input X1, X2;\n    output D_OUT;\n\n    table // X1 X2 : D_OUT\n        0 0 : 0;\n        0 1 : 1;\n        1 0 : 1;\n        1 1 : 0;\n    endtable\nendprimitive\n")),(0,i.kt)("h2",{id:"dataflow-level"},"Dataflow Level"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"assign net = net/reg: ",(0,i.kt)("strong",{parentName:"li"},"\u5de6\u5f0f\u53ea\u80fd\u662f net"))),(0,i.kt)("h3",{id:"operators"},"Operators"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://hom-wang.gitbooks.io/verilog-hdl/content/Chapter_04.html"},"Operators List"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"\u8d4b\u503c: <=, =\n>, <, <=, >=\n!=. ==\n[ ]. { }\n<<, >>\n+, -, *, /, %\n")),(0,i.kt)("h3",{id:"\u6574\u6570\u63d0\u5347"},"\u6574\u6570\u63d0\u5347"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u8868\u8fbe\u5f0f\u6240\u6709\u4e2d\u95f4\u53d6 \u6700\u5927\u4f4d\u5bbd(\u6700\u957f(\u5de6/\u53f3)\u64cd\u4f5c\u6570)")),(0,i.kt)("h4",{id:"-"},"{ }"),(0,i.kt)("p",null,"\u53ef\u5b9e\u73b0 haskell \u4e2d\u7684",(0,i.kt)("strong",{parentName:"p"},"\u6a21\u5f0f\u5339\u914d")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// \u8fde\u63a5\u8fd0\u7b97\u7b26\nA = { 1'b0, 1'b1};                // A = 2'b01\nA = { B[1:0], C[0], D[2] };    // A = B[1], B[2], C[0], D[2]\nA = { 2{2'b01} };                  // A = 4'b0101\nA = { 3'b101, 2{1'b0} };        // A = 5'b101_00\n")),(0,i.kt)("h2",{id:"behavior-level"},"Behavior Level"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reg = net/reg"),": \u5de6\u5f0f\u53ea\u80fd\u662f ",(0,i.kt)("inlineCode",{parentName:"li"},"reg"),".")),(0,i.kt)("h3",{id:"\u65f6\u5ef6\u63a7\u5236"},"\u65f6\u5ef6\u63a7\u5236"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"#num\n\nparameter cycle = 30;\n\n# 2\n# cycle/2\n")),(0,i.kt)("h3",{id:"\u4e8b\u4ef6\u63a7\u5236"},"\u4e8b\u4ef6\u63a7\u5236"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"@(*);\n@( sel, a, b);\n@(sel or a or b);\n@(posedge CLK);\n@(negedge CLK);\n")),(0,i.kt)("h3",{id:"\u8bed\u53e5\u5185\u95f4\u63a7\u5236"},"\u8bed\u53e5\u5185/\u95f4\u63a7\u5236"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"q = @(posedge clk_iol) d; // \u8bed\u53e5\u5185\u4e8b\u4ef6\u63a7\u5236\n\n@(posedge clk_iol)        // \u8bed\u53e5\u95f4\u4e8b\u4ef6\u63a7\u5236\n    q = temp;\n")),(0,i.kt)("h3",{id:"always"},"always"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always @(\u4e8b\u4ef61, \u4e8b\u4ef62, ...)\n    begin\n        ...;\n    end\n")),(0,i.kt)("h3",{id:"if-else"},"if-else"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5fc5\u987b\u6dfb\u52a0 else")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"if (condition1)\n    begin\n        ...;\n    end\nelse if (condition2)\n    begin\n        ...;\n    end\nelse\n    begin\n        ...;\n    end\n")),(0,i.kt)("h3",{id:"case-statement"},"Case Statement"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"expr: \u5e38\u91cf/\u53d8\u91cf/\u8fde\u63a5\u8fd0\u7b97\u7b26{ }/x/z"),(0,i.kt)("li",{parentName:"ul"},"casex: \u5f53\u8f93\u5165\u67d0\u4e00\u4f4d\u4e3a x/z \u65f6\uff0c\u5ffd\u7565\u6b64\u4f4d\u5339\u914d(\u6052\u5c06\u6b64\u4f4d\u5339\u914d\u4e3a\u771f)"),(0,i.kt)("li",{parentName:"ul"},"casez: \u5f53\u8f93\u5165\u67d0\u4e00\u4f4d\u4e3a z \u65f6\uff0c\u5ffd\u7565\u6b64\u4f4d\u5339\u914d(\u6052\u5c06\u6b64\u4f4d\u5339\u914d\u4e3a\u771f)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"case (expr)\n    item 1:\n        begin\n            ...;\n        end\n    item 2:\n        begin\n            ...;\n        end\n    item 3:\n        begin\n            ...;\n        end\n    default:\n        ...;\nendcase\n")),(0,i.kt)("h3",{id:"for"},"for"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"for (\u5faa\u73af\u521d\u503c; \u5faa\u73af\u6761\u4ef6; \u63a7\u5236\u90e8\u5206)\n    begin\n        ...;\n    end\n")),(0,i.kt)("h3",{id:"repeat-loop"},"repeat loop"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"initial for ",(0,i.kt)("strong",{parentName:"li"},"test bench")),(0,i.kt)("li",{parentName:"ul"},"\u5f53\u9700 if/else \u8fdb\u884c\u65ad\u8a00\u65f6,\u6ce8\u610f ",(0,i.kt)("strong",{parentName:"li"},"\u5ef6\u65f6")," \u9020\u6210\u7684\u9519\u8bef\u903b\u8f91")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// \u91cd\u590d\u4e8b\u4ef6\u63a7\u5236:\n// \u5148\u8ba1\u7b97\u597d\u53f3\u503c, \u7b49\u5f85\u65f6\u949f clk \u4e0a\u51fa\u73b02\u4e2a\u8d1f\u8df3\u53d8\u6cbf, \u518d\u628a\u53f3\u503c\u8d4b\u7ed9 result\nresult = repeat (2) @(negedge clk) hw_data + hr_data;\n\n// repeat \u5faa\u73af\u8bed\u53e5:\nrepeat (2)\n    @(posedge clk) result = hw_data + hr_data;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"initial begin\n    inc_DAC = 1\u2019b1;\n\n    repeat(4095) @(posedge clk); // bring DAC right up to point of rollover\n    inc_DAC = 1\u2019b0;\n    inc_sym = 1\u2019b1;\n\n    repeat(7)@(posedge clk); // bring sample count up to 7\n    inc_sym = 1\u2019b0;\nend\n\ninitial begin\n    #100 $finish; // run simulation for 100 units\nend\n")),(0,i.kt)("h3",{id:"forever-loop"},"forever loop"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"// $stop, $finish \u53ef\u4ee5\u7ec8\u6b62 forever loop\nforever #10 clk = ~ clk;\n")),(0,i.kt)("h3",{id:"force-and-release"},"Force and Release"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"initial\n    begin\n        force test_reset = penalty & rtc_intr;\n        #5;\n        release test_reset;\n    end\n")),(0,i.kt)("h3",{id:"blocking-and-non-blocking"},"Blocking and Non-Blocking"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Blocking(=): \u987a\u5e8f\u6267\u884c"),(0,i.kt)("li",{parentName:"ul"},"Non-Blocking(<=): \u5e76\u884c\u6267\u884c")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"output = input_logic;\n\noutput <= input_logic;\n")),(0,i.kt)("h3",{id:"disable"},"disable"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},'begin : break\n    for (i = 0; i < n; i = i+1) begin : continue\n        @(posedge clk)\n        if (a == 0) // "continue" loop\n            disable continue;\n        if (a == b) // "break" from loop\n            disable break;\n        statement1\n        statement2\n    end\nend\n')),(0,i.kt)("h2",{id:"\u7ed3\u6784\u5efa\u6a21"},"\u7ed3\u6784\u5efa\u6a21"),(0,i.kt)("h3",{id:"generate-\u8bed\u53e5"},"generate \u8bed\u53e5"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"generate\n    for (gv_i = 0; gv_i < SIZE; gv_i = gv_i + 1)\n        begin: blk\n            xor uxor (y[gv_i], a[gv_i], b[gv_i]);\n        end\nendgenerate\n// =>\n// module.blk[0].uxor\n// module.blk[1].uxor\n// module.blk[2].uxor\n// ...\n")),(0,i.kt)("h2",{id:"delay\u65f6\u5ef6"},"Delay(\u65f6\u5ef6)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u8bed\u53e5\u5185\u65f6\u5ef6"),(0,i.kt)("li",{parentName:"ul"},"\u8bed\u53e5\u95f4\u65f6\u5ef6"),(0,i.kt)("li",{parentName:"ul"},"\u8bed\u53e5\u5185\u65f6\u5ef6\u671f\u95f4\uff1a\u53f3\u503c\u4fdd\u6301\u7a33\u5b9a\u4e0d\u53d8\uff0c\u624d\u53ef\u6210\u529f\u8d4b\u7ed9\u5de6\u503c")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"sum = (a ^ b) ^ cin;\n#4 t1 = a & cin;\n")),(0,i.kt)("h2",{id:"\u9884\u7f16\u8bd1\u6307\u4ee4"},"\u9884\u7f16\u8bd1\u6307\u4ee4"),(0,i.kt)("h3",{id:"define-\u5b8f"},"define \u5b8f"),(0,i.kt)("p",null,"\u5c06\u591a\u4e2a define \u5b8f,\u653e\u81f3 ",(0,i.kt)("inlineCode",{parentName:"p"},"_defines.v"),", \u4f5c\u4e3a\u5168\u5c40\u5b8f."),(0,i.kt)("h2",{id:"data-path"},"Data Path"),(0,i.kt)("h3",{id:"multiplexer"},"Multiplexer"),(0,i.kt)("h3",{id:"adder"},"Adder"),(0,i.kt)("h3",{id:"register-data-path"},"Register Data Path"),(0,i.kt)("h3",{id:"memory"},"Memory"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5176\u4e2d\u6570\u636e\u6587\u4ef6\u4e2d\u5730\u5740\u5fc5\u987b\u5728\u7cfb\u7edf\u4efb\u52a1\u4e2d\u5b9a\u4e49\u7684\u8303\u56f4\u5185\uff0c\u7cfb\u7edf\u4efb\u52a1\u4e2d\u5b9a\u4e49\u7684\u5730\u5740\u5fc5\u987b\u5728\u5b58\u50a8\u5668\u5b9a\u4e49\u7684\u5730\u5740\u8303\u56f4\u5185"),(0,i.kt)("li",{parentName:"ul"},"\u4f18\u5148\u8003\u8651\u6570\u636e\u6587\u4ef6\u4e2d\u7684\u5730\u5740>\u7cfb\u7edf\u4efb\u52a1\u4e2d\u5b9a\u4e49\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740>\u5b58\u50a8\u5668\u5b9a\u4e49\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740")),(0,i.kt)("h2",{id:"demos"},"Demos"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://hom-wang.gitbooks.io/verilog-hdl/content/Chapter_07.html"},"GitBook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://www.xilinx.com/support/university/ise/ise-teaching-material/hdl-design.html"},"Xilinx Lab"))),(0,i.kt)("h3",{id:"binary-multiplier"},"Binary Multiplier"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"   1100 (the multiplicand)\nx  1011 (the multiplier)\n   ----\n   0000 (initial partial product, start with 0000)\n   1100 (1st multiplier bit is 1, so add the multiplicand)\n   ----\n   1100 (sum)\n   ----\n   01100 (shift sum one position to the right)\n   1100 (2nd multiplier bit is 1, so add multiplicand again)\n   ----\n  100100 (sum, with a carry generated on the left)\n   ----\n   100100 (shift sum once to the right, including carry)\n   0100100 (3rd multiplier bit is 0, so skip add, shift once)\n   ----\n   1100 (4th multiplier bit is 1, so add multiplicand again)\n   ----\n  10000100 (sum, with a carry generated on the left)\n   10000100 (shift sum once to the right, including carry)\n")),(0,i.kt)("h3",{id:"multi-hz"},"Multi-Hz"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/*\n * \u5229\u7528\u8ba1\u6570\u5668\u5b9e\u73b0\u4efb\u610f\u5206\u9891\n */\nalways\xa0@(posedge\xa0f_clk) begin\n\n    //\u8bbe\u5b9a\u9891\u7387\u63a7\u5236\u5b57p\xa0\xa0\n\xa0\xa0  if (i == p)\xa0begin\n        i=0;\n\xa0\xa0      f_out=~f_out;\n    end\n    else begin\n\xa0\xa0      i=i+1;\n    end\nend\n")),(0,i.kt)("h2",{id:"tips"},"Tips"),(0,i.kt)("h3",{id:"\u4e0d\u53ef\u7efc\u5408\u7ed3\u6784"},"\u4e0d\u53ef\u7efc\u5408\u7ed3\u6784"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"initial: \u53ea\u7528\u4e8e test bench"),(0,i.kt)("li",{parentName:"ul"},"events: Events \u540c\u6b65\u6d4b\u8bd5\u5404\u4e2a\u7ec4\u4ef6"),(0,i.kt)("li",{parentName:"ul"},"real: Real \u6570\u636e\u7c7b\u578b\u4e0d\u53ef\u7efc\u5408"),(0,i.kt)("li",{parentName:"ul"},"time: Time \u6570\u636e\u7c7b\u578b\u4e0d\u53ef\u7efc\u5408"),(0,i.kt)("li",{parentName:"ul"},"force/release"),(0,i.kt)("li",{parentName:"ul"},"assign(reg)/deassign(reg)"),(0,i.kt)("li",{parentName:"ul"},"fork join"),(0,i.kt)("li",{parentName:"ul"},"primitive: \u53ea\u6709\u95e8\u7ea7\u7684\u539f\u8bed\uff08primitives\uff09\u53ef\u7efc\u5408"),(0,i.kt)("li",{parentName:"ul"},"table: \u7528\u6237\u81ea\u5b9a\u4e49\u539f\u8bed\uff08UDP\uff09\u53ca table \u4e0d\u53ef\u7efc\u5408"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"#1")," \u5ef6\u8fdf\u53ea\u7528\u4e8e\u4eff\u771f\uff0c\u7efc\u5408\u5668\u76f4\u63a5\u5ffd\u7565\u5ef6\u8fdf")),(0,i.kt)("h3",{id:"\u6df7\u5408\u7f16\u7a0b"},"\u6df7\u5408\u7f16\u7a0b"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5185\u90e8\u53d8\u91cf\u7528 assign \u8d4b\u503c"),(0,i.kt)("li",{parentName:"ul"},"\u8f93\u51fa\u53d8\u91cf\u901a\u8fc7\u76d1\u542c \u5185\u90e8\u53d8\u91cf \u6539\u53d8\u8f93\u51fa\u503c")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"    assign DT0 = ...;\n    assign DT1 = ...;\n\n    always @(DT0) begin\n        AOut <= DT0;\n    end\n    always @(DT1) begin\n        BOut <= DT1;\n    end\n")),(0,i.kt)("h3",{id:"\u4e0a\u5347\u6cbf\u4e0b\u964d\u6cbf"},"\u4e0a\u5347\u6cbf/\u4e0b\u964d\u6cbf"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"    always @(posedge A or negedge B) begin\n        if (A) ...\n        else if (!B) ...\n        else ...\n    end\n")),(0,i.kt)("h3",{id:"parameter"},"Parameter"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u53ea\u5728\u5b9a\u4e49\u7684\u6a21\u5757\u5185\u90e8\u8d77\u4f5c\u7528")),(0,i.kt)("h4",{id:"overload-method"},"Overload Method"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module data_path\n#(parameter DATA_WIDTH = 8)\n(\n    input A,\n    input [(DATA_WIDTH - 1): 0] B,\n    output [(DATA_WIDTH - 1): 0] C\n);\n\n    ......\n\nendmodule\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module data_path_tb\n(\n);\n    data_path #(.DATA_WIDTH(16)) DUT (.A(A), .B(B), .C(C));\n\n    ......\n\nendmodule\n")),(0,i.kt)("h4",{id:"constant-variable"},"Constant Variable"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"reset_value = {{(DATA_WIDTH/2){1'b0}}, {(DATA_WIDTH/2){1'b1}}};\n")),(0,i.kt)("h4",{id:"test-bench"},"Test Bench"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always begin\n    clk = 0;\n    forever #DELAY clk = ~clk;\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},'reg clock;\ninteger no_of_clocks;\n\nparameter CLOCK_PERIOD = 5;\nparameter TIME = 50000;\n\ninitial no_of_clocks = 0;\ninitial clock = 1\'b0;\n\nalways #(CLOCK_PERIOD/2.0) clock = ~clock;\n\nalways @(posedge clock)\n    no_of_clocks = no_of_clocks +1 ;\n\ninitial begin\n    #TIME;\n    $display("End of simulation time is %d ,\n      total number of clocks seen is %d expected is %d",$time,no_of_clocks,($time/5));\n    $finish;\nend\n')),(0,i.kt)("h2",{id:"\u6709\u9650\u72b6\u6001\u673afsm"},"\u6709\u9650\u72b6\u6001\u673a(FSM)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"reset: initial state"),(0,i.kt)("li",{parentName:"ul"},"default: illegal/unreachable state")),(0,i.kt)("h2",{id:"\u7b97\u672f\u72b6\u6001\u673aasm"},"\u7b97\u672f\u72b6\u6001\u673a(ASM)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"state box: moore fsm"),(0,i.kt)("li",{parentName:"ul"},"conditional box: mealy fsm"),(0,i.kt)("li",{parentName:"ul"},"decision box: ",(0,i.kt)("inlineCode",{parentName:"li"},"x_input")," = 0/1")),(0,i.kt)("h2",{id:"system-verilog"},"System Verilog"),(0,i.kt)("h3",{id:"enum"},"Enum"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},'typedef enum logic [2:0] {\n  RED, GREEN, BLUE, CYAN, MAGENTA, YELLOW\n} color_t;\n\ncolor_t my_color = GREEN;\ninitial $display("The color is %s", my_color.name());\n')),(0,i.kt)("h3",{id:"struct-and-union"},"Struct and Union"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"typedef struct packed {\n  bit [10:0]  expo;\n  bit         sign;\n  bit [51:0]  man;\n} FP;\n\nFP zero = 64'b0;\n")),(0,i.kt)("h3",{id:"procedural-block"},"Procedural Block"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"always_comb: \u7528\u4e8e\u7ec4\u5408\u903b\u8f91\u7535\u8def\uff08\u76f8\u5f53\u4e8e Verilog \u4e2d\u5bf9\u6240\u6709\u8f93\u5165\u53d8\u91cf\u7535\u5e73\u654f\u611f\u7684 always\uff0c\u4f46 always_comb \u65e0\u9700\u624b\u52a8\u5217\u51fa\u6240\u6709\u8f93\u5165\u53d8\u91cf\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u8bc6\u522b\uff09"),(0,i.kt)("li",{parentName:"ul"},"always_ff: \u7528\u4e8e\u89e6\u53d1\u5668\u53ca\u76f8\u5173\u7684\u65f6\u5e8f\u903b\u8f91\u7535\u8def\uff08\u76f8\u5f53\u4e8e Verilog \u4e2d\u5bf9\u67d0\u4e2a\u6216\u67d0\u51e0\u4e2a\u4fe1\u53f7\u6709\u6548\u8df3\u53d8\u6cbf\u654f\u611f\u3001\u5e76\u5e26\u6709\u4fe1\u53f7\u50a8\u5b58\u7279\u6027\u7684 always\uff09"),(0,i.kt)("li",{parentName:"ul"},"always_latch: \u7528\u4e8e\u9501\u5b58\u5668\u7ea7\u76f8\u5173\u7684\u65f6\u5e8f\u903b\u8f91\u7535\u8def\uff08\u76f8\u5f53\u4e8e Verilog \u4e2d\u5bf9\u67d0\u4e2a\u6216\u67d0\u51e0\u4e2a\u4fe1\u53f7\u7535\u5e73\u654f\u611f\u3001\u5e76\u5e26\u6709\u4fe1\u53f7\u50a8\u5b58\u7279\u6027\u7684\u7684 always\uff09")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"always_comb begin\n  tmp = b * b - 4 * a * c;\n  no_root = (tmp < 0);\nend\n\nalways_ff @(posedge clk)\n  count <= count + 1;\n\n\nalways_latch\n  if (en) q <= d;\n")),(0,i.kt)("h3",{id:"interface"},"Interface"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"interface interfaceName;\n  logic a;\n  logic b;\n  modport in (input a, output b);\n  modport out (input b, output a);\nendinterface\n\nmodule top;\n  interfaceName i ();\n  u_a m1 (.i1(i));\n  u_b m2 (.i2(i));\nendmodule\n\nmodule u_a (interfaceName.in i1);\nendmodule\n\nmodule u_b (interfaceName.out i2);\nendmodule\n")),(0,i.kt)("h3",{id:"testing"},"Testing"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"module top;\n  integer num_packets = $random;\n  reg A, B, C, clk, reset_n;\n  wire D;\n  register_logic dut(A, B, C, clk, reset_n, D);\n\n  // generate clock\n  // ...\n\n  initial begin\n    run();\n  end\n\n  task run();\n    reset_n  = 1;\n    #20 reset_n = 0;\n    @(posedge clk) reset_n <= #1 1;\n    repeat (num_packets) begin\n      A = $random; B = $random; C = $random;\n      @(posedge clk);\n      $display(A, B, C, D);\n    end\n    $finish;\n  endtask\nendmodule\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"class Packet;\n  string name;\n  rand bit[3:0] sa, da;\n  rand reg A, B, C;\n\n  function void display(result);\n    $display(A, B, C, result);\n  endfunction\nendclass: Packet\n\n// inheritance\nclass Packet_da_3 extends Packet;\n  constraint da_3 {\n    da == 3;\n  }\n\n  function void display(result);\n    super.display(result);\n    $display(sa, da);\n  endfunction\nendclass: Packet_da_3\n\nclass Generator;\n  Packet pkt;\n  Channel out_chan;\n  int num_packets;\n\n  function void gen();\n    pkt = new():\n    pkt.randomize();\n    out_chan.put(pkt);\n  endfunction\n\n  task run();\n    while (num_packets-- != 0)\n      gen();\n  endtask\nendclass\n\nclass Driver;\n  Channel in_chan;\n\n  task send();\n    in_chan.get(pkt);\n    top.A = pkt.A;\n    top.B = pkt.B;\n    top.C = pkt.C;\n    @(posedge top.clk);\n  endtask\n\n  task run();\n    forever send();\n  endtask\nendclass\n\nmodule top;\n  initial begin\n    build();\n    run();\n  end\n\n  task build();\n    Config cfg = new();\n    Channel chan = new();\n    Generator gen = new();\n    Driver drv = new();\n    gen.out_chan = chan;\n    drv.in_chan = chan;\n\n    cfg.randomize() with { num_packets > 1500; }\n    gen.num_packets = cfg.num_packets;\n  endtask\n\n  task run();\n    fork\n      gen.run();\n      drv.run();\n    join\n    $finish;\n  endtask\nendmodule\n")),(0,i.kt)("h2",{id:"u280-platform"},"U280 Platform"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"-xp param (clock frequency etc.)\n-R report level\n-slr SLR region setting\n-sp memory resources mapping\n")),(0,i.kt)("p",null,"tools:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"xbutil query"),(0,i.kt)("li",{parentName:"ul"},"platforminfo"),(0,i.kt)("li",{parentName:"ul"},"kernelinfo"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"xclbinutil")),(0,i.kt)("li",{parentName:"ul"},"dmesg")),(0,i.kt)("h3",{id:"host-application"},"Host Application"),(0,i.kt)("h4",{id:"basic-flow"},"Basic Flow"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"set the kernel arguments before performing any enqueue operation"),(0,i.kt)("li",{parentName:"ul"},"keeping the buffer size ",(0,i.kt)("strong",{parentName:"li"},"2 MB ~ 4 GB")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"posix_memalign")," is used instead of malloc for the host memory space pointer")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"uint32_t *a, *b, *c, *d = NULL;\nposix_memalign((void **)&a, 4096, BUF_SIZE * sizeof(uint32_t));\nposix_memalign((void **)&b, 4096, BUF_SIZE * sizeof(uint32_t));\nposix_memalign((void **)&c, 4096, BUF_SIZE * sizeof(uint32_t));\nposix_memalign((void **)&d, 4096, BUF_SIZE * sizeof(uint32_t));\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"release resources for proper performance profile report")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"clReleaseCommandQueue(Command_Queue);\nclReleaseContext(Context);\nclReleaseDevice(Target_Device_ID);\nclReleaseKernel(Kernel);\nclReleaseProgram(Program);\nfree(Platform_IDs);\nfree(Device_IDs);\n")),(0,i.kt)("h4",{id:"tlp"},"TLP"),(0,i.kt)("p",null,"It is advisable to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"posix_spawn()")," system call\nto launch another process from the SDAccel environment application."),(0,i.kt)("h3",{id:"u280-tools"},"U280 Tools"),(0,i.kt)("h4",{id:"gdb-based-debugging"},"GDB Based Debugging"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"xprint queue [<cl_command_queue>]\nxprint event <cl_event>\nxprint mem [<cl_mem>]\nxprint kernel\nxprint all\nxstatus all\nxstatus --<ipName>\n")),(0,i.kt)("h4",{id:"xcl-binary-util"},"XCL Binary Util"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"xclbinutil -i binary_container_1.xclbin --info\n")),(0,i.kt)("h4",{id:"xocc"},"XOCC"),(0,i.kt)("p",null,"Checking out-of-bound access made by kernel interface buffers (option: address)\nand uninitialized memory access initiated by kernel local to kernel (option: memory)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"xocc -l \u2013t sw_emu --xp param:compiler.fsanitize=address -o bin_kernel.xclbin\nxocc -l \u2013t sw_emu --xp param:compiler.fsanitize=memory -o bin_kernel.xclbin\nxocc -l \u2013t sw_emu --xp param:compiler.fsanitize=address,memory -o bin_kernel.xclbin\n")),(0,i.kt)("h4",{id:"xbutil"},"XBUtil"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"sudo /opt/xilinx/xrt/bin/xbutil flash -a <shell_name> # flash the firmware\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"sudo lspci -vd 10ee:\nsudo /opt/xilinx/xrt/bin/xbutil flash scan\nsudo /opt/xilinx/xrt/bin/xbutil validate -d <card_id>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"xbutil program -p <xclbin>\nxbutil query         # check memory banks usage\nxbutil status --lapc # check AXI violations\n")),(0,i.kt)("h4",{id:"dmesg"},"dmesg"),(0,i.kt)("h4",{id:"ila-trigger"},"ILA Trigger"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"debug protocol hangs"),(0,i.kt)("li",{parentName:"ul"},"examine the burst size, pipelining and data width to locate the bottleneck")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'....\nstd::string binaryFile = xcl::find_binary_file(device_name,"vAdd");\ncl::Program::Binaries bins = xcl::import_binary_file(binaryFile);\ndevices.resize(1);\ncl::Program program(context, devices, bins);\ncl::Kernel kernel_vAdd(program,"kernel_vAdd_rtl");\n\n// wait_for_enter("\\nPress ENTER to continue after setting up ILA trigger...");\nstd::cout << "Pausing to arm ILA trigger. Hit enter here to resume host program..."\n          << std::endl;\nstd::cin::get();\n\n//Allocate Buffer in Global Memory\nstd::vector<cl::Memory> inBufVec, outBufVec;\ncl::Buffer buffer_r1(context,CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY,\nvector_size_bytes, source_input1.data());\n// ...\n// ...\n// ...\n\n//Copy input data to device global memory\nq.enqueueMigrateMemObjects(inBufVec,0/* 0 means from host*/);\n\n//Set the Kernel Arguments\n// ...\n// ...\n// ...\n\n//Launch the Kernel\nq.enqueueTask(kernel_vAdd);\n')),(0,i.kt)("h2",{id:"axi-protocol"},"AXI Protocol"),(0,i.kt)("p",null,"Advanced eXtensible Interface Protocol:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"handshake protocol: ready-valid protocol")),(0,i.kt)("h3",{id:"axi-channels"},"AXI Channels"),(0,i.kt)("h4",{id:"read-address-channel"},"Read Address Channel"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"arburst: burst type"),(0,i.kt)("li",{parentName:"ul"},"araddr: start address"),(0,i.kt)("li",{parentName:"ul"},"arlen: (# of transfers) - 1"),(0,i.kt)("li",{parentName:"ul"},"arsize: bytes/transfer"),(0,i.kt)("li",{parentName:"ul"},"arready (memory to host)"),(0,i.kt)("li",{parentName:"ul"},"arvalid")),(0,i.kt)("h4",{id:"read-data-channel"},"Read Data Channel"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"rdata: data"),(0,i.kt)("li",{parentName:"ul"},"rresp: response (failure check)"),(0,i.kt)("li",{parentName:"ul"},"rlast: flag for last piece of data"),(0,i.kt)("li",{parentName:"ul"},"rready (host to memory)"),(0,i.kt)("li",{parentName:"ul"},"rvalid")),(0,i.kt)("h4",{id:"write-address-channel"},"Write Address Channel"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"awburst: burst type"),(0,i.kt)("li",{parentName:"ul"},"awaddr: start address"),(0,i.kt)("li",{parentName:"ul"},"awlen: (# of transfers) - 1"),(0,i.kt)("li",{parentName:"ul"},"awsize: bytes/transfer"),(0,i.kt)("li",{parentName:"ul"},"awready (memory to host)"),(0,i.kt)("li",{parentName:"ul"},"awvalid")),(0,i.kt)("h4",{id:"write-data-channel"},"Write Data Channel"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"wdata: data"),(0,i.kt)("li",{parentName:"ul"},"wstrb: write strobe -> write mask (1 bit mask for 1 byte data)"),(0,i.kt)("li",{parentName:"ul"},"wlast: flag for last piece of data"),(0,i.kt)("li",{parentName:"ul"},"wready (memory to host)"),(0,i.kt)("li",{parentName:"ul"},"wvalid")),(0,i.kt)("h4",{id:"write-response-channel"},"Write Response Channel"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"bresp: response (failure check)"),(0,i.kt)("li",{parentName:"ul"},"bready (host to memory)"),(0,i.kt)("li",{parentName:"ul"},"bvalid")),(0,i.kt)("h3",{id:"axi-burst"},"AXI Burst"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"right"},"AxBURST","[1:0]"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Burst Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b00"),(0,i.kt)("td",{parentName:"tr",align:"left"},"FIXED")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b01"),(0,i.kt)("td",{parentName:"tr",align:"left"},"INCR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b10"),(0,i.kt)("td",{parentName:"tr",align:"left"},"WRAP")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b11"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Reserved")))),(0,i.kt)("p",null,"burst length = AxLEN","[7:0]"," + 1 (up to 256 transfers in each burst)"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"right"},"AxSIZE","[2:0]"),(0,i.kt)("th",{parentName:"tr",align:"right"},"Bytes in Transfer"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b000"),(0,i.kt)("td",{parentName:"tr",align:"right"},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b001"),(0,i.kt)("td",{parentName:"tr",align:"right"},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b010"),(0,i.kt)("td",{parentName:"tr",align:"right"},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b011"),(0,i.kt)("td",{parentName:"tr",align:"right"},"8")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b100"),(0,i.kt)("td",{parentName:"tr",align:"right"},"16")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b101"),(0,i.kt)("td",{parentName:"tr",align:"right"},"32")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b110"),(0,i.kt)("td",{parentName:"tr",align:"right"},"64")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"right"},"0b111"),(0,i.kt)("td",{parentName:"tr",align:"right"},"128")))),(0,i.kt)("h4",{id:"read-burst"},"Read Burst"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Read Burst Example",src:t(8923).Z,width:"1152",height:"623"})),(0,i.kt)("h4",{id:"write-burst"},"Write Burst"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Write Burst Example",src:t(7181).Z,width:"1144",height:"631"})),(0,i.kt)("h2",{id:"verilog-components"},"Verilog Components"),(0,i.kt)("h3",{id:"clock-unit"},"Clock Unit"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module tick_divider\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief simple clock divider\n * @param DATA_WIDTH data width\n * @input clk_src clock signal\n * @output clk_group divided clock signals\n */\nmodule tick_divider\n#(parameter DATA_WIDTH = 32)\n(\n    input clk_src,\n    output reg [(DATA_WIDTH-1): 0] clk_group\n);\n\n    initial begin\n        clk_group <= {(DATA_WIDTH){1'b0}};\n    end\n\n    always @(posedge clk_src) begin\n        clk_group <= clk_group + 1;\n    end\nendmodule\n")),(0,i.kt)("h3",{id:"signal-unit"},"Signal Unit"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module integer_to_segment\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief raw data to segment encoder\n * @param DATA_WIDTH data width\n * @input data raw decimal data (4 bit)\n * @output seg_data bit data for cNodes\n */\nmodule integer_to_segment\n(\n    input [3:0] int_data,\n    output reg [7:0] seg_data\n);\n\n    always @(int_data) begin\n        case (int_data)\n            4'b0000:    seg_data <= 8'b11000000;    // 0\n            4'b0001:    seg_data <= 8'b11111001;    // 1\n            4'b0010:    seg_data <= 8'b10100100;    // 2\n            4'b0011:    seg_data <= 8'b10110000;    // 3\n            4'b0100:    seg_data <= 8'b10011001;    // 4\n            4'b0101:    seg_data <= 8'b10010010;    // 5\n            4'b0110:    seg_data <= 8'b10000010;    // 6\n            4'b0111:    seg_data <= 8'b11111000;    // 7\n            4'b1000:    seg_data <= 8'b10000000;    // 8\n            4'b1001:    seg_data <= 8'b10010000;    // 9\n            4'b1010:    seg_data <= 8'b10001000;    // a\n            4'b1011:    seg_data <= 8'b10000011;    // b\n            4'b1100:    seg_data <= 8'b11000110;    // c\n            4'b1101:    seg_data <= 8'b10100001;    // d\n            4'b1110:    seg_data <= 8'b10000110;    // e\n            4'b1111:    seg_data <= 8'b10001110;    // f\n            default:    seg_data <= 8'b11111111;    // off\n        endcase\n    end\nendmodule\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module data_to_segment\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief raw data to segment encoder\n * @param DATA_WIDTH data width\n * @input data raw decimal data\n * @output seg_data bit data for cNodes\n */\nmodule data_to_segment\n#(parameter DATA_WIDTH = 32)\n(\n    input [(DATA_WIDTH-1):0] data,\n    output [(DATA_WIDTH*2)-1:0] seg_data\n);\n\n    integer_to_segment trans1 (\n        .int_data(data[3:0]),\n        .seg_data(seg_data[7:0])\n    );\n\n    integer_to_segment trans2 (\n        .int_data(data[7:4]),\n        .seg_data(seg_data[15:8])\n    );\n\n    integer_to_segment trans3 (\n        .int_data(data[11:8]),\n        .seg_data(seg_data[23:16])\n    );\n\n    integer_to_segment trans4 (\n        .int_data(data[15:12]),\n        .seg_data(seg_data[31:24])\n    );\n\n    integer_to_segment trans5 (\n        .int_data(data[19:16]),\n        .seg_data(seg_data[39:32])\n    );\n\n    integer_to_segment trans6 (\n        .int_data(data[23:20]),\n        .seg_data(seg_data[47:40])\n    );\n\n    integer_to_segment trans7 (\n        .int_data(data[27:24]),\n        .seg_data(seg_data[55:48])\n    );\n\n    integer_to_segment trans8 (\n        .int_data(data[31:28]),\n        .seg_data(seg_data[63:56])\n    );\n\nendmodule\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module led_unit\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief led display module (bind to aNodes and cNodes in FPGA)\n * @param DATA_WIDTH data width\n * @input clk_src clock signal (light different led on in round turn)\n * @input led_data raw decimal data\n * @output aNodes determine which led light on at now\n * @output cNodes determine how led light on (number)\n */\nmodule led_unit\n#(parameter DATA_WIDTH = 32)\n(\n    input clk_src,\n    input [(DATA_WIDTH-1):0] led_data,\n    output reg [7:0] aNodes,\n    output reg [7:0] cNodes\n);\n\n    reg [2:0] count; // 2^3 = 8\n    wire [(DATA_WIDTH*2)-1:0] seg_data;\n\n    initial begin\n        count <= 0;\n        aNodes <= 0;\n        cNodes <= 0;\n    end\n\n    data_to_segment #(\n        .DATA_WIDTH(DATA_WIDTH)\n    ) data_to_segment (\n        .data(led_data),\n        .seg_data(seg_data)\n    );\n\n    always @(posedge clk_src) begin\n        count = count + 1;\n    end\n\n    always @(count) begin\n        case (count)\n            3'b000: begin\n            aNodes = 8'b11111110;\n            cNodes = seg_data[7:0];\n        end\n        3'b001: begin\n            aNodes = 8'b11111101;\n            cNodes = seg_data[15:8];\n        end\n        3'b010:  begin\n            aNodes = 8'b11111011;\n            cNodes = seg_data[23:16];\n        end\n        3'b011: begin\n            aNodes = 8'b11110111;\n            cNodes = seg_data[31:24];\n        end\n        3'b100: begin\n            aNodes = 8'b11101111;\n            cNodes = seg_data[39:32];\n        end\n        3'b101: begin\n            aNodes = 8'b11011111;\n            cNodes = seg_data[47:40];\n        end\n        3'b110: begin\n            aNodes = 8'b10111111;\n            cNodes = seg_data[55:48];\n        end\n        3'b111: begin\n            aNodes = 8'b01111111;\n            cNodes = seg_data[63:56];\n        end\n        default: begin\n            aNodes = 8'b11111110;\n            cNodes = 8'b11111111;\n        end\n        endcase\n    end\n\nendmodule\n")),(0,i.kt)("h3",{id:"alu-unit"},"ALU Unit"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module counter\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief up counter\n * @param DATA_WIDTH data width\n * @param STEP counting step\n * @input clk clock signal\n * @input rst reset signal\n * @output en enable signal\n * @output count counting value\n */\nmodule counter\n#(parameter DATA_WIDTH = 1, STEP = 1)\n(\n    input clk,\n    input rst,\n    input en,\n    output reg [(DATA_WIDTH-1):0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0 ;\n        end else if (en) begin\n            count <= count + 1;\n        end else begin\n            count <= count;\n        end\n    end\n\nendmodule // counter\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module latch_counter\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief latch counter (latching when reaching max value)\n * @input clk clock signal\n * @input rst reset signal\n * @output en enable signal\n * @output count counting value\n */\nmodule latch_counter\n(\n    input clk,\n    input rst,\n    input en,\n    output reg count\n);\n\n    initial begin\n        count <= 0;\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0 ;\n        end else if (en) begin\n            if (count != 1) begin\n                count <= count + 1;\n            end else begin\n                count <= count;\n            end\n        end else begin\n            count <= count;\n        end\n    end\n\nendmodule // latch_counter\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module alu_flags\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief get flags after alu calculation\n * @param DATA_WIDTH data width\n * @input srcA A port data\n * @input srcB B port data\n * @input aluOP operation code\n * @output zero equal flag\n * @output of signed overflow flag\n * @output uof unsigned overflow flag\n */\nmodule alu_flags\n#(parameter DATA_WIDTH = 32)\n(\n    input [DATA_WIDTH-1:0] srcA,\n    input [DATA_WIDTH-1:0] srcB,\n    input [3:0] aluOP,\n    output zero,\n    output of,\n    output uof\n);\n\n    wire [DATA_WIDTH-1:0] sum, diff;\n    wire carry1, carry2;\n\n    assign {carry1, sum} = srcA + srcB;    // awesome tip\n    assign {carry2, diff} = srcA - srcB;    // awesome tip\n\n    assign zero = (srcA == srcB);\n    assign of = (aluOP == 4'd5) ? (\n      (srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & ~sum[DATA_WIDTH-1])\n      | (~srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & sum[DATA_WIDTH-1]))\n                : (aluOP == 4'd6) ? (\n      (srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & ~diff[DATA_WIDTH-1])\n      | (~srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & diff[DATA_WIDTH-1]))\n                : 0;\n    assign uof = (aluOP == 4'd5) ? (carry1)\n                : (aluOP == 4'd6) ? (carry2)\n                : 0;\n\nendmodule // alu_flags\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module alu\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @param DATA_WIDTH data width\n * @input srcA A port data\n * @input srcB B port data\n * @input aluOP operation code\n * @output aluOut calculation result\n * @output zero equal flag\n * @output of signed overflow flag\n * @output uof unsigned overflow flag\n */\nmodule alu\n#(parameter DATA_WIDTH = 32)\n(\n    input [DATA_WIDTH-1:0] srcA,\n    input [DATA_WIDTH-1:0] srcB,\n    input [3:0] aluOP,\n    output reg [DATA_WIDTH-1:0] aluOut,\n    output zero,\n    output of,\n    output uof\n);\n\n    wire signed [DATA_WIDTH-1:0] signed_srcA;\n    wire signed [DATA_WIDTH-1:0] signed_srcB;\n\n    assign signed_srcA = $signed(srcA);\n    assign signed_srcB = $signed(srcB);\n\n    always @ ( * ) begin\n        case (aluOP)\n            4'd0: aluOut <= srcA << srcB;\n            4'd1: aluOut <= signed_srcA >>> srcB;\n            4'd2: aluOut <= srcA >> srcB;\n            4'd3: aluOut <= srcA * srcB;\n            4'd4: aluOut <= srcA / srcB;\n            4'd5: aluOut <= srcA + srcB;  // awesome tip\n            4'd6: aluOut <= srcA - srcB;\n            4'd7: aluOut <= srcA & srcB;\n            4'd8: aluOut <= srcA | srcB;\n            4'd9: aluOut <= srcA ^ srcB;\n            4'd10: aluOut <= ~(srcA | srcB);\n            4'd11: aluOut <= (signed_srcA < signed_srcB) ? 1 : 0;\n            4'd12: aluOut <= (srcA < srcB) ? 1 : 0;\n            default: aluOut <= 0;\n        endcase\n    end\n\n    alu_flags #(\n        .DATA_WIDTH(DATA_WIDTH)\n    ) FLAGS  (\n        .srcA(srcA),\n        .srcB(srcB),\n        .aluOP(aluOP),\n        .zero(zero),\n        .of(of),\n        .uof(uof)\n    );\n\nendmodule // alu\n")),(0,i.kt)("h3",{id:"memory-unit"},"Memory Unit"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module register\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief D flip flop\n * @param DATA_WIDTH data width\n * @input clk clock signal\n * @input rst reset signal\n * @input en enable signal\n * @input din data in\n * @output dout data out\n */\nmodule register\n#(parameter DATA_WIDTH = 32)\n(\n    input clk,\n    input rst,\n    input en,\n    input [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            dout <= 0;      // reset\n        end else if (en) begin\n            dout <= din;    // update\n        end else begin\n            dout <= dout;   // hold\n        end\n    end\n\nendmodule // register\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},'/**\n * @module regFile\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief register files for MIPS CPU, contains 32 D flip-flop registers\n * @param DATA_WIDTH data width\n * @input clk clock signal\n * @input we write enable signal\n * @input raddrA read address (No.register) for A out port\n * @input raddrB read address (No.register) for B out port\n * @input waddr write address (No.register) for wdata (in port)\n * @input wdata data to write into regFile\n * @output regA A port output\n * @output regB B port output\n */\nmodule regFile\n#(parameter DATA_WIDTH = 32)\n(\n    input clk,\n    input rst,\n    input we,\n    input [4:0] raddrA,\n    input [4:0] raddrB,\n    input [4:0] waddr,\n    input [DATA_WIDTH-1:0] wdata,\n    output [DATA_WIDTH-1:0] regA,\n    output [DATA_WIDTH-1:0] regB,\n    output [DATA_WIDTH-1:0] v0_data,\n    output [DATA_WIDTH-1:0] a0_data\n);\n\n`include "defines.vh"\n\n    reg [4:0] i;\n\n    ///< three ported regFile contains 32 registers\n    reg [DATA_WIDTH-1:0] regFile [0:31];\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            for (i = 0; i < 31; i = i + 1)\n                begin\n                    regFile[i] <= 0;\n                end\n        end else if (we && waddr != 0) begin\n            regFile[waddr] <= wdata;\n        end\n    end\n\n    assign regA = (we && waddr == raddrA) ? wdata\n                : (raddrA != 0) ? regFile[raddrA]\n                : 0;\n    assign regB = (we && waddr == raddrB) ? wdata\n                : (raddrB != 0) ? regFile[raddrB]\n                : 0;\n    assign v0_data = regFile[`V0];\n    assign a0_data = regFile[`A0];\n\nendmodule // regFile\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},'/**\n * @module imem\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief instruction cache memory (ROM)\n * @param DATA_WIDTH data width\n * @param BUS_WIDTH bus width\n * @param CODE_FILE MIPS assembly hexadecimal code file\n * @input addr memory address\n * @output rdata instruction read out from memory\n */\nmodule imem\n#(parameter DATA_WIDTH = 32, BUS_WIDTH = 10, CODE_FILE= "mips/benchmark.hex")\n(\n    input [BUS_WIDTH-1:0] addr,\n    output [DATA_WIDTH-1:0] rdata\n);\n\n    reg [DATA_WIDTH-1:0] ROM [0:(2**BUS_WIDTH)-1];\n\n    initial begin\n        $readmemh(CODE_FILE, ROM, 0, (2**BUS_WIDTH)-1);\n    end\n\n    assign rdata = ROM[addr];\n\nendmodule // imem\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-verilog"},"/**\n * @module dmem\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief data cache memory (RAM)\n * @param DATA_WIDTH data width\n * @param BUS_WIDTH bus width\n * @input clk clock signal\n * @input re read enable signal\n * @input we write enable signal\n * @input addr memory address\n * @input wdata data write into memory\n * @output rdata data read out from memory\n */\nmodule dmem\n#(parameter DATA_WIDTH = 32, BUS_WIDTH = 10)\n(\n    input clk,\n    input re,\n    input we,\n    input [BUS_WIDTH-1:0] addr,\n    input [DATA_WIDTH-1:0] wdata,\n    input [4:0] switch_addr,\n    output [DATA_WIDTH-1:0] rdata,\n    output [DATA_WIDTH-1:0] led_data\n);\n\n    reg [DATA_WIDTH-1:0] RAM [0:(2**BUS_WIDTH)-1];\n\n    always @ (posedge clk) begin\n        if (we) begin\n            RAM[addr] <= wdata;\n        end\n    end\n\n    assign rdata = re ? RAM[addr] : {(DATA_WIDTH-1){1'bx}};\n    assign led_data = RAM[switch_addr];\n\nendmodule // dmem\n")))}c.isMDXComponent=!0},8923:function(e,n,t){n.Z=t.p+"assets/images/AXI_Read_Burst-bfe7b67affa60b173cbdf4376866a32f.png"},7181:function(e,n,t){n.Z=t.p+"assets/images/AXI_Write_Burst-5d68dc35f9b1456ab61a9ed9e46b52c7.png"}}]);