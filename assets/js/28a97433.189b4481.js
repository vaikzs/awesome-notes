"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[1432],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(t),d=r,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||l;return t?a.createElement(k,i(i({ref:n},p),{},{components:t})):a.createElement(k,i({ref:n},p))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},955:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return m}});var a=t(7462),r=t(3366),l=(t(7294),t(3905)),i=["components"],o={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Language","Rust"]},s="Rust Basic Notes",u={unversionedId:"language/rust/rustBasicNotes",id:"language/rust/rustBasicNotes",title:"Rust Basic Notes",description:"Toolchain",source:"@site/notes/language/rust/rustBasicNotes.md",sourceDirName:"language/rust",slug:"/language/rust/rustBasicNotes",permalink:"/awesome-notes/language/rust/rustBasicNotes",editUrl:"https://github.com/sabertazimi/awesome-notes/edit/main/notes/language/rust/rustBasicNotes.md",tags:[{label:"Language",permalink:"/awesome-notes/tags/language"},{label:"Rust",permalink:"/awesome-notes/tags/rust"}],version:"current",lastUpdatedBy:"sabertazimi",lastUpdatedAt:1649572540,formattedLastUpdatedAt:"4/10/2022",frontMatter:{author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Language","Rust"]},sidebar:"sidebar",previous:{title:"Python Basic Notes",permalink:"/awesome-notes/language/python/pythonBasicNotes"},next:{title:"Verilog Basic Notes",permalink:"/awesome-notes/language/verilog/verilogBasicNotes"}},p={},m=[{value:"Toolchain",id:"toolchain",level:2},{value:"Installation",id:"installation",level:3},{value:"Cargo",id:"cargo",level:3},{value:"Cargo Basic Commands",id:"cargo-basic-commands",level:4},{value:"Cargo Cache",id:"cargo-cache",level:4},{value:"Cargo Configuration",id:"cargo-configuration",level:4},{value:"GitHub Action",id:"github-action",level:3},{value:"Memory Model",id:"memory-model",level:2},{value:"Stack Value",id:"stack-value",level:3},{value:"Heap Value",id:"heap-value",level:3},{value:"Ownership",id:"ownership",level:2},{value:"Copy Trait",id:"copy-trait",level:3},{value:"Reference Type",id:"reference-type",level:3},{value:"String Type",id:"string-type",level:2},{value:"Struct Type",id:"struct-type",level:2},{value:"Tuple Struct",id:"tuple-struct",level:3},{value:"Unit-like Struct",id:"unit-like-struct",level:3},{value:"Enum Type",id:"enum-type",level:2},{value:"Array Type",id:"array-type",level:2},{value:"Type Alias",id:"type-alias",level:2},{value:"Type Conversion",id:"type-conversion",level:2},{value:"From Trait",id:"from-trait",level:3},{value:"Explicit Type Conversion",id:"explicit-type-conversion",level:3},{value:"Implicit Type Conversion",id:"implicit-type-conversion",level:3},{value:"Dynamically Sized Type",id:"dynamically-sized-type",level:2},{value:"Sized Trait",id:"sized-trait",level:3},{value:"Flow Control",id:"flow-control",level:2},{value:"If Statement",id:"if-statement",level:3},{value:"Loop Statement",id:"loop-statement",level:3},{value:"For Loop Statement",id:"for-loop-statement",level:4},{value:"While Loop Statement",id:"while-loop-statement",level:4},{value:"Loop Expression",id:"loop-expression",level:4},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Enum Pattern Matching",id:"enum-pattern-matching",level:3},{value:"Tuple Pattern Matching",id:"tuple-pattern-matching",level:3},{value:"Struct Pattern Matching",id:"struct-pattern-matching",level:3},{value:"Match Guard",id:"match-guard",level:3},{value:"Match Assignment",id:"match-assignment",level:3},{value:"Method",id:"method",level:2},{value:"Self",id:"self",level:3},{value:"Generics",id:"generics",level:2},{value:"Traits",id:"traits",level:2},{value:"Orphan Rule",id:"orphan-rule",level:3},{value:"Trait Bound",id:"trait-bound",level:3},{value:"Trait Derive",id:"trait-derive",level:3},{value:"Trait Object",id:"trait-object",level:3},{value:"Associated Types",id:"associated-types",level:3},{value:"Common Traits",id:"common-traits",level:3},{value:"Collection",id:"collection",level:2},{value:"Vector",id:"vector",level:3},{value:"HashMap",id:"hashmap",level:3},{value:"HashSet",id:"hashset",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Result Type",id:"result-type",level:3},{value:"Result Type Compositor",id:"result-type-compositor",level:3},{value:"Error Handling Macro",id:"error-handling-macro",level:3},{value:"Error Trait",id:"error-trait",level:3},{value:"Standard Error Trait",id:"standard-error-trait",level:4},{value:"Custom Error Type",id:"custom-error-type",level:4},{value:"Convert From Standard Error",id:"convert-from-standard-error",level:4},{value:"Format Print",id:"format-print",level:2},{value:"Format Print Macros",id:"format-print-macros",level:3},{value:"Format Print Placeholder",id:"format-print-placeholder",level:3},{value:"Debug Trait",id:"debug-trait",level:3},{value:"Display Trait",id:"display-trait",level:3},{value:"Lifetime",id:"lifetime",level:2},{value:"Function Lifetime",id:"function-lifetime",level:3},{value:"Static Lifetime",id:"static-lifetime",level:3},{value:"Lifetime Constraint",id:"lifetime-constraint",level:3},{value:"Closure",id:"closure",level:2},{value:"Function Parameter Closure",id:"function-parameter-closure",level:3},{value:"Function Return Closure",id:"function-return-closure",level:3},{value:"Iterator",id:"iterator",level:2},{value:"Iterator Trait",id:"iterator-trait",level:3},{value:"Adapter Methods",id:"adapter-methods",level:3},{value:"Smart Pointer",id:"smart-pointer",level:2},{value:"Box Type",id:"box-type",level:3},{value:"Deref Trait",id:"deref-trait",level:3},{value:"Drop Trait",id:"drop-trait",level:3},{value:"Reference Counting Type",id:"reference-counting-type",level:3},{value:"Cell and RefCell Type",id:"cell-and-refcell-type",level:3},{value:"Circle Reference",id:"circle-reference",level:3},{value:"Phantom Type",id:"phantom-type",level:2},{value:"Concurrent Programming",id:"concurrent-programming",level:2},{value:"Concurrency Programming Model",id:"concurrency-programming-model",level:3},{value:"Threads",id:"threads",level:3},{value:"Barrier",id:"barrier",level:3},{value:"Condition Variables and Mutex",id:"condition-variables-and-mutex",level:3},{value:"Threads Communication",id:"threads-communication",level:3},{value:"Tokio Semaphore",id:"tokio-semaphore",level:3},{value:"Atomic Primitives",id:"atomic-primitives",level:3},{value:"Send and Sync Trait",id:"send-and-sync-trait",level:3},{value:"Thread Pool",id:"thread-pool",level:3},{value:"Asynchronous Programming",id:"asynchronous-programming",level:2},{value:"Async and Await",id:"async-and-await",level:3},{value:"Future Trait",id:"future-trait",level:3},{value:"Asynchronous Runtime",id:"asynchronous-runtime",level:3},{value:"IO",id:"io",level:2},{value:"Path",id:"path",level:3},{value:"Files",id:"files",level:3},{value:"System",id:"system",level:2},{value:"Process",id:"process",level:3},{value:"Command Line",id:"command-line",level:3},{value:"Tests",id:"tests",level:2},{value:"Macros",id:"macros",level:2},{value:"Unsafe Code",id:"unsafe-code",level:2},{value:"Comments",id:"comments",level:2},{value:"Attributes",id:"attributes",level:2},{value:"Crate Attributes",id:"crate-attributes",level:3},{value:"Linter Attributes",id:"linter-attributes",level:3},{value:"Compile Attributes",id:"compile-attributes",level:3},{value:"Standard Library",id:"standard-library",level:2},{value:"Web Development",id:"web-development",level:2},{value:"Node.js Bindings",id:"nodejs-bindings",level:3},{value:"Library",id:"library",level:2},{value:"Reference",id:"reference",level:2}],c={toc:m};function d(e){var n=e.components,t=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"rust-basic-notes"},"Rust Basic Notes"),(0,l.kt)("h2",{id:"toolchain"},"Toolchain"),(0,l.kt)("h3",{id:"installation"},"Installation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n")),(0,l.kt)("h3",{id:"cargo"},"Cargo"),(0,l.kt)("h4",{id:"cargo-basic-commands"},"Cargo Basic Commands"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"cargo new hello_world\ncargo run\ncargo build\ncargo run --release\ncargo build --release\ncargo check\ncargo generate-lockfile\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"cargo fmt --check\ncargo clippy\ncargo test\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"cargo install cargo-edit\ncargo install cargo-release\ncargo install cargo-tarpaulin\ncargo install cargo-watch\ncargo install cargo-workspaces\n")),(0,l.kt)("p",null,"Cargo release configuration:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-toml"},'[workspace.metadata.release]\n# cargo install cargo-release\n# cargo release -x\nsign-commit = true\nsign-tag = true\nrelease = false\npush = false\npublish = false\nshared-version = true\npre-release-commit-message = "chore(release): {{version}}"\npost-release-commit-message = "chore(release): {{version}}"\ntag-message = "{{tag_name}}"\n')),(0,l.kt)("h4",{id:"cargo-cache"},"Cargo Cache"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"~/.cargo/"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"config.toml"),": global configuration."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"credentials.toml"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"cargo login")," related file."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},".crates.toml"),"/",(0,l.kt)("inlineCode",{parentName:"li"},".crates2.json"),": installed package information."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bin/"),": installed binaries."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"git/"),": installed rust git repositories.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"git/db/"),": installed git repositories."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"git/checkouts/"),": branches of git repositories."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"registry/"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"crates.io")," metadata and packages.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"registry/index/"),": metadata git repository."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"registry/cache/"),": dependencies cache (",(0,l.kt)("inlineCode",{parentName:"li"},".crate")," gzip files)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"registry/src/"),": package source files.")))),(0,l.kt)("h4",{id:"cargo-configuration"},"Cargo Configuration"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cargo-features"),": \u53ea\u80fd\u7528\u4e8e ",(0,l.kt)("inlineCode",{parentName:"li"},"nightly"),"\u7248\u672c\u7684 ",(0,l.kt)("inlineCode",{parentName:"li"},"feature"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[package]"),": \u5b9a\u4e49\u9879\u76ee( ",(0,l.kt)("inlineCode",{parentName:"li"},"package")," )\u7684\u5143\u4fe1\u606f.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"name"),": \u540d\u79f0."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"version"),": \u7248\u672c."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"authors"),": \u5f00\u53d1\u4f5c\u8005."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"edition"),": Rust edition.."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rust-version"),": \u652f\u6301\u7684\u6700\u5c0f\u5316 Rust \u7248\u672c."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"description"),": \u63cf\u8ff0."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"documentation"),": \u6587\u6863 URL."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"readme"),": README \u6587\u4ef6\u7684\u8def\u5f84."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"homepage"),": \u4e3b\u9875 URL."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"repository"),": \u6e90\u4ee3\u7801\u4ed3\u5e93\u7684 URL."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"license"),": \u5f00\u6e90\u534f\u8bae License.."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"license-file"),": License \u6587\u4ef6\u7684\u8def\u5f84.."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"keywords"),": \u9879\u76ee\u7684\u5173\u952e\u8bcd."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"categories"),": \u9879\u76ee\u5206\u7c7b."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"workspace"),": \u5de5\u4f5c\u7a7a\u95f4 workspace \u7684\u8def\u5f84."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"build"),": \u6784\u5efa\u811a\u672c\u7684\u8def\u5f84."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"links"),": \u672c\u5730\u94fe\u63a5\u5e93\u7684\u540d\u79f0."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"exclude"),": \u53d1\u5e03\u65f6\u6392\u9664\u7684\u6587\u4ef6."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"include"),": \u53d1\u5e03\u65f6\u5305\u542b\u7684\u6587\u4ef6."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"publish"),": \u7528\u4e8e\u963b\u6b62\u9879\u76ee\u7684\u53d1\u5e03."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"metadata"),": \u989d\u5916\u7684\u914d\u7f6e\u4fe1\u606f\uff0c\u7528\u4e8e\u63d0\u4f9b\u7ed9\u5916\u90e8\u5de5\u5177."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"default-run"),": ","[",(0,l.kt)("inlineCode",{parentName:"li"},"cargo run"),"]"," \u6240\u4f7f\u7528\u7684\u9ed8\u8ba4\u53ef\u6267\u884c\u6587\u4ef6( binary )."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"autobins"),": \u7981\u6b62\u53ef\u6267\u884c\u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"autoexamples"),": \u7981\u6b62\u793a\u4f8b\u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"autotests"),": \u7981\u6b62\u6d4b\u8bd5\u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"autobenches"),": \u7981\u6b62 bench \u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"resolver"),": \u8bbe\u7f6e\u4f9d\u8d56\u89e3\u6790\u5668( dependency resolver)."))),(0,l.kt)("li",{parentName:"ul"},"Cargo target configuration:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[lib]"),": Library target."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[[bin]]"),": Binary target."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[[example]]"),": Example target."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[[test]]"),": Test target."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[[bench]]"),": Benchmark target."))),(0,l.kt)("li",{parentName:"ul"},"Dependency tables:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[dependencies]"),": \u9879\u76ee\u4f9d\u8d56\u5305."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[dev-dependencies]"),":\n\u7528\u4e8e examples\u3001tests \u548c benchmarks \u7684\u4f9d\u8d56\u5305."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[build-dependencies]"),": \u7528\u4e8e\u6784\u5efa\u811a\u672c\u7684\u4f9d\u8d56\u5305."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[target]"),": \u5e73\u53f0\u7279\u5b9a\u7684\u4f9d\u8d56\u5305."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[badges]"),": \u7ef4\u62a4\u72b6\u6001."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[features]"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"features")," \u53ef\u4ee5\u7528\u4e8e\u6761\u4ef6\u7f16\u8bd1."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[patch]"),": \u63a8\u8350\u4f7f\u7528\u7684\u4f9d\u8d56\u8986\u76d6\u65b9\u5f0f."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[profile]"),": \u7f16\u8bd1\u5668\u8bbe\u7f6e\u548c\u4f18\u5316."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[workspace]"),": \u5de5\u4f5c\u7a7a\u95f4\u7684\u5b9a\u4e49.")),(0,l.kt)("h3",{id:"github-action"},"GitHub Action"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Use ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/mozilla/sccache"},"tool")," to speed up compilation.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yml"},"name: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  test:\n    name: Test Suite\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - uses: actions-rs/cargo@v1\n        with:\n          command: test\n          args: --all-features --workspace\n\n  rustfmt:\n    name: Rustfmt\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n          components: rustfmt\n      - name: Check formatting\n        uses: actions-rs/cargo@v1\n        with:\n          command: fmt\n          args: --all -- --check\n\n  clippy:\n    name: Clippy\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n          components: clippy\n      - name: Clippy check\n        uses: actions-rs/cargo@v1\n        with:\n          command: clippy\n          args: --all-targets --all-features --workspace -- -D warnings\n\n  docs:\n    name: Docs\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Check documentation\n        env:\n          RUSTDOCFLAGS: -D warnings\n        uses: actions-rs/cargo@v1\n        with:\n          command: doc\n          args: --no-deps --document-private-items --all-features --workspace\n\n  publish-dry-run:\n    name: Publish dry run\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - uses: actions-rs/cargo@v1\n        with:\n          command: publish\n          args: --dry-run\n\n  coverage:\n    name: Code coverage\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Run cargo-tarpaulin\n        uses: actions-rs/tarpaulin@v0.1\n        with:\n          args: --all-features --workspace --ignore-tests --out Lcov\n      - name: Upload to Coveralls\n        if: ${{ github.event_name == 'push' }}\n        uses: coverallsapp/github-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          path-to-lcov: ./lcov.info\n")),(0,l.kt)("h2",{id:"memory-model"},"Memory Model"),(0,l.kt)("h3",{id:"stack-value"},"Stack Value"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Primitives"),(0,l.kt)("li",{parentName:"ul"},"Fixed size struts."),(0,l.kt)("li",{parentName:"ul"},"Fixed size arrays."),(0,l.kt)("li",{parentName:"ul"},"Pointers and references.")),(0,l.kt)("h3",{id:"heap-value"},"Heap Value"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Collections:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Arrays."),(0,l.kt)("li",{parentName:"ul"},"Lists."),(0,l.kt)("li",{parentName:"ul"},"Strings."))),(0,l.kt)("li",{parentName:"ul"},"Dynamic sized objects:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Box."),(0,l.kt)("li",{parentName:"ul"},"Trait objects.")))),(0,l.kt)("h2",{id:"ownership"},"Ownership"),(0,l.kt)("h3",{id:"copy-trait"},"Copy Trait"),(0,l.kt)("p",null,"Copyable type (implement ",(0,l.kt)("inlineCode",{parentName:"p"},"Copy")," trait):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Integer type."),(0,l.kt)("li",{parentName:"ul"},"Bool type."),(0,l.kt)("li",{parentName:"ul"},"Float type."),(0,l.kt)("li",{parentName:"ul"},"Char type."),(0,l.kt)("li",{parentName:"ul"},"Copyable Tuple type, e.g ",(0,l.kt)("inlineCode",{parentName:"li"},"(i32, i32)"),"."),(0,l.kt)("li",{parentName:"ul"},"Reference type (",(0,l.kt)("strong",{parentName:"li"},"borrowing")," ownership).")),(0,l.kt)("p",null,"Most these types store on stack\n(including reference type with vtable)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // Primitive type.\n    let a = 5;\n    let b = a;\n\n    // Reference type.\n    let x: &str = "hello, world";\n    let y = x;\n\n    // Deep clone on `non-Copy` type.\n    let s1 = String::from("hello");\n    let s2 = s1.clone();\n\n    // Correct.\n    println!("a = {}, b = {}", a, b);\n    println!("x = {}, y = {}", x, y);\n    println!("s1 = {}, s2 = {}", s1, s2);\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("hello");\n    let s2 = s1;\n\n    // Error[E0382]: use of moved value: `s1`.\n    // Move occurs because `s1` has type `std::string::String`,\n    // which does not implement the `Copy` trait.\n    println!("{}, world!", s1);\n}\n')),(0,l.kt)("h3",{id:"reference-type"},"Reference Type"),(0,l.kt)("p",null,"Borrowing ownership with reference type:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"At same time, only one mutable reference or multiple immutable reference."),(0,l.kt)("li",{parentName:"ul"},"Reference should be valid (rustc will report dangling reference error).")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("hello");\n    let len = calculate_length(&s1);\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n    // Leave function without drop `s`,\n    // due to `s` not owner string.\n}\n')),(0,l.kt)("p",null,"Mutable reference:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Only one mutable reference for a value in a scope)."),(0,l.kt)("li",{parentName:"ul"},"Can't mutable borrow an already immutable borrowed value.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut s = String::from("hello");\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n   let mut s = String::from("hello");\n\n    let r1 = &s;\n    let r2 = &s;\n    let r3 = &mut s;\n\n    // Error.\n    println!("{}, {} and {}", r1, r2, r3);\n    // End of r1 and r2 borrowing.\n\n    // Correct.\n    let r4 = &mut s;\n    println!("{}", r4);\n}\n')),(0,l.kt)("h2",{id:"string-type"},"String Type"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"&str")," string slice reference type:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Borrowing type."),(0,l.kt)("li",{parentName:"ul"},"UTF-8 encode (1 ~ 4 bytes)."),(0,l.kt)("li",{parentName:"ul"},"String literal is ",(0,l.kt)("inlineCode",{parentName:"li"},"&str")," type.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("hello world");\nlet len = s.len();\n\nlet hello = &s[0..5];\nlet world = &s[6..11];\nlet slice1 = &s[0..2];\nlet slice2 = &s[..2];\nlet slice3 = &s[4..len];\nlet slice4 = &s[4..];\nlet slice5 = &s[0..len];\nlet slice6 = &s[..];\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"String")," type:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Ownership type."),(0,l.kt)("li",{parentName:"ul"},"UTF-8 encode (1 ~ 4 bytes).")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut s = String::new();\n    s.push_str("hello,world");\n    s.push(\'!\');\n    assert_eq!(s,"hello,world!");\n\n    let mut s = "hello,world".to_string();\n    s.push(\'!\');\n    assert_eq!(s,"hello,world!");\n\n    let mut s = String::from("\u4f60\u597d, \u4e16\u754c");\n    s.push(\'!\');\n    assert_eq!(s,"\u4f60\u597d, \u4e16\u754c!");\n\n    let s1 = String::from("hello,");\n    let s2 = String::from("world!");\n    let s3 = s1 + &s2;\n    assert_eq!(s3,"hello,world!");\n\n    for c in "\u4e2d\u56fd\u4eba".chars() {\n        println!("{}", c);\n    }\n}\n')),(0,l.kt)("h2",{id:"struct-type"},"Struct Type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n\nlet user1 = User {\n    email: String::from("someone@example.com"),\n    username: String::from("username123"),\n    active: true,\n    sign_in_count: 1,\n};\n\nlet user2 = User {\n    email: String::from("another@example.com"),\n    ..user1\n};\n')),(0,l.kt)("h3",{id:"tuple-struct"},"Tuple Struct"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"struct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"newtype"),": Wrap type into tuple struct:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Make code more readable."),(0,l.kt)("li",{parentName:"ul"},"Implement 3rd traits for 3rd types."),(0,l.kt)("li",{parentName:"ul"},"Hide internal details of types.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"struct Meters(u32);\n")),(0,l.kt)("h3",{id:"unit-like-struct"},"Unit-like Struct"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"struct AlwaysEqual;\nlet subject = AlwaysEqual;\nimpl SomeTrait for AlwaysEqual {}\n")),(0,l.kt)("h2",{id:"enum-type"},"Enum Type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let m1 = Message::Quit;\n    let m2 = Message::Move{x: 1, y: 1};\n    let m3 = Message::ChangeColor(255, 255, 0);\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"enum Option<T> {\n    Some(T),\n    None,\n}\n\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n")),(0,l.kt)("h2",{id:"array-type"},"Array Type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let a: [i32; 5] = [1, 2, 3, 4, 5];\nlet b = [3; 5];\nlet slice: &[i32] = &a[1..3];\nassert_eq!(slice, &[2, 3]);\n\nfn main() {\n  let one             = [1, 2, 3];\n  let two: [u8; 3]    = [1, 2, 3];\n  let blank1          = [0; 3];\n  let blank2: [u8; 3] = [0; 3];\n\n  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];\n\n  for a in &arrays {\n    print!("{:?}: ", a);\n\n    for n in a.iter() {\n      print!("\\t{} + 10 = {}", n, n+10);\n    }\n\n    let mut sum = 0;\n\n    for i in 0..a.len() {\n      sum += a[i];\n    }\n\n    println!("\\t({:?} = {})", a, sum);\n  }\n}\n')),(0,l.kt)("h2",{id:"type-alias"},"Type Alias"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'type Meters = i32;\n\nlet x: u32 = 5;\nlet y: Meters = 5;\n\nprintln!("x + y = {}", x + y);\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'type Result<T> = std::result::Result<T, std::io::Error>;\ntype Thunk = Box<dyn Fn() + Send + \'static>;\n\nlet f: Thunk = Box::new(|| println!("hi"));\nfn takes_long_type(f: Thunk) {}\nfn returns_long_type() -> Thunk {}\n')),(0,l.kt)("h2",{id:"type-conversion"},"Type Conversion"),(0,l.kt)("h3",{id:"from-trait"},"From Trait"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!("My number is {:?}", num);\n\n    let int = 5;\n    let num: Number = int.into();\n    println!("My number is {:?}", num);\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom<i32> for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n    let result: Result<EvenNumber, ()> = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result<EvenNumber, ()> = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n")),(0,l.kt)("h3",{id:"explicit-type-conversion"},"Explicit Type Conversion"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let a = 3.1 as i8;\n    let b = 100_i8 as i32;\n    let c = \'a\' as u8;\n    println!("{}, {}, {}", a, b, c)\n\n    let x: i16 = 1500;\n    let x_: u8 = match x.try_into() {\n        Ok(x1) => x1,\n        Err(e) => {\n            println!("{:?}", e.to_string());\n            0\n        }\n    };\n}\n')),(0,l.kt)("h3",{id:"implicit-type-conversion"},"Implicit Type Conversion"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"target.method()"),":"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Call by value: ",(0,l.kt)("inlineCode",{parentName:"li"},"T::method(target)"),"."),(0,l.kt)("li",{parentName:"ol"},"Call by reference: ",(0,l.kt)("inlineCode",{parentName:"li"},"T::method(&target)")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"T::method(&mut target)"),"."),(0,l.kt)("li",{parentName:"ol"},"Call by deref: when ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Deref<Target = U>"),", then ",(0,l.kt)("inlineCode",{parentName:"li"},"(&T).method() => (&U).method()"),"."),(0,l.kt)("li",{parentName:"ol"},"Length-non-determined collection to length-determined slice."),(0,l.kt)("li",{parentName:"ol"},"Panic.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"let array: Rc<Box<[T; 3]>> = ...;\nlet first_entry = array[0];\n// 1. `Index` trait grammar sugar: array[0] => array.index(0).\n// 2. Call by: value: `Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 3. Call by reference: `&Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 4. Call by reference: `&mut Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 5. Call by deref -> Call by value: `Box<[T; 3]>` not impl `Index` trait.\n// 6. Call by deref -> Call by reference: `&Box<[T; 3]>` not impl `Index` trait.\n// 7. Call by deref -> Call by reference: `&mut Box<[T; 3]>` not impl `Index` trait.\n// 8. Call by deref -> Call by deref: `[T; 3]` not impl `Index` trait.\n// 9. `[T; 3]` => `[T]` impl `Index` trait.\n")),(0,l.kt)("h2",{id:"dynamically-sized-type"},"Dynamically Sized Type"),(0,l.kt)("p",null,"DST:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"DST \u65e0\u6cd5\u5355\u72ec\u88ab\u4f7f\u7528, \u5fc5\u987b\u8981\u901a\u8fc7 ",(0,l.kt)("inlineCode",{parentName:"li"},"&"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Box"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Rc")," \u6765\u95f4\u63a5\u4f7f\u7528."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"str"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"[T]"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"dyn Trait"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'// Error!\nlet s1: str = "Hello there!";\nlet s2: str = "How\'s it going?";\n\n// Ok.\nlet s3: &str = "on?"\nlet s4: Box<str> = "Hello there!".into();\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"// Error!\nfn my_function(n: usize) {\n    let array = [123; n];\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn foobar_1(thing: &dyn MyThing) {}     // OK.\nfn foobar_2(thing: Box<dyn MyThing>) {} // OK.\nfn foobar_3(thing: Rc<dyn MyThing>) {}  // OK.\nfn foobar_4(thing: MyThing) {}          // ERROR!\n")),(0,l.kt)("h3",{id:"sized-trait"},"Sized Trait"),(0,l.kt)("p",null,"Implicit sized trait:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn generic<T>(t: T) {}\n// Auto-transform to by Rust compiler\nfn generic<T: Sized>(t: T) {}\n")),(0,l.kt)("p",null,"Dynamic sized generics:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn generic<T: ?Sized>(t: &T) {}\n")),(0,l.kt)("h2",{id:"flow-control"},"Flow Control"),(0,l.kt)("h3",{id:"if-statement"},"If Statement"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"if")," expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"let number = if condition {\n    5\n} else {\n    6\n};\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"if let")," expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"let o = Some(3);\nlet v = if let Some(x) = o {\n    x\n} else {\n    0\n};\n")),(0,l.kt)("h3",{id:"loop-statement"},"Loop Statement"),(0,l.kt)("h4",{id:"for-loop-statement"},"For Loop Statement"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"for i in 1..=5 {}\nfor _ in 0..10 {}\nfor item in collection {}\nfor item in &collection {}\nfor item in &mut collection {}\nfor (i, v) in collection.iter().enumerate() {}\n")),(0,l.kt)("h4",{id:"while-loop-statement"},"While Loop Statement"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut n = 0;\n\n    while n <= 5  {\n        println!("{}!", n);\n        n = n + 1;\n    }\n}\n')),(0,l.kt)("h4",{id:"loop-expression"},"Loop Expression"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!("The result is {}", result);\n}\n')),(0,l.kt)("h2",{id:"pattern-matching"},"Pattern Matching"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"match target {\n    pattern1 => expression1,\n    pattern2 => {\n        statement1;\n        statement2;\n        expression2\n    },\n    _ => expression3\n}\n\nif let pattern = target {\n    statement;\n    expression\n}\n\nwhile let pattern = target {\n    statement;\n}\n")),(0,l.kt)("h3",{id:"enum-pattern-matching"},"Enum Pattern Matching"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'enum Action {\n    Say(String),\n    MoveTo(i32, i32),\n    ChangeColorRGB(u16, u16, u16),\n}\n\nfn main() {\n    let actions = [\n        Action::Say("Hello Rust".to_string()),\n        Action::MoveTo(1,2),\n        Action::ChangeColorRGB(255,255,0),\n    ];\n\n    for action in actions {\n        match action {\n            Action::Say(s) => {\n                println!("{}", s);\n            },\n            Action::MoveTo(x, y) => {\n                println!("point from (0, 0) move to ({}, {})", x, y);\n            },\n            Action::ChangeColorRGB(r, g, _) => {\n                println!("change color into \'(r:{}, g:{}, b:0)\', \'b\' has been ignored",\n                    r, g,\n                );\n            }\n        }\n    }\n}\n')),(0,l.kt)("h3",{id:"tuple-pattern-matching"},"Tuple Pattern Matching"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!("Some numbers: {}, {}", first, last);\n        },\n    }\n}\n')),(0,l.kt)("h3",{id:"struct-pattern-matching"},"Struct Pattern Matching"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'struct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7, z: 0 };\n    let Point { x: a, y: b, z: c } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n    assert_eq!(0, c);\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n    match origin {\n        Point { x, .. } => println!("x is {}", x),\n    }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!("On the x axis at {}", x),\n        Point { x: 0, y } => println!("On the y axis at {}", y),\n        Point { x, y } => println!("On neither axis: ({}, {})", x, y),\n    }\n}\n')),(0,l.kt)("h3",{id:"match-guard"},"Match Guard"),(0,l.kt)("p",null,"Combine pattern matching and ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let num = Some(4);\n\nmatch num {\n    Some(x) if x < 5 => println!("less than five: {}", x),\n    Some(x) => println!("{}", x),\n    None => (),\n}\n')),(0,l.kt)("h3",{id:"match-assignment"},"Match Assignment"),(0,l.kt)("p",null,"Combine pattern matching and ",(0,l.kt)("inlineCode",{parentName:"p"},"@")," expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'enum Message {\n    Hello { id: i32 },\n}\n\nlet msg = Message::Hello { id: 5 };\n\nmatch msg {\n    Message::Hello { id: id_variable @ 3..=7 } => {\n        println!("Found an id in range: {}", id_variable)\n    },\n    Message::Hello { id: 10..=12 } => {\n        println!("Found an id in another range")\n    },\n    Message::Hello { id } => {\n        println!("Found some other id: {}", id)\n    },\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};\n    println!("x: {}, y: {}", px, py);\n    println!("{:?}", p);\n\n    let point = Point {x: 10, y: 5};\n    if let p @ Point {x: 10, y} = point {\n        println!("x is 10 and y is {} in {:?}", y, p);\n    } else {\n        println!("x was not 10 :(");\n    }\n}\n')),(0,l.kt)("h2",{id:"method"},"Method"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"struct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn new(x: f64, y: f64, radius: f64) -> Circle {\n        Circle {\n            x,\n            y,\n            radius,\n        }\n    }\n\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nimpl Message {\n    fn call(&self) {}\n}\n\nfn main() {\n    let m = Message::Write(String::from("hello"));\n    m.call();\n}\n')),(0,l.kt)("h3",{id:"self"},"Self"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"self"),": \u6240\u6709\u6743\u8f6c\u79fb."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"&self"),": \u4e0d\u53ef\u53d8\u501f\u7528."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"&mut self"),": \u53ef\u53d8\u501f\u7528.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    pub fn new(width: u32, height: u32) -> Self {\n        Rectangle { width, height }\n    }\n    pub fn width(&self) -> u32 {\n        return self.width;\n    }\n    pub fn height(&self) -> u32 {\n        return self.height;\n    }\n}\n\nfn main() {\n    let rect = Rectangle::new(30, 50);\n    println!("{}", rect.width());\n    println!("{}", rect.height());\n}\n')),(0,l.kt)("h2",{id:"generics"},"Generics"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"enum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n\n    fn mixup<U>(self, other: Point<U>) {}\n}\n\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\n\nfn add<T: std::ops::Add<T, Output = T>>(a:T, b:T) -> T {\n    a + b\n}\n\nfn largest<T: PartialOrd>(list: &[T]) -> T {}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"TurboFish:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"generics_struct::<T>::method()"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"struct.generics_method::<T>()"),"."))),(0,l.kt)("li",{parentName:"ul"},"Use associated types in traits.")),(0,l.kt)("h2",{id:"traits"},"Traits"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct Post {\n    pub username: String,\n    pub content: String\n}\n\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!("(Read more from {}...)", self.summarize_author())\n    }\n}\n\nimpl Summary for Post {\n    fn summarize_author(&self) -> String {\n        format!("@{}", self.username)\n    }\n}\n\nfn main() {\n    let post = Post{username: "username".to_string(),content: "content".to_string()};\n    println!("1 new post: {}", post.summarize());\n}\n')),(0,l.kt)("h3",{id:"orphan-rule"},"Orphan Rule"),(0,l.kt)("p",null,"Rust can\u2019t implement external traits on external types:\ncan\u2019t implement the ",(0,l.kt)("inlineCode",{parentName:"p"},"Display")," trait on ",(0,l.kt)("inlineCode",{parentName:"p"},"Vec<T>")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"some_package")," crate,\nbecause ",(0,l.kt)("inlineCode",{parentName:"p"},"Display")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Vec<T>")," are ",(0,l.kt)("strong",{parentName:"p"},"both")," defined out of ",(0,l.kt)("inlineCode",{parentName:"p"},"some_package"),".\nThis restriction is part of a property of programs called coherence,\nensures that other people\u2019s code can\u2019t break your code and vice versa."),(0,l.kt)("h3",{id:"trait-bound"},"Trait Bound"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn notify(item: &impl Summary) {}\nfn notify(item: &(impl Summary + Display)) {}\nfn notify<T: Summary>(item: &T) {}\nfn notify<T: Summary + Display>(item: &T) {}\nfn notify<T, U>(t: &T, u: &U) -> i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"trait SomeTrait: BoundTrait {}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"// \u53ef\u4ee5\u5bf9\u4efb\u4f55\u5b9e\u73b0\u4e86 Display \u7279\u5f81\u7684\u7c7b\u578b\u8c03\u7528 ToString \u7279\u5f81\u4e2d\u65b9\u6cd5.\nimpl<T: Display> ToString for T {}\n")),(0,l.kt)("h3",{id:"trait-derive"},"Trait Derive"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug)]\n#[derive(PartialEq)]\n#[derive(Eq)]\n#[derive(PartialOrd)]\n#[derive(Ord)]\n#[derive(Clone)]\n#[derive(Copy)]\n#[derive(Hash)]\n#[derive(Default)]\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'trait Person {\n    fn name(&self) -> String;\n}\n\ntrait Student: Person {\n    fn university(&self) -> String;\n}\n\ntrait Programmer {\n    fn fav_language(&self) -> String;\n}\n\ntrait CompSciStudent: Programmer + Student {\n    fn git_username(&self) -> String;\n}\n\nfn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String {\n    format!(\n        "My name is {} and I attend {}. My language is {}. My Git username is {}",\n        student.name(),\n        student.university(),\n        student.fav_language(),\n        student.git_username()\n    )\n}\n')),(0,l.kt)("h3",{id:"trait-object"},"Trait Object"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Define trait object:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Box<dyn some_trait>"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"&dyn some_trait"),"."))),(0,l.kt)("li",{parentName:"ul"},"A trait can have trait object only when\nit is ",(0,l.kt)("inlineCode",{parentName:"li"},"object safe"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"all methods can't return ",(0,l.kt)("inlineCode",{parentName:"li"},"Self"),"."),(0,l.kt)("li",{parentName:"ul"},"all methods can't be generics."))),(0,l.kt)("li",{parentName:"ul"},"Trait object has ",(0,l.kt)("inlineCode",{parentName:"li"},"'static")," lifetime."),(0,l.kt)("li",{parentName:"ul"},"Trait object stand for dynamic distributing (runtime),\ngenerics stand for static distributing (compile time).")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'trait Draw {\n    fn draw(&self) -> String;\n}\n\nimpl Draw for u8 {\n    fn draw(&self) -> String {\n        format!("u8: {}", *self)\n    }\n}\n\nimpl Draw for f64 {\n    fn draw(&self) -> String {\n        format!("f64: {}", *self)\n    }\n}\n\nfn draw1(x: Box<dyn Draw>) {\n    x.draw();\n}\n\nfn draw2(x: &dyn Draw) {\n    x.draw();\n}\n\nfn main() {\n    let x = 1.1f64;\n    let y = 8u8;\n\n    draw1(Box::new(x));\n    draw1(Box::new(y));\n    draw2(&x);\n    draw2(&y);\n}\n')),(0,l.kt)("h3",{id:"associated-types"},"Associated Types"),(0,l.kt)("p",null,"Associated types make code become readable and concise:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"trait Container<A,B> {\n    fn contains(&self,a: A,b: B) -> bool;\n}\n\nfn difference<A,B,C>(container: &C) -> i32\n  where\n    C : Container<A,B> {}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"trait Container{\n    type A;\n    type B;\n    fn contains(&self, a: &Self::A, b: &Self::B) -> bool;\n}\n\nfn difference<C: Container>(container: &C) {}\n")),(0,l.kt)("p",null,"For all ",(0,l.kt)("strong",{parentName:"p"},"generic trait"),",\nuse associated types better than ",(0,l.kt)("inlineCode",{parentName:"p"},"<T>"),"."),(0,l.kt)("h3",{id:"common-traits"},"Common Traits"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::fmt::Display")," (better than ",(0,l.kt)("inlineCode",{parentName:"li"},"std::string::ToString"),")."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::fmt::Debug"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::ops::Add"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Mul"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Div"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"BitAnd"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"BitOr"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Not"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Neg"),": operators overload."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::ops::Fn"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"FnMut"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"FnOnce"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::ops::Deref"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::ops::Drop"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::clone::Clone"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::iter::Iterator"),".")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"std::prelude"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::marker::{Copy, Send, Sized, Sync, Unpin}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::ops::{Drop, Fn, FnMut, FnOnce}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::mem::drop"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::boxed::Box"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::borrow::ToOwned"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::clone::Clone"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::cmp::{PartialEq, PartialOrd, Eq, Ord}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::convert::{AsRef, AsMut, Into, From}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::default::Default"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::option::Option::{self, Some, None}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::result::Result::{self, Ok, Err}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::string::{String, ToString}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::vec::Vec"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::convert::{TryFrom, TryInto}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::iter::FromIterator"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::io::prelude::*;\n")),(0,l.kt)("h2",{id:"collection"},"Collection"),(0,l.kt)("h3",{id:"vector"},"Vector"),(0,l.kt)("p",null,"Create and Insert:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"let mut v = Vec::new();\nv.push(1);\n")),(0,l.kt)("p",null,"Access and Get:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let v = vec![1, 2, 3, 4, 5];\n\nlet third: &i32 = &v[2];\nprintln!("3rd: {}", third);\n\nmatch v.get(2) {\n    Some(third) => println!("3rd: {}", third),\n    None => println!("None."),\n}\n')),(0,l.kt)("p",null,"Visit:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let v = vec![1, 2, 3];\n\nfor i in &v {\n    println!("{}", i);\n}\n')),(0,l.kt)("p",null,"Visit and Mutate:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"let mut v = vec![1, 2, 3];\n\nfor i in &mut v {\n    *i += 10\n}\n")),(0,l.kt)("p",null,"Store different types:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'enum IpAddr {\n    V4(String),\n    V6(String)\n}\n\nfn main() {\n    let v = vec![\n        IpAddr::V4("127.0.0.1".to_string()),\n        IpAddr::V6("::1".to_string())\n    ];\n\n    for ip in v {\n        show_addr(ip)\n    }\n}\n\nfn show_addr(ip: IpAddr) {\n    println!("{:?}",ip);\n}\n')),(0,l.kt)("h3",{id:"hashmap"},"HashMap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::collections::HashMap;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'// Create.\nlet mut scores = HashMap::new();\n\n// Insert.\nscores.insert(String::from("Blue"), 10);\nscores.insert(String::from("Yellow"), 50);\nscores.entry("Red").or_insert(5);\n\n// Get.\nlet team_name = String::from("Blue");\nlet score: Option<&i32> = scores.get(&team_name);\n\n// Visit\nfor (key, value) in &scores {\n    println!("{}: {}", key, value);\n}\n\n// Transform.\nlet from_list: HashMap<_,_> = some_list.into_iter().collect();\n')),(0,l.kt)("h3",{id:"hashset"},"HashSet"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"insert."),(0,l.kt)("li",{parentName:"ul"},"contains."),(0,l.kt)("li",{parentName:"ul"},"union."),(0,l.kt)("li",{parentName:"ul"},"difference."),(0,l.kt)("li",{parentName:"ul"},"intersection."),(0,l.kt)("li",{parentName:"ul"},"symmetric_difference.")),(0,l.kt)("h2",{id:"error-handling"},"Error Handling"),(0,l.kt)("h3",{id:"result-type"},"Result Type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open("hello.txt");\n\n    let f = match f {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create("hello.txt") {\n                Ok(fc) => fc,\n                Err(e) => panic!("Problem creating the file: {:?}", e),\n            },\n            other_error => panic!("Problem opening the file: {:?}", other_error),\n        },\n    };\n}\n')),(0,l.kt)("h3",{id:"result-type-compositor"},"Result Type Compositor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"or"),": logic or."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"and"),": logic and."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"or_else"),": logic or function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"and_then"),": logic and function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"filter"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"Option")," filter function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"Ok"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Some")," map function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map_or"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"Ok"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Some")," map function with defaults value."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map_or_else"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"Ok"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Some")," map function with defaults function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"map_err"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"Err")," map function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ok_or"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"Option")," -> ",(0,l.kt)("inlineCode",{parentName:"li"},"Result")," with error message."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ok_or_else"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"Option")," -> ",(0,l.kt)("inlineCode",{parentName:"li"},"Result")," with error message function.")),(0,l.kt)("h3",{id:"error-handling-macro"},"Error Handling Macro"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"?")," for ",(0,l.kt)("inlineCode",{parentName:"p"},"Result")," type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fs::File;\nuse std::io;\nuse std::io::Read;\n\nfn open_file() -> Result<File, Box<dyn std::error::Error>> {\n    let mut f = File::open("hello.txt")?;\n    Ok(f)\n}\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut s = String::new();\n    File::open("hello.txt")?.read_to_string(&mut s)?;\n    Ok(s)\n}\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"?")," for ",(0,l.kt)("inlineCode",{parentName:"p"},"Option")," type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn last_char_of_first_line(text: &str) -> Option<char> {\n    text.lines().next()?.chars().last()\n}\n")),(0,l.kt)("h3",{id:"error-trait"},"Error Trait"),(0,l.kt)("h4",{id:"standard-error-trait"},"Standard Error Trait"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&self) -> Option<&(Error + 'static)> { ... }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fs::read_to_string;\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let html = render()?;\n    println!("{}", html);\n    Ok(())\n}\n\nfn render() -> Result<String, Box<dyn Error>> {\n    let file = std::env::var("MARKDOWN")?;\n    let source = read_to_string(file)?;\n    Ok(source)\n}\n')),(0,l.kt)("h4",{id:"custom-error-type"},"Custom Error Type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::error;\nuse std::fmt;\n\n#[derive(Debug)]\nstruct AppError;\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, "An Error Occurred, Please Try Again!")\n    }\n}\n\nimpl error::Error for AppError {\n    fn description(&self) -> &str {\n        "Invalid App"\n    }\n\n    fn source(&self) -> Option<&(dyn error::Error + \'static)> {\n        None\n    }\n\n    fn cause(&self) -> Option<&dyn error::Error> {\n        None\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError)\n}\n\nfn main(){\n    match produce_error() {\n        Err(e) => eprintln!("{}", e),\n        _ => println!("No error"),\n    }\n\n    eprintln!("{:?}", produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n')),(0,l.kt)("h4",{id:"convert-from-standard-error"},"Convert From Standard Error"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from("io"),\n            message: error.to_string(),\n        }\n    }\n}\n\nimpl From<num::ParseIntError> for AppError {\n    fn from(error: num::ParseIntError) -> Self {\n        AppError {\n            kind: String::from("parse"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let mut file = File::open("hello_world.txt")?;\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n\n    let _number: usize;\n    _number = content.parse()?;\n\n    Ok(())\n}\n\n\n// --------------- \u4e0a\u8ff0\u4ee3\u7801\u8fd0\u884c\u540e\u7684\u53ef\u80fd\u8f93\u51fa ---------------\n// 01. \u82e5 hello_world.txt \u6587\u4ef6\u4e0d\u5b58\u5728\n// Error: AppError { kind: "io", message: "No such file or directory" }\n// 02. \u82e5\u7528\u6237\u6ca1\u6709\u76f8\u5173\u7684\u6743\u9650\u8bbf\u95ee hello_world.txt\n// Error: AppError { kind: "io", message: "Permission denied" }\n// 03. \u82e5 hello_world.txt \u5305\u542b\u6709\u975e\u6570\u5b57\u7684\u5185\u5bb9\uff0c\u4f8b\u5982 Hello, world!\n// Error: AppError { kind: "parse", message: "invalid digit found in string" }\n')),(0,l.kt)("h2",{id:"format-print"},"Format Print"),(0,l.kt)("h3",{id:"format-print-macros"},"Format Print Macros"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"print!"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"println!"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"eprint!"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"eprintln!"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"format!"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'println!("Hello");                 // => "Hello"\nprintln!("Hello, {}!", "world");   // => "Hello, world!"\nprintln!("The number is {}", 1);   // => "The number is 1"\nprintln!("{:?}", (3, 4));          // => "(3, 4)"\nprintln!("{value}", value=4);      // => "4"\nprintln!("{} {}", 1, 2);           // => "1 2"\nprintln!("{:04}", 42);             // => "0042" with leading zeros\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s = "hello";\n    println!("{}, world", s);\n    let s1 = format!("{}, world", s);\n    print!("{}", s1);\n    print!("{}\\n", "!");\n}\n')),(0,l.kt)("h3",{id:"format-print-placeholder"},"Format Print Placeholder"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{:?}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{:#?}"),"."),(0,l.kt)("li",{parentName:"ul"},"Index placeholder."),(0,l.kt)("li",{parentName:"ul"},"Alias placeholder.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    println!("{1}{}{0}{}", 1, 2); // => 2112\n    println!("{name} {}", 1, name = 2); // => "2 1"\n    println!("{a} {c} {b}", a = "a", b = \'b\', c = 3); // => "a 3 b"\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Pad placeholder.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // \u4ee5\u4e0b\u5168\u90e8\u8f93\u51fa "Hello x    !"\n    // \u4e3a"x"\u540e\u9762\u586b\u5145\u7a7a\u683c, \u8865\u9f50\u5bbd\u5ea65\n    println!("Hello {:5}!", "x");\n    // \u4f7f\u7528\u53c2\u65705\u6765\u6307\u5b9a\u5bbd\u5ea6\n    println!("Hello {:1$}!", "x", 5);\n    // \u4f7f\u7528x\u4f5c\u4e3a\u5360\u4f4d\u7b26\u8f93\u51fa\u5185\u5bb9, \u540c\u65f6\u4f7f\u75285\u4f5c\u4e3a\u5bbd\u5ea6\n    println!("Hello {1:0$}!", 5, "x");\n    // \u4f7f\u7528\u6709\u540d\u79f0\u7684\u53c2\u6570\u4f5c\u4e3a\u5bbd\u5ea6\n    println!("Hello {:width$}!", "x", width = 5);\n\n    // \u4f7f\u7528\u53c2\u65705\u4e3a\u53c2\u6570x\u6307\u5b9a\u5bbd\u5ea6, \u540c\u65f6\u5728\u7ed3\u5c3e\u8f93\u51fa\u53c2\u65705 => Hello x    !5\n    println!("Hello {:1$}!{}", "x", 5);\n\n    // \u5bbd\u5ea6\u662f5 => Hello     5!\n    println!("Hello {:5}!", 5);\n    // \u663e\u5f0f\u7684\u8f93\u51fa\u6b63\u53f7 => Hello +5!\n    println!("Hello {:+}!", 5);\n    // \u5bbd\u5ea65, \u4f7f\u75280\u8fdb\u884c\u586b\u5145 => Hello 00005!\n    println!("Hello {:05}!", 5);\n    // \u8d1f\u53f7\u4e5f\u8981\u5360\u7528\u4e00\u4f4d\u5bbd\u5ea6 => Hello -0005!\n    println!("Hello {:05}!", -5);\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Alignment placeholder.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // \u4ee5\u4e0b\u5168\u90e8\u90fd\u4f1a\u8865\u9f505\u4e2a\u5b57\u7b26\u7684\u957f\u5ea6\n    // \u5de6\u5bf9\u9f50 => Hello x    !\n    println!("Hello {:<5}!", "x");\n    // \u53f3\u5bf9\u9f50 => Hello     x\n    println!("Hello {:>5}!", "x");\n    // \u5c45\u4e2d\u5bf9\u9f50 => Hello   x  !\n    println!("Hello {:^5}!", "x");\n\n    // \u5bf9\u9f50\u5e76\u4f7f\u7528\u6307\u5b9a\u7b26\u53f7\u586b\u5145 => Hello x&&&&!\n    // \u6307\u5b9a\u7b26\u53f7\u586b\u5145\u7684\u524d\u63d0\u6761\u4ef6\u662f\u5fc5\u987b\u6709\u5bf9\u9f50\u5b57\u7b26\n    println!("Hello {:&<5}!", "x");\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Precision placeholder.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let v = 3.1415926;\n    // \u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d => 3.14\n    println!("{:.2}", v);\n    // \u5e26\u7b26\u53f7\u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d => +3.14\n    println!("{:+.2}", v);\n    // \u4e0d\u5e26\u5c0f\u6570 => 3\n    println!("{:.0}", v);\n    // \u901a\u8fc7\u53c2\u6570\u6765\u8bbe\u5b9a\u7cbe\u5ea6 => 3.1416, \u76f8\u5f53\u4e8e{:.4}\n    println!("{:.1$}", v, 4);\n\n    let s = "hello I\'m some one";\n    // \u4fdd\u7559\u5b57\u7b26\u4e32\u524d\u4e09\u4e2a\u5b57\u7b26 => hel\n    println!("{:.3}", s);\n    // {:.*} \u63a5\u6536\u4e24\u4e2a\u53c2\u6570, \u7b2c\u4e00\u4e2a\u662f\u7cbe\u5ea6, \u7b2c\u4e8c\u4e2a\u662f\u88ab\u683c\u5f0f\u5316\u7684\u503c => Hello abc!\n    println!("Hello {:.*}!", 3, "abcdefg");\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Radix placeholder: ",(0,l.kt)("inlineCode",{parentName:"li"},"boxXeE"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fmt::Binary")," trait."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fmt::Octal")," trait."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fmt::LowerHex")," trait."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fmt::UpperHex")," trait."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fmt::LowerExp")," trait."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fmt::UpperExp")," trait.")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // \u4e8c\u8fdb\u5236 => 0b11011!\n    println!("{:#b}!", 27);\n    // \u516b\u8fdb\u5236 => 0o33!\n    println!("{:#o}!", 27);\n    // \u5341\u8fdb\u5236 => 27!\n    println!("{}!", 27);\n    // \u5c0f\u5199\u5341\u516d\u8fdb\u5236 => 0x1b!\n    println!("{:#x}!", 27);\n    // \u5927\u5199\u5341\u516d\u8fdb\u5236 => 0x1B!\n    println!("{:#X}!", 27);\n\n    // \u4e0d\u5e26\u524d\u7f00\u7684\u5341\u516d\u8fdb\u5236 => 1b!\n    println!("{:x}!", 27);\n\n    // \u4f7f\u75280\u586b\u5145\u4e8c\u8fdb\u5236, \u5bbd\u5ea6\u4e3a10 => 0b00011011!\n    println!("{:#010b}!", 27);\n\n    println!("{:2e}", 1000000000); // => 1e9\n    println!("{:2E}", 1000000000); // => 1E9\n}\n')),(0,l.kt)("h3",{id:"debug-trait"},"Debug Trait"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: u8\n}\n\nfn main() {\n    let i = 3.1415926;\n    let s = String::from("hello");\n    let v = vec![1, 2, 3];\n    let p = Person{name: "name".to_string(), age: 18};\n    println!("{:?}, {:?}, {:?}, {:?}", i, s, v, p);\n}\n')),(0,l.kt)("h3",{id:"display-trait"},"Display Trait"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fmt;\n\nstruct Person {\n    name: String,\n    age: u8,\n}\n\nimpl fmt::Display for Person {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            "My name is {}, {} year old.",\n            self.name, self.age\n        )\n    }\n}\n\nfn main() {\n    let p = Person {\n        name: "name".to_string(),\n        age: 18,\n    };\n\n    println!("{}", p);\n}\n')),(0,l.kt)("h2",{id:"lifetime"},"Lifetime"),(0,l.kt)("p",null,"\u663e\u5f0f\u5730\u4f7f\u7528\u751f\u547d\u5468\u671f, \u53ef\u4ee5\u8ba9\u7f16\u8bd1\u5668\u6b63\u786e\u5730\u8ba4\u8bc6\u5230\u591a\u4e2a",(0,l.kt)("strong",{parentName:"p"},"\u5f15\u7528"),"\u4e4b\u95f4\u7684\u5173\u7cfb."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"&i32        // \u4e00\u4e2a\u5f15\u7528\n&'a i32     // \u5177\u6709\u663e\u5f0f\u751f\u547d\u5468\u671f\u7684\u5f15\u7528\n&'a mut i32 // \u5177\u6709\u663e\u5f0f\u751f\u547d\u5468\u671f\u7684\u53ef\u53d8\u5f15\u7528\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"struct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n")),(0,l.kt)("h3",{id:"function-lifetime"},"Function Lifetime"),(0,l.kt)("p",null,"\u51fd\u6570\u6216\u8005\u65b9\u6cd5\u4e2d,\n\u53c2\u6570\u7684\u751f\u547d\u5468\u671f\u88ab\u79f0\u4e3a",(0,l.kt)("inlineCode",{parentName:"p"},"\u8f93\u5165\u751f\u547d\u5468\u671f"),",\n\u8fd4\u56de\u503c\u7684\u751f\u547d\u5468\u671f\u88ab\u79f0\u4e3a",(0,l.kt)("inlineCode",{parentName:"p"},"\u8f93\u51fa\u751f\u547d\u5468\u671f"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u6bcf\u4e00\u4e2a\u5f15\u7528\u53c2\u6570\u90fd\u4f1a\u83b7\u5f97\u72ec\u81ea\u7684\u751f\u547d\u5468\u671f:\n",(0,l.kt)("inlineCode",{parentName:"li"},"fn foo<'a, 'b>(x: &'a i32, y: &'b i32)"),"."),(0,l.kt)("li",{parentName:"ul"},"\u82e5\u53ea\u6709\u4e00\u4e2a\u8f93\u5165\u751f\u547d\u5468\u671f, \u5219\u8be5\u751f\u547d\u5468\u671f\u4f1a\u88ab\u8d4b\u7ed9\u6240\u6709\u8f93\u51fa\u751f\u547d\u5468\u671f."),(0,l.kt)("li",{parentName:"ul"},"\u82e5\u5b58\u5728\u591a\u4e2a\u8f93\u5165\u751f\u547d\u5468\u671f, \u4e14\u5176\u4e2d\u4e00\u4e2a\u662f",(0,l.kt)("inlineCode",{parentName:"li"},"&self"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"&mut self"),",\n\u5219",(0,l.kt)("inlineCode",{parentName:"li"},"&self"),"\u751f\u547d\u5468\u671f\u88ab\u8d4b\u7ed9\u6240\u6709\u8f93\u51fa\u751f\u547d\u5468\u671f (\u9664\u975e\u663e\u5f0f\u5730\u58f0\u660e\u8f93\u51fa\u751f\u547d\u5468\u671f).")),(0,l.kt)("h3",{id:"static-lifetime"},"Static Lifetime"),(0,l.kt)("p",null,"\u751f\u547d\u5468\u671f",(0,l.kt)("inlineCode",{parentName:"p"},"'static"),"\u8868\u793a\u6301\u7eed\u6574\u4e2a\u7a0b\u5e8f,\n\u4f8b\u5982\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\u548c\u7279\u5f81\u5bf9\u8c61."),(0,l.kt)("h3",{id:"lifetime-constraint"},"Lifetime Constraint"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"'a: 'b"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"'a")," \u751f\u547d\u5468\u671f\u66f4\u957f."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"T: 'a"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"T")," \u751f\u547d\u5468\u671f\u66f4\u957f.")),(0,l.kt)("h2",{id:"closure"},"Closure"),(0,l.kt)("h3",{id:"function-parameter-closure"},"Function Parameter Closure"),(0,l.kt)("p",null,"\u6539\u53d8\u6355\u83b7\u53d8\u91cf\u7684\u6240\u6709\u6743 (FnOnce):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn fn_once<F>(func: F)\nwhere\n    F: FnOnce(usize) -> bool + Copy,\n{\n    println!("{}", func(3));\n    println!("{}", func(4));\n}\n\nfn main() {\n    let x = vec![1, 2, 3];\n    fn_once(|z|{z == x.len()})\n}\n')),(0,l.kt)("p",null,"\u53ef\u53d8\u501f\u7528\u6355\u83b7 (FnMut):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut s = String::new();\n\n    let update_string =  |str| s.push_str(str);\n\n    exec(update_string);\n\n    println!("{:?}",s);\n}\n\nfn exec<\'a, F: FnMut(&\'a str)>(mut f: F)  {\n    f("hello")\n}\n')),(0,l.kt)("p",null,"\u4e0d\u53ef\u53d8\u501f\u7528\u6355\u83b7 (Fn):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s = "hello, ".to_string();\n\n    let update_string =  |str| println!("{},{}",s,str);\n\n    exec(update_string);\n\n    println!("{:?}",s);\n}\n\nfn exec<\'a, F: Fn(String) -> ()>(f: F)  {\n    f("world".to_string())\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u6240\u6709\u95ed\u5305\u90fd\u81ea\u52a8\u5b9e\u73b0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"li"},"FnOnce")," \u7279\u5f81, \u56e0\u6b64\u4efb\u4f55\u4e00\u4e2a\u95ed\u5305\u90fd\u81f3\u5c11\u53ef\u4ee5\u88ab\u8c03\u7528\u4e00\u6b21."),(0,l.kt)("li",{parentName:"ul"},"\u6ca1\u6709\u79fb\u51fa\u6240\u6355\u83b7\u53d8\u91cf\u7684\u6240\u6709\u6743\u7684\u95ed\u5305\u81ea\u52a8\u5b9e\u73b0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"li"},"FnMut")," \u7279\u5f81."),(0,l.kt)("li",{parentName:"ul"},"\u4e0d\u9700\u8981\u5bf9\u6355\u83b7\u53d8\u91cf\u8fdb\u884c\u6539\u53d8\u7684\u95ed\u5305\u81ea\u52a8\u5b9e\u73b0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"li"},"Fn")," \u7279\u5f81.")),(0,l.kt)("h3",{id:"function-return-closure"},"Function Return Closure"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn factory() -> impl Fn(i32) -> i32 {\n    let num = 5;\n    |x| x + num\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {\n    let num = 5;\n\n    if x > 1{\n        Box::new(move |x| x + num)\n    } else {\n        Box::new(move |x| x - num)\n    }\n}\n")),(0,l.kt)("h2",{id:"iterator"},"Iterator"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'let arr = [1, 2, 3];\n\nfor v in arr.into_iter() {\n    println!("{}", v);\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let arr = [1, 2, 3];\n    let mut arr_iter = arr.into_iter();\n\n    assert_eq!(arr_iter.next(), Some(1));\n    assert_eq!(arr_iter.next(), Some(2));\n    assert_eq!(arr_iter.next(), Some(3));\n    assert_eq!(arr_iter.next(), None);\n}\n")),(0,l.kt)("h3",{id:"iterator-trait"},"Iterator Trait"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n\nimpl<I: Iterator> IntoIterator for I {\n    type Item = I::Item;\n    type IntoIter = I;\n\n    #[inline]\n    fn into_iter(self) -> I {\n        self\n    }\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"iter"),": \u4e0d\u53ef\u53d8\u501f\u7528."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"iter_mut"),": \u53ef\u53d8\u501f\u7528."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"into_iter"),": \u6539\u53d8\u6240\u6709\u6743.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn iter(&self) -> Iter             // Iter implements Iterator<Item = &U>\nfn iter_mut(&mut self) -> IterMut  // IterMut implements Iterator<Item = &mut U>\nfn into_iter(self) -> IntoIter     // IntoIter implements Iterator<Item = U>\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let values = vec![1, 2, 3];\n\n    for v in values.into_iter() {\n        println!("{}", v)\n    }\n\n    // \u4e0b\u9762\u7684\u4ee3\u7801\u5c06\u62a5\u9519.\n    // println!("{:?}",values);\n\n    let values = vec![1, 2, 3];\n    let _values_iter = values.iter();\n\n    // \u4e0d\u4f1a\u62a5\u9519.\n    println!("{:?}", values);\n\n    let mut values = vec![1, 2, 3];\n    // \u5bf9 values \u4e2d\u7684\u5143\u7d20\u8fdb\u884c\u53ef\u53d8\u501f\u7528.\n    let mut values_iter_mut = values.iter_mut();\n\n    // \u53d6\u51fa\u7b2c\u4e00\u4e2a\u5143\u7d20, \u5e76\u4fee\u6539\u4e3a0.\n    if let Some(v) = values_iter_mut.next() {\n        *v = 0;\n    }\n\n    // \u8f93\u51fa [0, 2, 3].\n    println!("{:?}", values);\n}\n')),(0,l.kt)("p",null,"Implement iterator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"struct Counter {\n    count: u32,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\n\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.count < 5 {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let mut counter = Counter::new();\n    assert_eq!(counter.next(), Some(1));\n    assert_eq!(counter.next(), Some(2));\n    assert_eq!(counter.next(), Some(3));\n    assert_eq!(counter.next(), Some(4));\n    assert_eq!(counter.next(), Some(5));\n    assert_eq!(counter.next(), None);\n\n    let sum: u32 = Counter::new()\n        .zip(Counter::new().skip(1))\n        .map(|(a, b)| a * b)\n        .filter(|x| x % 3 == 0)\n        .sum();\n    assert_eq!(18, sum);\n}\n")),(0,l.kt)("h3",{id:"adapter-methods"},"Adapter Methods"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u6d88\u8d39\u6027\u9002\u914d\u5668: \u83b7\u53d6\u8fed\u4ee3\u5668\u7684\u6240\u6709\u6743, \u5e76\u6d88\u8017\u8fed\u4ee3\u5668\u4e2d\u6240\u6709\u5143\u7d20.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"collect::<T>()"),"."),(0,l.kt)("li",{parentName:"ul"},"fold."),(0,l.kt)("li",{parentName:"ul"},"partition."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sum::<T>()"),"."))),(0,l.kt)("li",{parentName:"ul"},"\u8fed\u4ee3\u6027\u9002\u914d\u5668: \u60f0\u6027\u65b9\u6cd5 (Lazy Iterator)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"enumerate."),(0,l.kt)("li",{parentName:"ul"},"filter."),(0,l.kt)("li",{parentName:"ul"},"filter_map."),(0,l.kt)("li",{parentName:"ul"},"map."),(0,l.kt)("li",{parentName:"ul"},"take_while."),(0,l.kt)("li",{parentName:"ul"},"zip."))),(0,l.kt)("li",{parentName:"ul"},"Ordinary iterator methods:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Iterator::any."),(0,l.kt)("li",{parentName:"ul"},"Iterator::find.")))),(0,l.kt)("p",null,"More adapter methods see ",(0,l.kt)("inlineCode",{parentName:"p"},"Iterator")," trait\n",(0,l.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html"},"documentation"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    let total: i32 = v1_iter.sum();\n    assert_eq!(total, 6);\n\n    // v1_iter \u662f\u501f\u7528\u4e86 v1, \u56e0\u6b64 v1 \u53ef\u4ee5\u7167\u5e38\u4f7f\u7528.\n    println!("{:?}",v1);\n\n    // \u4ee5\u4e0b\u4ee3\u7801\u4f1a\u62a5\u9519, \u56e0\u4e3a `sum` \u62ff\u5230\u4e86\u8fed\u4ee3\u5668 `v1_iter` \u7684\u6240\u6709\u6743.\n    // println!("{:?}",v1_iter);\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let v1: Vec<i32> = vec![1, 2, 3];\n    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n    assert_eq!(v2, vec![2, 3, 4]);\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\nfn main() {\n    let names = ["name1", "name2"];\n    let ages = [18, 18];\n    let folks: HashMap<_, _> = names.into_iter().zip(ages.into_iter()).collect();\n    println!("{:?}",folks);\n}\n')),(0,l.kt)("h2",{id:"smart-pointer"},"Smart Pointer"),(0,l.kt)("h3",{id:"box-type"},"Box Type"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Box<T>")," \u5c06\u4e00\u4e2a\u503c\u5206\u914d\u5230\u5806\u4e0a, \u7136\u540e\u5728\u6808\u4e0a\u4fdd\u7559\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u5806\u4e0a\u6570\u636e:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u5b9e\u73b0\u8f6c\u79fb\u6240\u6709\u6743\u65f6\u7684\u96f6\u62f7\u8d1d."),(0,l.kt)("li",{parentName:"ul"},"\u5c06\u4e0d\u5b9a\u957f\u7c7b\u578b\u8f6c\u6362\u4e3a\u5b9a\u957f\u7c7b\u578b.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // \u5728\u6808\u4e0a\u521b\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a 1000 \u7684\u6570\u7ec4.\n    let arr = [0;1000];\n    // \u5c06 arr \u6240\u6709\u6743\u8f6c\u79fb arr1, \u7531\u4e8e `arr` \u5206\u914d\u5728\u6808\u4e0a, \u56e0\u6b64\u76f4\u63a5\u91cd\u65b0\u6df1\u62f7\u8d1d\u4e86\u4e00\u4efd\u6570\u636e.\n    let arr1 = arr;\n\n    // arr \u548c arr1 \u90fd\u62e5\u6709\u5404\u81ea\u7684\u6808\u4e0a\u6570\u7ec4, \u56e0\u6b64\u4e0d\u4f1a\u62a5\u9519.\n    println!("{:?}", arr.len());\n    println!("{:?}", arr1.len());\n\n    // \u5728\u5806\u4e0a\u521b\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a 1000 \u7684\u6570\u7ec4, \u7136\u540e\u4f7f\u7528\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u5b83.\n    let arr = Box::new([0;1000]);\n    // \u5c06\u5806\u4e0a\u6570\u7ec4\u7684\u6240\u6709\u6743\u8f6c\u79fb\u7ed9 arr1, \u7531\u4e8e\u6570\u636e\u5728\u5806\u4e0a, \u56e0\u6b64\u4ec5\u4ec5\u62f7\u8d1d\u4e86\u667a\u80fd\u6307\u9488\u7684\u7ed3\u6784\u4f53, \u5e95\u5c42\u6570\u636e\u5e76\u6ca1\u6709\u88ab\u62f7\u8d1d.\n    // \u6240\u6709\u6743\u987a\u5229\u8f6c\u79fb\u7ed9 arr1, arr \u4e0d\u518d\u62e5\u6709\u6240\u6709\u6743.\n    let arr1 = arr;\n    println!("{:?}", arr1.len());\n    // \u7531\u4e8e arr \u4e0d\u518d\u62e5\u6709\u5e95\u5c42\u6570\u7ec4\u7684\u6240\u6709\u6743, \u56e0\u6b64\u4e0b\u9762\u4ee3\u7801\u5c06\u62a5\u9519.\n    // println!("{:?}", arr.len());\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n")),(0,l.kt)("h3",{id:"deref-trait"},"Deref Trait"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"&smart_pointer"),"\n=> ",(0,l.kt)("inlineCode",{parentName:"li"},"smart_pointer.defer()"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*smart_pointer"),"\n=> ",(0,l.kt)("inlineCode",{parentName:"li"},"*(smart_pointer.defer())"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"smart_pointer.method()"),"\n=> ",(0,l.kt)("inlineCode",{parentName:"li"},"(&smart_pointer).method()"),"\n=> ",(0,l.kt)("inlineCode",{parentName:"li"},"(smart_pointer.defer()).method()"),"."),(0,l.kt)("li",{parentName:"ul"},"When ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Deref<Target=U>"),", then ",(0,l.kt)("inlineCode",{parentName:"li"},"&T => &U"),"."),(0,l.kt)("li",{parentName:"ul"},"When ",(0,l.kt)("inlineCode",{parentName:"li"},"T: DerefMut<Target=U>"),", then ",(0,l.kt)("inlineCode",{parentName:"li"},"&mut T => &mut U"),"."),(0,l.kt)("li",{parentName:"ul"},"When ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Deref<Target=U>"),", then ",(0,l.kt)("inlineCode",{parentName:"li"},"&mut T => &U"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use core::ops::{self};\nuse crate::str::{self, from_boxed_utf8_unchecked};\nuse crate::vec::Vec;\n\nstruct String {\n    vec: Vec<u8>,\n}\n\nimpl ops::Deref for String {\n    type Target = str;\n\n    fn deref(&self) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> ops::Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nfn main() {\n    let x = MyBox::new(5);\n    assert_eq!(5, *x);\n    // => *(x.deref())\n    // => *(&x.0)\n    // => x.0\n\n    let s = MyBox::new(String::from("hello world"));\n    display(&s);\n    // => &MyBox\n    // => MyBox.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n\n    let hello_world = MyBox::new(String::from("hello, world"));\n    let s1: &str = &hello_world;\n    // => &MyBox<String>\n    // => MyBox<String>.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n    let s2: String = hello_world.to_string();\n    // => MyBox<String>.to_string()\n    // => (&MyBox<String>).to_string()\n    // => (MyBox<String>.defer()).to_string()\n    // => (&String).to_string()\n    let ptr: *const u8 = hello_world.as_ptr();\n    // => MyBox<String>.as_ptr()\n    // => (&MyBox<String>).as_ptr()\n    // => (MyBox<String>.defer()).as_ptr()\n    // => (&String).as_ptr()\n    // => (String.defer()).as_ptr()\n    // => (&str).as_ptr()\n}\n\nfn display(s: &str) {\n    println!("{}", s);\n}\n')),(0,l.kt)("h3",{id:"drop-trait"},"Drop Trait"),(0,l.kt)("p",null,"Drop order:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u53d8\u91cf\u7ea7\u522b, \u6309\u7167\u9006\u5e8f\u7684\u65b9\u5f0f, \u5148\u521b\u5efa\u7684\u53d8\u91cf\u540e drop."),(0,l.kt)("li",{parentName:"ul"},"\u7ed3\u6784\u4f53\u5185\u90e8, \u6309\u7167\u987a\u5e8f\u7684\u65b9\u5f0f, \u7ed3\u6784\u4f53\u4e2d\u7684\u5b57\u6bb5\u6309\u7167\u5b9a\u4e49\u4e2d\u7684\u987a\u5e8f\u4f9d\u6b21 drop.")),(0,l.kt)("h3",{id:"reference-counting-type"},"Reference Counting Type"),(0,l.kt)("p",null,"\u901a\u8fc7\u5f15\u7528\u8ba1\u6570\u7684\u65b9\u5f0f, \u5141\u8bb8\u4e00\u4e2a\u6570\u636e\u8d44\u6e90\u5728\u540c\u4e00\u65f6\u523b\u62e5\u6709\u591a\u4e2a\u6240\u6709\u8005."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(String::from("hello, world"));\n    let b = Rc::clone(&a); // \u590d\u5236\u4e86\u667a\u80fd\u6307\u9488\u5e76\u589e\u52a0\u4e86\u5f15\u7528\u8ba1\u6570, \u5e76\u6ca1\u6709\u514b\u9686\u5e95\u5c42\u6570\u636e.\n    assert_eq!(2, Rc::strong_count(&a));\n    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Rc"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Arc")," \u662f\u4e0d\u53ef\u53d8\u5f15\u7528, \u65e0\u6cd5\u4fee\u6539\u5b83\u6307\u5411\u7684\u503c."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Rc<T>")," \u662f\u4e00\u4e2a\u667a\u80fd\u6307\u9488, \u5b9e\u73b0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"li"},"Deref")," \u7279\u5f81, \u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"li"},"T"),"."),(0,l.kt)("li",{parentName:"ul"},"\u4e00\u65e6\u6700\u540e\u4e00\u4e2a\u62e5\u6709\u8005\u6d88\u5931, \u5219\u8d44\u6e90\u4f1a\u81ea\u52a8\u88ab\u56de\u6536."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Arc"),": Atomic reference counting.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let s = Arc::new(String::from("Multiple threads walker"));\n\n    for _ in 0..10 {\n        let s = Arc::clone(&s);\n        let handle = thread::spawn(move || {\n           println!("{}", s)\n        });\n    }\n}\n')),(0,l.kt)("h3",{id:"cell-and-refcell-type"},"Cell and RefCell Type"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Cell")," for copyable type."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::cell::Cell;\n\nfn main() {\n    let c = Cell::new("abc");\n    let one = c.get();\n    c.set("xyz");\n    let two = c.get();\n    println!("{}, {}", one, two); // abc, xyz\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::cell::Cell;\n\nfn retain_even(nums: &mut Vec<i32>) {\n    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..])\n        .as_slice_of_cells();\n\n    let mut i = 0;\n\n    for num in slice.iter().filter(|num| is_even(num.get())) {\n        slice[i].set(num.get());\n        i += 1;\n    }\n\n    nums.truncate(i);\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"RefCell")," for borrowing reference:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u5b9e\u73b0\u5185\u90e8\u53ef\u53d8\u6027: \u4e0d\u53ef\u53d8\u503c\u7684\u53ef\u53d8\u501f\u7528.\n",(0,l.kt)("inlineCode",{parentName:"li"},"imut_self.refcell_member.borrow_mut().changeMember()"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Rc<RefCell<T>>"),": \u5b9e\u73b0\u591a\u4e2a\u53ef\u53d8\u6570\u636e\u6240\u6709\u8005."),(0,l.kt)("li",{parentName:"ul"},"\u5b9e\u73b0\u7f16\u8bd1\u671f",(0,l.kt)("strong",{parentName:"li"},"\u53ef\u53d8\u501f\u7528"),"\u4e0e",(0,l.kt)("strong",{parentName:"li"},"\u4e0d\u53ef\u53d8\u501f\u7528"),"\u5171\u5b58,\n\u4f46\u4f1a\u5f15\u8d77\u8fd0\u884c\u65f6 ",(0,l.kt)("inlineCode",{parentName:"li"},"panic"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::cell::RefCell;\n\nfn main() {\n    let s = RefCell::new(String::from("hello, world"));\n    let s1 = s.borrow();\n    let s2 = s.borrow_mut();\n\n    println!("{}, {}", s1, s2);\n}\n')),(0,l.kt)("p",null,"\u901a\u8fc7\u5305\u88f9\u4e00\u5c42 ",(0,l.kt)("inlineCode",{parentName:"p"},"RefCell"),",\n\u5c06\u4e0d\u53ef\u53d8\u501f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"&self")," \u7684\u6210\u5458\u6210\u4e3a\u4e00\u4e2a\u53ef\u53d8\u503c,\n\u7136\u540e\u5b9e\u73b0\u4fee\u6539:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::cell::RefCell;\n\npub trait Messenger {\n    fn send(&self, msg: String);\n}\n\npub struct MsgQueue {\n    msg_cache: RefCell<Vec<String>>,\n}\n\nimpl Messenger for MsgQueue {\n    fn send(&self, msg: String) {\n        self.msg_cache.borrow_mut().push(msg)\n    }\n}\n\nfn main() {\n    let mq = MsgQueue {\n        msg_cache: RefCell::new(Vec::new()),\n    };\n    mq.send("hello, world".to_string());\n}\n')),(0,l.kt)("h3",{id:"circle-reference"},"Circle Reference"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Weak")," \u901a\u8fc7 ",(0,l.kt)("inlineCode",{parentName:"p"},"use std::rc::Weak")," \u5f15\u5165, \u5177\u6709\u4ee5\u4e0b\u7279\u70b9:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u53ef\u8bbf\u95ee, \u4f46\u6ca1\u6709\u6240\u6709\u6743, \u4e0d\u589e\u52a0\u5f15\u7528\u8ba1\u6570, \u4e0d\u5f71\u54cd drop."),(0,l.kt)("li",{parentName:"ul"},"\u53ef\u7531 ",(0,l.kt)("inlineCode",{parentName:"li"},"Rc<T>")," \u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"li"},"downgrade")," \u65b9\u6cd5\u8f6c\u6362\u6210 ",(0,l.kt)("inlineCode",{parentName:"li"},"Weak<T>"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Weak<T>")," \u53ef\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"li"},"upgrade")," \u65b9\u6cd5\u8f6c\u6362\u6210 ",(0,l.kt)("inlineCode",{parentName:"li"},"Option<Rc<T>>"),",\n\u5982\u679c\u8d44\u6e90\u5df2\u7ecf\u88ab\u91ca\u653e, \u5219 ",(0,l.kt)("inlineCode",{parentName:"li"},"Option")," \u7684\u503c\u662f ",(0,l.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,l.kt)("li",{parentName:"ul"},"\u5e38\u7528\u4e8e\u89e3\u51b3\u5faa\u73af\u5f15\u7528\u7684\u95ee\u9898.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            "branch strong = {}, weak = {}",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            "leaf strong = {}, weak = {}",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n')),(0,l.kt)("h2",{id:"phantom-type"},"Phantom Type"),(0,l.kt)("p",null,"\u865a\u7c7b\u578b/\u5e7d\u7075\u7c7b\u578b\u53c2\u6570\u662f\u4e00\u79cd\u5728",(0,l.kt)("strong",{parentName:"p"},"\u8fd0\u884c\u65f6\u4e0d\u51fa\u73b0"),",\n\u4ec5\u8fdb\u884c",(0,l.kt)("strong",{parentName:"p"},"\u9759\u6001\u7f16\u8bd1\u68c0\u67e5"),"\u7684\u7c7b\u578b\u53c2\u6570."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::marker::PhantomData;\n\nstruct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: PhantomData<&'a T>,\n}\n\nstruct Vec<T> {\n    data: *const T,\n    len: usize,\n    cap: usize,\n    _marker: PhantomData<T>,\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::marker::PhantomData;\n\n#[derive(PartialEq)]\nstruct PhantomTuple<A, B>(A, PhantomData<B>);\n\n#[derive(PartialEq)]\nstruct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> }\n\nfn main() {\n    let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);\n    let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData);\n\n    let _struct1: PhantomStruct<char, f32> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n    let _struct2: PhantomStruct<char, f64> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef\uff01\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u8fd9\u4e9b\u503c\u4e0d\u80fd\u591f\u6bd4\u8f83\uff1a\n    println!(\"_tuple1 == _tuple2 yields: {}\",\n              _tuple1 == _tuple2);\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef\uff01\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u8fd9\u4e9b\u503c\u4e0d\u80fd\u591f\u6bd4\u8f83\uff1a\n    println!(\"_struct1 == _struct2 yields: {}\",\n              _struct1 == _struct2);\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::ops::Add;\nuse std::marker::PhantomData;\n\n#[derive(Debug, Clone, Copy)]\nenum Inch {}\n#[derive(Debug, Clone, Copy)]\nenum Mm {}\n\n#[derive(Debug, Clone, Copy)]\nstruct Length<Unit>(f64, PhantomData<Unit>);\n\nimpl<Unit> Add for Length<Unit> {\n     type Output = Length<Unit>;\n\n    fn add(self, rhs: Length<Unit>) -> Length<Unit> {\n        Length(self.0 + rhs.0, PhantomData)\n    }\n}\n\nfn main() {\n    let one_foot:  Length<Inch> = Length(12.0, PhantomData);\n    let one_meter: Length<Mm>   = Length(1000.0, PhantomData);\n\n    let two_feet = one_foot + one_foot;\n    let two_meters = one_meter + one_meter;\n\n    println!("one foot + one_foot = {:?} in", two_feet.0);\n    println!("one meter + one_meter = {:?} mm", two_meters.0);\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef: \u7c7b\u578b\u4e0d\u5339\u914d.\n    let compile_error = one_foot + one_meter;\n}\n')),(0,l.kt)("h2",{id:"concurrent-programming"},"Concurrent Programming"),(0,l.kt)("h3",{id:"concurrency-programming-model"},"Concurrency Programming Model"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Pros"),(0,l.kt)("th",{parentName:"tr",align:null},"Cons"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"OS Thread"),(0,l.kt)("td",{parentName:"tr",align:null},"simple, native model"),(0,l.kt)("td",{parentName:"tr",align:null},"consistent and context switch overhead")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Event Driven"),(0,l.kt)("td",{parentName:"tr",align:null},"perf model"),(0,l.kt)("td",{parentName:"tr",align:null},"non-liner logic, callback hell")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Coroutines"),(0,l.kt)("td",{parentName:"tr",align:null},"perf model"),(0,l.kt)("td",{parentName:"tr",align:null},"non-system abstraction")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Actor"),(0,l.kt)("td",{parentName:"tr",align:null},"distributed model"),(0,l.kt)("td",{parentName:"tr",align:null},"complex flow control and retry logic")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Async/Await"),(0,l.kt)("td",{parentName:"tr",align:null},"perf, native model"),(0,l.kt)("td",{parentName:"tr",align:null},"complex internal logic")))),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"OS Threads")," for CPU intensive task (parallel computing),\n",(0,l.kt)("inlineCode",{parentName:"p"},"Async/Await")," for I/O intensive task (blocking I/O)."),(0,l.kt)("h3",{id:"threads"},"Threads"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..5 {\n            println!("hi number {} from the spawned thread!", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!("hi number {} from the main thread!", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n')),(0,l.kt)("h3",{id:"barrier"},"Barrier"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::{Arc, Barrier};\nuse std::thread;\n\nfn main() {\n    let mut handles = Vec::with_capacity(6);\n    let barrier = Arc::new(Barrier::new(6));\n\n    for _ in 0..6 {\n        let b = barrier.clone();\n        handles.push(thread::spawn(move|| {\n            println!("before wait");\n            b.wait();\n            println!("after wait");\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n')),(0,l.kt)("h3",{id:"condition-variables-and-mutex"},"Condition Variables and Mutex"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::thread;\nuse std::sync::{Arc, Mutex, Condvar};\n\nfn main() {\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair2 = pair.clone();\n\n    thread::spawn(move|| {\n        let &(ref lock, ref cvar) = &*pair2;\n        let mut started = lock.lock().unwrap();\n        println!("changing started");\n        *started = true;\n        cvar.notify_one();\n    });\n\n    let &(ref lock, ref cvar) = &*pair;\n    let mut started = lock.lock().unwrap();\n    while !*started {\n        started = cvar.wait(started).unwrap();\n    }\n\n    println!("started changed");\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!("Result: {}", *counter.lock().unwrap());\n}\n')),(0,l.kt)("p",null,"Read and write mutex:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u540c\u65f6\u5141\u8bb8\u591a\u4e2a\u8bfb, \u4f46\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2a\u5199."),(0,l.kt)("li",{parentName:"ul"},"\u8bfb\u548c\u5199\u4e0d\u80fd\u540c\u65f6\u5b58\u5728."),(0,l.kt)("li",{parentName:"ul"},"\u53ef\u4ee5\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"li"},"read"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"try_read"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"write"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"try_write"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::sync::RwLock;\n\nfn main() {\n    let lock = RwLock::new(5);\n\n    // \u540c\u4e00\u65f6\u95f4\u5141\u8bb8\u591a\u4e2a\u8bfb.\n    {\n        let r1 = lock.read().unwrap();\n        let r2 = lock.read().unwrap();\n        assert_eq!(*r1, 5);\n        assert_eq!(*r2, 5);\n    } // Drop.\n\n    // \u540c\u4e00\u65f6\u95f4\u53ea\u5141\u8bb8\u4e00\u4e2a\u5199.\n    {\n        let mut w = lock.write().unwrap();\n        *w += 1;\n        assert_eq!(*w, 6);\n    } // Drop.\n}\n")),(0,l.kt)("h3",{id:"threads-communication"},"Threads Communication"),(0,l.kt)("p",null,"Message channel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        tx.send(1).unwrap();\n    });\n\n    // Block.\n    println!("receive {}", rx.recv().unwrap());\n}\n')),(0,l.kt)("p",null,"Sync channel with message buffer:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    // Sync channel with 3 length buffer.\n    let (tx, rx)= mpsc::sync_channel(3);\n\n    let handle = thread::spawn(move || {\n        println!("\u53d1\u9001\u4e4b\u524d");\n        tx.send(1).unwrap();\n        println!("\u53d1\u9001\u4e4b\u540e");\n    });\n\n    println!("\u7761\u7720\u4e4b\u524d");\n    thread::sleep(Duration::from_secs(3));\n    println!("\u7761\u7720\u4e4b\u540e");\n\n    println!("receive {}", rx.recv().unwrap());\n    handle.join().unwrap();\n}\n')),(0,l.kt)("p",null,"Send message via ",(0,l.kt)("inlineCode",{parentName:"p"},"for")," loop:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let values = vec![\n            String::from("hi"),\n            String::from("from"),\n            String::from("the"),\n            String::from("thread"),\n        ];\n\n        for value in values {\n            tx.send(value).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!("Got: {}", received);\n    }\n}\n')),(0,l.kt)("p",null,"Multiple producers:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let tx1 = tx.clone();\n\n    thread::spawn(move || {\n        tx.send(String::from("hi from raw tx")).unwrap();\n    });\n\n    thread::spawn(move || {\n        tx1.send(String::from("hi from cloned tx")).unwrap();\n    });\n\n    for received in rx {\n        println!("Got: {}", received);\n    }\n}\n')),(0,l.kt)("p",null,"Multiple type message:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc::{self, Receiver, Sender};\n\nenum Fruit {\n    Apple(u8),\n    Orange(String)\n}\n\nfn main() {\n    let (tx, rx): (Sender<Fruit>, Receiver<Fruit>) = mpsc::channel();\n\n    tx.send(Fruit::Orange("sweet".to_string())).unwrap();\n    tx.send(Fruit::Apple(2)).unwrap();\n\n    for _ in 0..2 {\n        match rx.recv().unwrap() {\n            Fruit::Apple(count) => println!("received {} apples", count),\n            Fruit::Orange(flavor) => println!("received {} oranges", flavor),\n        }\n    }\n}\n')),(0,l.kt)("h3",{id:"tokio-semaphore"},"Tokio Semaphore"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::sync::Arc;\nuse tokio::sync::Semaphore;\n\n#[tokio::main]\nasync fn main() {\n    let semaphore = Arc::new(Semaphore::new(3));\n    let mut join_handles = Vec::new();\n\n    for _ in 0..5 {\n        let permit = semaphore.clone().acquire_owned().await.unwrap();\n        join_handles.push(tokio::spawn(async move {\n            /**\n             * Task here ...\n             */\n            drop(permit);\n        }));\n    }\n\n    for handle in join_handles {\n        handle.await.unwrap();\n    }\n}\n")),(0,l.kt)("h3",{id:"atomic-primitives"},"Atomic Primitives"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::ops::Sub;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::thread::{self, JoinHandle};\nuse std::time::Instant;\n\nconst N_TIMES: u64 = 10000000;\nconst N_THREADS: usize = 10;\n\nstatic R: AtomicU64 = AtomicU64::new(0);\n\nfn add_n_times(n: u64) -> JoinHandle<()> {\n    thread::spawn(move || {\n        for _ in 0..n {\n            R.fetch_add(1, Ordering::Relaxed);\n        }\n    })\n}\n\nfn main() {\n    let s = Instant::now();\n    let mut threads = Vec::with_capacity(N_THREADS);\n\n    for _ in 0..N_THREADS {\n        threads.push(add_n_times(N_TIMES));\n    }\n\n    for thread in threads {\n        thread.join().unwrap();\n    }\n\n    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));\n\n    println!("{:?}",Instant::now().sub(s));\n}\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Ordering")," \u5185\u5b58\u987a\u5e8f:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Relaxed: \u4e71\u5e8f."),(0,l.kt)("li",{parentName:"ul"},"Release: \u8bbe\u7f6e\u5185\u5b58\u5c4f\u969c, \u4fdd\u8bc1\u5b83\u4e4b\u524d\u7684\u64cd\u4f5c\u6c38\u8fdc\u5728\u5b83\u4e4b\u524d."),(0,l.kt)("li",{parentName:"ul"},"Acquire: \u8bbe\u7f6e\u5185\u5b58\u5c4f\u969c, \u4fdd\u8bc1\u5b83\u4e4b\u540e\u7684\u64cd\u4f5c\u6c38\u8fdc\u5728\u5b83\u4e4b\u540e."),(0,l.kt)("li",{parentName:"ul"},"AcqRel: Acquire + Release."),(0,l.kt)("li",{parentName:"ul"},"SeqCst: \u987a\u5e8f\u4e00\u81f4\u6027.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::thread::{self, JoinHandle};\nuse std::sync::atomic::{Ordering, AtomicBool};\n\nstatic mut DATA: u64 = 0;\nstatic READY: AtomicBool = AtomicBool::new(false);\n\nfn reset() {\n    unsafe {\n        DATA = 0;\n    }\n    READY.store(false, Ordering::Relaxed);\n}\n\nfn producer() -> JoinHandle<()> {\n    thread::spawn(move || {\n        unsafe {\n            DATA = 100;                                 // A\n        }\n        READY.store(true, Ordering::Release);           // B: \u5185\u5b58\u5c4f\u969c \u2191\n    })\n}\n\nfn consumer() -> JoinHandle<()> {\n    thread::spawn(move || {\n        while !READY.load(Ordering::Acquire) {}         // C: \u5185\u5b58\u5c4f\u969c \u2193\n\n        assert_eq!(100, unsafe { DATA });               // D\n    })\n}\n\n\nfn main() {\n    loop {\n        reset();\n\n        let t_producer = producer();\n        let t_consumer = consumer();\n\n        t_producer.join().unwrap();\n        t_consumer.join().unwrap();\n    }\n}\n")),(0,l.kt)("p",null,"Spinlock:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{hint, thread};\n\nfn main() {\n    let spinlock = Arc::new(AtomicUsize::new(1));\n    let spinlock_clone = Arc::clone(&spinlock);\n    let thread = thread::spawn(move|| {\n        spinlock_clone.store(0, Ordering::SeqCst);\n    });\n\n    // \u7b49\u5f85\u5176\u5b83\u7ebf\u7a0b\u91ca\u653e\u9501.\n    while spinlock.load(Ordering::SeqCst) != 0 {\n        hint::spin_loop();\n    }\n\n    if let Err(panic) = thread.join() {\n        println!("Thread had an error: {:?}", panic);\n    }\n}\n')),(0,l.kt)("h3",{id:"send-and-sync-trait"},"Send and Sync Trait"),(0,l.kt)("p",null,"Send and Sync:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Marker trait."),(0,l.kt)("li",{parentName:"ul"},"\u5b9e\u73b0 ",(0,l.kt)("inlineCode",{parentName:"li"},"Send")," \u7684\u7c7b\u578b\u53ef\u4ee5\u5728\u7ebf\u7a0b\u95f4\u5b89\u5168\u7684\u4f20\u9012\u5176\u6240\u6709\u6743,\n\u5b9e\u73b0 ",(0,l.kt)("inlineCode",{parentName:"li"},"Sync")," \u7684\u7c7b\u578b\u53ef\u4ee5\u5728\u7ebf\u7a0b\u95f4\u5b89\u5168\u7684\u5171\u4eab (\u901a\u8fc7\u5f15\u7528).\n\u82e5 ",(0,l.kt)("inlineCode",{parentName:"li"},"&T: Send"),", \u5219 ",(0,l.kt)("inlineCode",{parentName:"li"},"T: Sync"),"."),(0,l.kt)("li",{parentName:"ul"},"\u7edd\u5927\u90e8\u5206\u7c7b\u578b\u90fd\u5b9e\u73b0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"li"},"Send"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"Sync"),",\n\u4f8b\u5916: \u539f\u751f\u6307\u9488, ",(0,l.kt)("inlineCode",{parentName:"li"},"Cell"),"/",(0,l.kt)("inlineCode",{parentName:"li"},"RefCell"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Rc"),".")),(0,l.kt)("h3",{id:"thread-pool"},"Thread Pool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::sync::mpsc;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::thread;\n\ntype Job = Box<dyn FnOnce() + Send + \'static>;\n\nenum Message {\n    NewJob(Job),\n    Terminate,\n}\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Message>,\n}\n\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n        let receiver = Arc::new(Mutex::new(receiver));\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + \'static,\n    {\n        let job = Box::new(f);\n        self.sender.send(Message::NewJob(job)).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        println!("Sending terminate message to all workers.");\n\n        for _ in &self.workers {\n            self.sender.send(Message::Terminate).unwrap();\n        }\n\n        println!("Shutting down all workers.");\n\n        for worker in &mut self.workers {\n            println!("Shutting down worker {}", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv().unwrap();\n\n            match message {\n                Message::NewJob(job) => {\n                    println!("Worker {} got a job; executing.", id);\n                    job();\n                }\n                Message::Terminate => {\n                    println!("Worker {} was told to terminate.", id);\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n')),(0,l.kt)("h2",{id:"asynchronous-programming"},"Asynchronous Programming"),(0,l.kt)("h3",{id:"async-and-await"},"Async and Await"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u5728 ",(0,l.kt)("inlineCode",{parentName:"li"},".await")," \u6267\u884c\u671f\u95f4, \u4efb\u52a1\u53ef\u80fd\u4f1a\u5728\u7ebf\u7a0b\u95f4\u8f6c\u79fb."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},".await")," \u53ea\u80fd\u7528\u4e8e async fn \u51fd\u6570\u4e2d.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use futures::executor::block_on;\nuse futures::join;\n\nasync fn learn_song() -> Song { /* ... */ }\nasync fn sing_song(song: Song) { /* ... */ }\nasync fn dance() { /* ... */ }\n\nasync fn learn_and_sing() {\n    let song = learn_song().await;\n    sing_song(song).await;\n}\n\nasync fn async_main() {\n    let f1 = learn_and_sing();\n    let f2 = dance();\n    join!(f1, f2);\n}\n\nfn main() {\n    block_on(async_main());\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use futures::future;\nuse futures::select;\n\npub fn main() {\n    let mut a_fut = future::ready(4);\n    let mut b_fut = future::ready(6);\n    let mut total = 0;\n\n    loop {\n        select! {\n            a = a_fut => total += a,\n            b = b_fut => total += b,\n            complete => break,\n            default => panic!(), // \u8be5\u5206\u652f\u6c38\u8fdc\u4e0d\u4f1a\u8fd0\u884c.\n        };\n    }\n\n    assert_eq!(total, 10);\n}\n")),(0,l.kt)("h3",{id:"future-trait"},"Future Trait"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Future")," \u4ee3\u8868\u4e00\u7ec4\u8ba1\u7b97, \u60f0\u6027\u6c42\u503c. \u5f53 ",(0,l.kt)("inlineCode",{parentName:"li"},".await")," \u8c03\u7528\u65f6\u624d\u771f\u6b63\u5f00\u59cb\u6267\u884c."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Future")," \u542f\u52a8\u540e\u4f1a\u56e0\u8d44\u6e90\u7b49\u539f\u56e0\u963b\u585e, \u8f6c\u5165 ",(0,l.kt)("inlineCode",{parentName:"li"},"pending")," \u72b6\u6001."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Future")," \u963b\u585e\u540e, \u5f53\u8d44\u6e90\u51c6\u5907\u597d\u53ef\u4ee5\u91cd\u65b0\u542f\u52a8\u65f6, \u4f1a\u901a\u8fc7 ",(0,l.kt)("inlineCode",{parentName:"li"},"Waker.wake")," \u901a\u77e5\u6267\u884c\u5668, \u7b49\u5f85\u88ab\u4e0b\u4e00\u6b21 ",(0,l.kt)("inlineCode",{parentName:"li"},"poll"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"trait Future {\n    type Output;\n    fn poll(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Self::Output>;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"\nuse std::{\n    future::Future,\n    pin::Pin,\n    sync::{Arc, Mutex},\n    task::{Context, Poll, Waker},\n    thread,\n    time::Duration,\n};\n\npub struct TimerFuture {\n    shared_state: Arc<Mutex<SharedState>>,\n}\n\nstruct SharedState {\n    completed: bool,\n    waker: Option<Waker>,\n}\n\nimpl Future for TimerFuture {\n    type Output = ();\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let mut shared_state = self.shared_state.lock().unwrap();\n\n        if shared_state.completed {\n            Poll::Ready(())\n        } else {\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\n\nimpl TimerFuture {\n    pub fn new(duration: Duration) -> Self {\n        let shared_state = Arc::new(Mutex::new(SharedState {\n            completed: false,\n            waker: None,\n        }));\n\n        let thread_shared_state = shared_state.clone();\n\n        thread::spawn(move || {\n            thread::sleep(duration);\n            let mut shared_state = thread_shared_state.lock().unwrap();\n            shared_state.completed = true;\n            if let Some(waker) = shared_state.waker.take() {\n                waker.wake()\n            }\n        });\n\n        TimerFuture { shared_state }\n    }\n}\n")),(0,l.kt)("p",null,"\u5f53 ",(0,l.kt)("inlineCode",{parentName:"p"},"Future")," \u4f1a\u8fd4\u56de ",(0,l.kt)("inlineCode",{parentName:"p"},"Poll::Pending")," \u65f6,\n\u4e00\u5b9a\u8981\u786e\u4fdd ",(0,l.kt)("inlineCode",{parentName:"p"},"wake")," \u80fd\u88ab\u6b63\u5e38\u8c03\u7528,\n\u5426\u5219\u4f1a\u5bfc\u81f4\u4efb\u52a1\u6c38\u8fdc\u88ab\u6302\u8d77,\n\u518d\u4e5f\u4e0d\u4f1a\u88ab\u6267\u884c\u5668 ",(0,l.kt)("inlineCode",{parentName:"p"},"poll"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\nuse std::time::{Duration, Instant};\n\nstruct Delay {\n    when: Instant,\n}\n\nimpl Future for Delay {\n    type Output = &\'static str;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<\'_>)\n        -> Poll<&\'static str>\n    {\n        if Instant::now() >= self.when {\n            println!("Hello world");\n            Poll::Ready("done")\n        } else {\n            let waker = cx.waker().clone();\n            let when = self.when;\n\n            thread::spawn(move || {\n                let now = Instant::now();\n\n                if now < when {\n                    thread::sleep(when - now);\n                }\n\n                waker.wake();\n            });\n\n            Poll::Pending\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let when = Instant::now() + Duration::from_millis(10);\n    let future = Delay { when };\n\n    let out = future.await;\n    assert_eq!(out, "done");\n}\n')),(0,l.kt)("h3",{id:"asynchronous-runtime"},"Asynchronous Runtime"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use {\n    futures::{\n        future::{BoxFuture, FutureExt},\n        task::{waker_ref, ArcWake},\n    },\n    std::{\n        future::Future,\n        sync::mpsc::{sync_channel, Receiver, SyncSender},\n        sync::{Arc, Mutex},\n        task::{Context, Poll},\n        time::Duration,\n    },\n    // \u5f15\u5165\u4e4b\u524d\u5b9e\u73b0\u7684\u5b9a\u65f6\u5668\u6a21\u5757\n    timer_future::TimerFuture,\n};\n\nstruct Task {\n    future: Mutex<Option<BoxFuture<\'static, ()>>>,\n    task_sender: SyncSender<Arc<Task>>,\n}\n\nimpl ArcWake for Task {\n    fn wake_by_ref(arc_self: &Arc<Self>) {\n        let cloned = arc_self.clone();\n        arc_self\n            .task_sender\n            .send(cloned)\n            .expect("\u4efb\u52a1\u961f\u5217\u5df2\u6ee1");\n    }\n}\n\n#[derive(Clone)]\nstruct Spawner {\n    task_sender: SyncSender<Arc<Task>>,\n}\n\nimpl Spawner {\n    fn spawn(&self, future: impl Future<Output = ()> + \'static + Send) {\n        let future = future.boxed();\n        let task = Arc::new(Task {\n            future: Mutex::new(Some(future)),\n            task_sender: self.task_sender.clone(),\n        });\n        self.task_sender.send(task).expect("\u4efb\u52a1\u961f\u5217\u5df2\u6ee1");\n    }\n}\n\nstruct Executor {\n    ready_queue: Receiver<Arc<Task>>,\n}\n\nimpl Executor {\n    fn run(&self) {\n        while let Ok(task) = self.ready_queue.recv() {\n            let mut future_slot = task.future.lock().unwrap();\n\n            if let Some(mut future) = future_slot.take() {\n                let waker = waker_ref(&task);\n                let context = &mut Context::from_waker(&*waker);\n\n                if future.as_mut().poll(context).is_pending() {\n                    // Future \u672a\u6267\u884c\u5b8c\uff0c, \u5c06\u5b83\u653e\u56de\u4efb\u52a1\u4e2d, \u7b49\u5f85\u4e0b\u6b21\u88ab poll.\n                    *future_slot = Some(future);\n                }\n            }\n        }\n    }\n}\n\nfn new_executor_and_spawner() -> (Executor, Spawner) {\n    const MAX_QUEUED_TASKS: usize = 10_000;\n    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);\n    (Executor { ready_queue }, Spawner { task_sender })\n}\n\nfn main() {\n    let (executor, spawner) = new_executor_and_spawner();\n\n    spawner.spawn(async {\n        println!("howdy!");\n        TimerFuture::new(Duration::new(2, 0)).await;\n        println!("done!");\n    });\n\n    drop(spawner);\n\n    // \u8fd0\u884c\u6267\u884c\u5668\u76f4\u5230\u4efb\u52a1\u961f\u5217\u4e3a\u7a7a.\n    // \u4efb\u52a1\u8fd0\u884c\u540e, \u4f1a\u5148\u6253\u5370 `howdy!`, \u6682\u505c 2 \u79d2, \u63a5\u7740\u6253\u5370 `done!`.\n    executor.run();\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"use std::cell::RefCell;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::sync::{Arc, Mutex};\nuse std::task::{Context, Poll, Waker};\nuse std::thread;\nuse std::time::{Duration, Instant};\nuse futures::task::{self, ArcWake};\nuse crossbeam::channel;\n\nfn main() {\n    let mini_tokio = MiniTokio::new();\n\n    mini_tokio.spawn(async {\n        spawn(async {\n            delay(Duration::from_millis(100)).await;\n            println!(\"world\");\n        });\n\n        spawn(async {\n            println!(\"hello\");\n        });\n\n        delay(Duration::from_millis(200)).await;\n        std::process::exit(0);\n    });\n\n    mini_tokio.run();\n}\n\nstruct MiniTokio {\n    scheduled: channel::Receiver<Arc<Task>>,\n    sender: channel::Sender<Arc<Task>>,\n}\n\nimpl MiniTokio {\n    fn new() -> MiniTokio {\n        let (sender, scheduled) = channel::unbounded();\n\n        MiniTokio { scheduled, sender }\n    }\n\n    fn spawn<F>(&self, future: F)\n    where\n        F: Future<Output = ()> + Send + 'static,\n    {\n        Task::spawn(future, &self.sender);\n    }\n\n    fn run(&self) {\n        CURRENT.with(|cell| {\n            *cell.borrow_mut() = Some(self.sender.clone());\n        });\n\n        while let Ok(task) = self.scheduled.recv() {\n            task.poll();\n        }\n    }\n}\n\npub fn spawn<F>(future: F)\nwhere\n    F: Future<Output = ()> + Send + 'static,\n{\n    CURRENT.with(|cell| {\n        let borrow = cell.borrow();\n        let sender = borrow.as_ref().unwrap();\n        Task::spawn(future, sender);\n    });\n}\n\nasync fn delay(dur: Duration) {\n    struct Delay {\n        when: Instant,\n        waker: Option<Arc<Mutex<Waker>>>,\n    }\n\n    impl Future for Delay {\n        type Output = ();\n\n        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n            if let Some(waker) = &self.waker {\n                let mut waker = waker.lock().unwrap();\n\n                if !waker.will_wake(cx.waker()) {\n                    *waker = cx.waker().clone();\n                }\n            } else {\n                let when = self.when;\n                let waker = Arc::new(Mutex::new(cx.waker().clone()));\n                self.waker = Some(waker.clone());\n\n                thread::spawn(move || {\n                    let now = Instant::now();\n\n                    if now < when {\n                        thread::sleep(when - now);\n                    }\n\n                    let waker = waker.lock().unwrap();\n                    waker.wake_by_ref();\n                });\n            }\n\n            if Instant::now() >= self.when {\n                Poll::Ready(())\n            } else {\n                Poll::Pending\n            }\n        }\n    }\n\n    let future = Delay {\n        when: Instant::now() + dur,\n        waker: None,\n    };\n\n    future.await;\n}\n\nthread_local! {\n    static CURRENT: RefCell<Option<channel::Sender<Arc<Task>>>> =\n        RefCell::new(None);\n}\n\nstruct Task {\n    future: Mutex<Pin<Box<dyn Future<Output = ()> + Send>>>,\n    executor: channel::Sender<Arc<Task>>,\n}\n\nimpl Task {\n    fn spawn<F>(future: F, sender: &channel::Sender<Arc<Task>>)\n    where\n        F: Future<Output = ()> + Send + 'static,\n    {\n        let task = Arc::new(Task {\n            future: Mutex::new(Box::pin(future)),\n            executor: sender.clone(),\n        });\n\n        let _ = sender.send(task);\n    }\n\n    fn poll(self: Arc<Self>) {\n        let waker = task::waker(self.clone());\n        let mut cx = Context::from_waker(&waker);\n        let mut future = self.future.try_lock().unwrap();\n        let _ = future.as_mut().poll(&mut cx);\n    }\n}\n\nimpl ArcWake for Task {\n    fn wake_by_ref(arc_self: &Arc<Self>) {\n        let _ = arc_self.executor.send(arc_self.clone());\n    }\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'#[tokio::main]\nasync fn main() {\n    println!("Hello world");\n}\n\nfn main() {\n    tokio::runtime::Builder::new_multi_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            println!("Hello world");\n        })\n}\n')),(0,l.kt)("h2",{id:"io"},"IO"),(0,l.kt)("h3",{id:"path"},"Path"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::path::Path;\n\nfn main() {\n    let path = Path::new(".");\n    let new_path = path.join("a").join("b");\n\n    // \u5c06\u8def\u5f84\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\u5207\u7247\n    match new_path.to_str() {\n        None => panic!("new path is not a valid UTF-8 sequence"),\n        Some(s) => println!("new path is {}", s),\n    }\n\n    // `display` \u65b9\u6cd5\u8fd4\u56de\u4e00\u4e2a\u53ef\u663e\u793a\u7684\u7ed3\u6784\u4f53\n    let display = path.display();\n}\n')),(0,l.kt)("h3",{id:"files"},"Files"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"File::open"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"File::create"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"file.read_to_string"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"file.write_all"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bufReader.lines"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"OpenOptions"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fs::read_dir"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fs::create_dir"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fs::create_dir_all"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fs::remove_file"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fs::remove_dir"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fs::symlink"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new("hello.txt");\n    let display = path.display();\n\n    let mut file = match File::open(&path) {\n        Err(why) => panic!("couldn\'t open {}: {}", display,\n                                                   why.description()),\n        Ok(file) => file,\n    };\n\n    let mut s = String::new();\n    match file.read_to_string(&mut s) {\n        Err(why) => panic!("couldn\'t read {}: {}", display,\n                                                   why.description()),\n        Ok(_) => print!("{} contains:\\n{}", display, s),\n    }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\nfn main() {\n    if let Ok(lines) = read_lines("./hosts") {\n        for line in lines {\n            if let Ok(ip) = line {\n                println!("{}", ip);\n            }\n        }\n    }\n}\n\nfn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>\nwhere P: AsRef<Path>, {\n    let file = File::open(filename)?;\n    Ok(io::BufReader::new(file).lines())\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'static LOREM_IPSUM: &\'static str = "Words";\n\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new("out/lorem_ipsum.txt");\n    let display = path.display();\n\n    let mut file = match File::create(&path) {\n        Err(why) => panic!("couldn\'t create {}: {}",\n                           display,\n                           why.description()),\n        Ok(file) => file,\n    };\n\n    match file.write_all(LOREM_IPSUM.as_bytes()) {\n        Err(why) => {\n            panic!("couldn\'t write to {}: {}", display,\n                                               why.description())\n        },\n        Ok(_) => println!("successfully wrote to {}", display),\n    }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fs;\nuse std::fs::{File, OpenOptions};\nuse std::io;\nuse std::io::prelude::*;\nuse std::os::unix;\nuse std::path::Path;\n\nfn cat(path: &Path) -> io::Result<String> {\n    let mut f = File::open(path)?;\n    let mut s = String::new();\n    match f.read_to_string(&mut s) {\n        Ok(_) => Ok(s),\n        Err(e) => Err(e),\n    }\n}\n\nfn echo(s: &str, path: &Path) -> io::Result<()> {\n    let mut f = File::create(path)?;\n    f.write_all(s.as_bytes())\n}\n\nfn touch(path: &Path) -> io::Result<()> {\n    match OpenOptions::new().create(true).write(true).open(path) {\n        Ok(_) => Ok(()),\n        Err(e) => Err(e),\n    }\n}\n\nfn main() {\n    println!("`mkdir a`");\n    match fs::create_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(_) => {},\n    }\n\n    println!("`echo hello > a/b.txt`");\n    echo("hello", &Path::new("a/b.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`mkdir -p a/c/d`");\n    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`touch a/c/e.txt`");\n    touch(&Path::new("a/c/e.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`ln -s ../b.txt a/c/b.txt`");\n    if cfg!(target_family = "unix") {\n        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n        });\n    }\n\n    println!("`cat a/c/b.txt`");\n    match cat(&Path::new("a/c/b.txt")) {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(s) => println!("> {}", s),\n    }\n\n    println!("`ls a`");\n    match fs::read_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(paths) => for path in paths {\n            println!("> {:?}", path.unwrap().path());\n        },\n    }\n\n    println!("`rm a/c/e.txt`");\n    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`rmdir a/c/d`");\n    fs::remove_dir("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n}\n')),(0,l.kt)("h2",{id:"system"},"System"),(0,l.kt)("h3",{id:"process"},"Process"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::process::Command;\n\nfn main() {\n    let output = Command::new("rustc")\n        .arg("--version")\n        .output().unwrap_or_else(|e| {\n            panic!("failed to execute process: {}", e)\n    });\n\n    if output.status.success() {\n        let s = String::from_utf8_lossy(&output.stdout);\n        print!("rustc succeeded and stdout was:\\n{}", s);\n    } else {\n        let s = String::from_utf8_lossy(&output.stderr);\n        print!("rustc failed and stderr was:\\n{}", s);\n    }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use std::error::Error;\nuse std::io::prelude::*;\nuse std::process::{Command, Stdio};\n\nstatic PROGRAM: &\'static str =\n"the quick brown fox jumped over the lazy dog\\n";\n\nfn main() {\n    let process = match Command::new("wc")\n                                .stdin(Stdio::piped())\n                                .stdout(Stdio::piped())\n                                .spawn() {\n        Err(why) => panic!("couldn\'t spawn wc: {}", why.description()),\n        Ok(process) => process,\n    };\n\n    match process.stdin.unwrap().write_all(PROGRAM.as_bytes()) {\n        Err(why) => panic!("couldn\'t write to wc stdin: {}",\n                           why.description()),\n        Ok(_) => println!("sent program to wc"),\n    }\n\n    let mut s = String::new();\n    match process.stdout.unwrap().read_to_string(&mut s) {\n        Err(why) => panic!("couldn\'t read wc stdout: {}",\n                           why.description()),\n        Ok(_) => print!("wc responded with:\\n{}", s),\n    }\n}\n')),(0,l.kt)("h3",{id:"command-line"},"Command Line"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'\nuse std::env;\nuse std::error::Error;\nuse std::fs;\nuse std::process;\n\npub struct Config {\n    pub query: String,\n    pub filename: String,\n    pub case_sensitive: bool,\n}\n\nimpl Config {\n    pub fn new(args: &[String]) -> Result<Config, &\'static str> {\n        if args.len() < 3 {\n            return Err("not enough arguments");\n        }\n\n        let query = args[1].clone();\n        let filename = args[2].clone();\n\n        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();\n\n        Ok(Config {\n            query,\n            filename,\n            case_sensitive,\n        })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.filename)?;\n\n    let results = if config.case_sensitive {\n        search(&config.query, &contents)\n    } else {\n        search_case_insensitive(&config.query, &contents)\n    };\n\n    for line in results {\n        println!("{}", line);\n    }\n\n    Ok(())\n}\n\npub fn search<\'a>(query: &str, contents: &\'a str) -> Vec<&\'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\npub fn search_case_insensitive<\'a>(\n    query: &str,\n    contents: &\'a str,\n) -> Vec<&\'a str> {\n    let query = query.to_lowercase();\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.to_lowercase().contains(&query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args).unwrap_or_else(|err| {\n        eprintln!("Problem parsing arguments: {}", err);\n        process::exit(1);\n    });\n\n    if let Err(e) = run(config) {\n        eprintln!("Application error: {}", e);\n\n        process::exit(1);\n    }\n}\n')),(0,l.kt)("h2",{id:"tests"},"Tests"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'fn greeting(name: &str) -> String {\n    format!("Hello {}!", name)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[ignore]\n    #[should_panic]\n    #[should_panic(expected = "Panic message.")]\n    fn greeting_contains_name() {\n        let target = "name";\n        let result = greeting("Name");\n        assert!(\n            result.contains(target),\n            "Expect: `{}`, Result: `{}`",\n            target,\n            result\n        );\n    }\n}\n')),(0,l.kt)("h2",{id:"macros"},"Macros"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n")),(0,l.kt)("h2",{id:"unsafe-code"},"Unsafe Code"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"unsafe {}"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u5bf9\u539f\u59cb\u6307\u9488\u8fdb\u884c\u89e3\u5f15\u7528."),(0,l.kt)("li",{parentName:"ul"},"\u8c03\u7528",(0,l.kt)("inlineCode",{parentName:"li"},"\u4e0d\u5b89\u5168"),"\u7684\u51fd\u6570 (\u5305\u62ec C \u51fd\u6570, \u7f16\u8bd1\u5668\u5185\u5efa\u6307\u4ee4, \u539f\u59cb\u5206\u914d\u5668)."),(0,l.kt)("li",{parentName:"ul"},"\u5b9e\u73b0",(0,l.kt)("inlineCode",{parentName:"li"},"\u4e0d\u5b89\u5168"),"\u7684\u7279\u6027."),(0,l.kt)("li",{parentName:"ul"},"\u8bbf\u95ee",(0,l.kt)("inlineCode",{parentName:"li"},"union"),"\u5b57\u6bb5."),(0,l.kt)("li",{parentName:"ul"},"\u6539\u53d8\u9759\u6001\u6570\u636e.")),(0,l.kt)("h2",{id:"comments"},"Comments"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'// Line Comments\n/* Block Comments */\n/// Document Line Comments\n/** Document Block Comments */\n//! Crate Line Comments\n/*! Crate Block Comments */\n\n/// [`Option`]\n/// [`Type`](struct@Type)\n/// [`Type`](fn@Type)\n\n#[doc(alias = "alias" )]\n')),(0,l.kt)("h2",{id:"attributes"},"Attributes"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Crate scope:",(0,l.kt)("inlineCode",{parentName:"li"},"#![crate_attribute]"),"."),(0,l.kt)("li",{parentName:"ul"},"Module/Function scope: ",(0,l.kt)("inlineCode",{parentName:"li"},"#[item_attribute]"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'#[attribute = "value"]\n#[attribute(key = "value")]\n#[attribute(value)]\n')),(0,l.kt)("h3",{id:"crate-attributes"},"Crate Attributes"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'#![crate_type = "lib"]\n#![crate_name = "rand"]\n')),(0,l.kt)("h3",{id:"linter-attributes"},"Linter Attributes"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},"#[allow(dead_code)]\n#[allow(unused)]\n")),(0,l.kt)("h3",{id:"compile-attributes"},"Compile Attributes"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(target_os = "linux")]\nfn are_you_on_linux() {\n    println!("You are running linux!")\n}\n\n#[cfg(not(target_os = "linux"))]\nfn are_you_on_linux() {\n    println!("You are *not* running linux!")\n}\n\nfn main() {\n    are_you_on_linux();\n\n    if cfg!(target_os = "linux") {\n        println!("Yes. It\'s definitely linux!");\n    } else {\n        println!("Yes. It\'s definitely *not* linux!");\n    }\n}\n')),(0,l.kt)("h2",{id:"standard-library"},"Standard Library"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"as_"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"borrowed")," -> ",(0,l.kt)("inlineCode",{parentName:"li"},"borrowed"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"into_"),": ",(0,l.kt)("inlineCode",{parentName:"li"},"owned")," -> ",(0,l.kt)("inlineCode",{parentName:"li"},"owned")," (\u79fb\u9664\u6240\u6709\u6743)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"to_"),":\n",(0,l.kt)("inlineCode",{parentName:"li"},"borrowed")," -> ",(0,l.kt)("inlineCode",{parentName:"li"},"borrowed"),",\n",(0,l.kt)("inlineCode",{parentName:"li"},"borrowed")," -> ",(0,l.kt)("inlineCode",{parentName:"li"},"owned")," on non-copy types,\n",(0,l.kt)("inlineCode",{parentName:"li"},"owned")," -> ",(0,l.kt)("inlineCode",{parentName:"li"},"owned")," on copy types."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"try_"),": \u5c1d\u8bd5\u4e00\u6b21, \u5931\u8d25\u5219\u8fd4\u56de\u6216\u62a5\u9519."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"_mut"),": \u53ef\u53d8\u501f\u7528.")),(0,l.kt)("h2",{id:"web-development"},"Web Development"),(0,l.kt)("h3",{id:"nodejs-bindings"},"Node.js Bindings"),(0,l.kt)("p",null,"Tasks suite for native ",(0,l.kt)("inlineCode",{parentName:"p"},"Node.js")," add-ons:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Computing intensive tasks with simple I/O:\ne.g ",(0,l.kt)("inlineCode",{parentName:"li"},"@node-rs/crc32")," (CPU SIMD instruction), ",(0,l.kt)("inlineCode",{parentName:"li"},"@node-rs/bcrypt"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"@node-rs/jieba"),"."),(0,l.kt)("li",{parentName:"ul"},"System call tasks:\nSIMD instruction, GPU instruction.")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/napi-rs/napi-rs"},"Napi"),":\nFramework for building compiled ",(0,l.kt)("inlineCode",{parentName:"p"},"Node.js")," add-ons in ",(0,l.kt)("inlineCode",{parentName:"p"},"Rust")," via Node API."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'#[macro_use]\nextern crate napi;\n\n/// import the preludes\nuse napi::bindgen_prelude::*;\n\n/// module registration is done by the runtime, no need to explicitly do it now.\n#[napi]\nfn fibonacci(n: u32) -> u32 {\n    match n {\n        1 | 2 => 1,\n        _ => fibonacci(n - 1) + fibonacci(n - 2),\n    }\n}\n\n/// use `Fn`, `FnMut` or `FnOnce` traits to defined JavaScript callbacks\n/// the return type of callbacks can only be `Result`.\n#[napi]\nfn get_cwd<T: Fn(String) -> Result<()>>(callback: T) {\n    callback(env::current_dir().unwrap().to_string_lossy().to_string()).unwrap();\n}\n\n/// or, define the callback signature in where clause\n#[napi]\nfn test_callback<T>(callback: T)\nwhere T: Fn(String) -> Result<()>\n{}\n\n/// async fn, require `async` feature enabled.\n/// [dependencies]\n/// napi = {version="2", features=["async"]}\n#[napi]\nasync fn read_file_async(path: String) -> Result<Buffer> {\n    tokio::fs::read(path)\n        .map(|r| match r {\n            Ok(content) => Ok(content.into()),\n            Err(e) => Err(Error::new(\n                Status::GenericFailure,\n                format!("failed to read file, {}", e),\n            )),\n        })\n        .await\n}\n')),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://github.com/neon-bindings/neon"},"Neon"),":\n",(0,l.kt)("inlineCode",{parentName:"p"},"Rust")," bindings for safe and fast native ",(0,l.kt)("inlineCode",{parentName:"p"},"Node.js")," modules."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rust"},'use neon::context::{Context, ModuleContext, FunctionContext};\nuse neon::types::JsNumber;\nuse neon::result::JsResult;\nuse neon::result::NeonResult;\n\nfn fibonacci(n: i32) -> i32 {\n    return match n {\n        n if n < 1 => 0,\n        n if n <= 2 => 1,\n        _ => fibonacci(n - 1) + fibonacci(n - 2)\n  }\n}\n\nfn fibonacci_api(mut cx: FunctionContext) -> JsResult<JsNumber> {\n    let handle = cx.argument::<JsNumber>(0).unwrap();\n    let res = fibonacci(handle.value(&mut cx) as i32);\n    Ok(cx.number(res))\n}\n\n#[neon::main]\nfn main(mut cx: ModuleContext) -> NeonResult<()> {\n    cx.export_function("fibonacci_rs", fibonacci_api)?;\n    Ok(())\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const { fibonacci_rs } = require('./index.node');\n\nconst value = process.argv[2] || null;\nconst number = parseInt(value);\n\nif (isNaN(number)) {\n  console.log('Provided value is not a number');\n  return;\n}\n\nconst result = fibonacci_rs(number);\nconsole.log(result);\n")),(0,l.kt)("h2",{id:"library"},"Library"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-num/num"},"Num: Numeric Types and Traits")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-random/rand"},"Rand: Random Number Generator")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/regex"},"Regex: Regular Expression Engine")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/chronotope/chrono"},"Chrono: DateTime Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/async-rs/async-std"},"AsyncStd: Asynchronous Version Standard Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/crossbeam-rs/crossbeam"},"Crossbeam: Concurrent Programming Tools")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/tokio-rs/tokio"},"Tokio: Asynchronous Runtime")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rayon-rs/rayon"},"Rayon: Data Parallelism Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/log"},"Log: Logging Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/tokio-rs/tracing"},"Tracing: Tracing Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/serde-rs/serde"},"Serde: Serialization Framework")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/tokio-rs/axum"},"Axum: Tokio Web Framework")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/SergioBenitez/Rocket"},"Rocket: Web Framework")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/actix/actix-web"},"Actix: Web Framework")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/seanmonstar/warp"},"Warp: Web Framework")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/seanmonstar/reqwest"},"Request: HTTP Client")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/cloudflare/quiche"},"Quiche: QUIC and HTTP/3 Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/hyperium/tonic"},"Tonic: gPRC Framework")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/quickwit-oss/quickwit"},"QuickWit: Distributed Search Engine")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/meilisearch/MeiliSearch"},"MeiliSearch: Realtime Search Engine")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/clap-rs/clap"},"Clap: CLI Framework")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/console-rs/indicatif"},"Console: ProgressBar")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/dtolnay/syn"},"Syn: Source Code Parser")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/napi-rs/napi-rs"},"Napi: Node.js Bindings Library"),":"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/neon-bindings/neon"},"Neon: Node.js Bindings Library"),":"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/git2-rs"},"Git: Git Bindings Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/colin-kiegel/rust-pretty-assertions"},"PrettyAssertions")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/bheisler/criterion.rs"},"Criterion: Benchmarking Library")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/clog-tool/clog-cli"},"Clog: Conventional Changelog"))),(0,l.kt)("h2",{id:"reference"},"Reference"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/book"},"Rust Book")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/nomicon"},"Rust Nomicon")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/async-book"},"Rust Asynchronism")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-unofficial/too-many-lists"},"Rust Data Structures")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/rust-by-example"},"Rust Example")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rust-lang/rustlings"},"Rust Lings")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/sunface/rust-course"},"Rust Course"))))}d.isMDXComponent=!0}}]);