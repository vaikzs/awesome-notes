"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[2070],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var l=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,l,a=function(e,n){if(null==e)return{};var t,l,a={},i=Object.keys(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=l.createContext({}),o=function(e){var n=l.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=o(e.components);return l.createElement(s.Provider,{value:n},e.children)},k={inlineCode:"code",wrapper:function(e){var n=e.children;return l.createElement(l.Fragment,{},n)}},c=l.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),c=o(t),m=a,d=c["".concat(s,".").concat(m)]||c[m]||k[m]||i;return t?l.createElement(d,r(r({ref:n},u),{},{components:t})):l.createElement(d,r({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=c;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,r[1]=p;for(var o=2;o<i;o++)r[o]=t[o];return l.createElement.apply(null,r)}return l.createElement.apply(null,t)}c.displayName="MDXCreateElement"},3433:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return p},metadata:function(){return o},toc:function(){return k}});var l=t(7462),a=t(3366),i=(t(7294),t(3905)),r=["components"],p={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["CS","Compiler"]},s="Compiler Basic Notes",o={unversionedId:"computerScience/compilers/compilersBasicNotes",id:"computerScience/compilers/compilersBasicNotes",title:"Compiler Basic Notes",description:"Basic Concepts",source:"@site/notes/computerScience/compilers/compilersBasicNotes.md",sourceDirName:"computerScience/compilers",slug:"/computerScience/compilers/compilersBasicNotes",permalink:"/awesome-notes/computerScience/compilers/compilersBasicNotes",editUrl:"https://github.com/sabertazimi/awesome-notes/edit/main/notes/computerScience/compilers/compilersBasicNotes.md",tags:[{label:"CS",permalink:"/awesome-notes/tags/cs"},{label:"Compiler",permalink:"/awesome-notes/tags/compiler"}],version:"current",lastUpdatedBy:"sabertazimi",lastUpdatedAt:1649250539,formattedLastUpdatedAt:"4/6/2022",frontMatter:{author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["CS","Compiler"]},sidebar:"sidebar",previous:{title:"Graph Processing Basic Notes",permalink:"/awesome-notes/computerScience/architecture/graphProcessingBasicNotes"},next:{title:"Database Basic Notes",permalink:"/awesome-notes/computerScience/database/databaseBasicNotes"}},u={},k=[{value:"Basic Concepts",id:"basic-concepts",level:2},{value:"Definition of compilers",id:"definition-of-compilers",level:3},{value:"Structure of compilers",id:"structure-of-compilers",level:3},{value:"\u6587\u6cd5\u4e0e\u8bed\u8a00",id:"\u6587\u6cd5\u4e0e\u8bed\u8a00",level:2},{value:"\u7b26\u53f7\u4e0e\u7b26\u53f7\u4e32",id:"\u7b26\u53f7\u4e0e\u7b26\u53f7\u4e32",level:3},{value:"\u6587\u6cd5\u4e0e\u8bed\u8a00\u7684\u5f62\u5f0f\u5316\u8868\u793a",id:"\u6587\u6cd5\u4e0e\u8bed\u8a00\u7684\u5f62\u5f0f\u5316\u8868\u793a",level:3},{value:"\u4e54\u59c6\u65af\u57fa\u6587\u6cd5\u4f53\u7cfb",id:"\u4e54\u59c6\u65af\u57fa\u6587\u6cd5\u4f53\u7cfb",level:3},{value:"\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5",id:"\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5",level:3},{value:"\u6587\u6cd5\u8868\u793a",id:"\u6587\u6cd5\u8868\u793a",level:4},{value:"\u5f62\u5f0f\u5316\u8868\u793a",id:"\u5f62\u5f0f\u5316\u8868\u793a",level:4},{value:"\u7b80\u6613\u8868\u793a",id:"\u7b80\u6613\u8868\u793a",level:5},{value:"\u5df4\u79d1\u65af\u8303\u5f0f",id:"\u5df4\u79d1\u65af\u8303\u5f0f",level:5},{value:"\u6b63\u89c4\u6587\u6cd5",id:"\u6b63\u89c4\u6587\u6cd5",level:3},{value:"\u6b63\u5219\u8bed\u8a00(Regular Expressions)",id:"\u6b63\u5219\u8bed\u8a00regular-expressions",level:3},{value:"\u57fa\u672c\u5b9a\u4e49",id:"\u57fa\u672c\u5b9a\u4e49",level:4},{value:"\u5f62\u5f0f\u8868\u793a",id:"\u5f62\u5f0f\u8868\u793a",level:4},{value:"\u6b63\u5219\u8bed\u6cd5\u7cd6(Syntax Sugar)",id:"\u6b63\u5219\u8bed\u6cd5\u7cd6syntax-sugar",level:4},{value:"\u5206\u6790\u6811",id:"\u5206\u6790\u6811",level:3},{value:"\u63a8\u5bfc\u7c7b\u578b",id:"\u63a8\u5bfc\u7c7b\u578b",level:4},{value:"\u53e5\u578b\u5206\u6790",id:"\u53e5\u578b\u5206\u6790",level:4},{value:"meaning function(\u591a\u5bf9\u4e00)",id:"meaning-function\u591a\u5bf9\u4e00",level:4},{value:"\u4e8c\u4e49\u6027\u6587\u6cd5(\u4e00\u5bf9\u591a)",id:"\u4e8c\u4e49\u6027\u6587\u6cd5\u4e00\u5bf9\u591a",level:4},{value:"\u6587\u6cd5\u91cd\u5199",id:"\u6587\u6cd5\u91cd\u5199",level:5},{value:"\u4f18\u5148\u7ea7\u4e0e\u7ed3\u5408\u6027",id:"\u4f18\u5148\u7ea7\u4e0e\u7ed3\u5408\u6027",level:5},{value:"\u6587\u6cd5\u89c4\u5219",id:"\u6587\u6cd5\u89c4\u5219",level:3},{value:"Lexical Analysis",id:"lexical-analysis",level:2},{value:"Tokenizer - \u8bcd\u6cd5\u5206\u6790\u5668",id:"tokenizer---\u8bcd\u6cd5\u5206\u6790\u5668",level:3},{value:"\u8f6c\u79fb\u56fe\u7b97\u6cd5",id:"\u8f6c\u79fb\u56fe\u7b97\u6cd5",level:4},{value:"\u5173\u952e\u5b57(keyword)\u5904\u7406",id:"\u5173\u952e\u5b57keyword\u5904\u7406",level:4},{value:"\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a(Finite Automaton)",id:"\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673afinite-automaton",level:3},{value:"\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a(Deterministic Finite Automaton)",id:"\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673adeterministic-finite-automaton",level:4},{value:"\u72b6\u6001\u8f6c\u79fb\u8868\u5b9e\u73b0 DFA",id:"\u72b6\u6001\u8f6c\u79fb\u8868\u5b9e\u73b0-dfa",level:5},{value:"\u975e\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a(Nondeterministic Finite Automaton)",id:"\u975e\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673anondeterministic-finite-automaton",level:4},{value:"\u81ea\u52a8\u8bcd\u6cd5\u5206\u6790\u5668",id:"\u81ea\u52a8\u8bcd\u6cd5\u5206\u6790\u5668",level:3},{value:"Thompson \u7b97\u6cd5",id:"thompson-\u7b97\u6cd5",level:4},{value:"\u5b50\u96c6\u6784\u9020\u7b97\u6cd5",id:"\u5b50\u96c6\u6784\u9020\u7b97\u6cd5",level:4},{value:"Hopcroft \u7b97\u6cd5",id:"hopcroft-\u7b97\u6cd5",level:4},{value:"\u5b9e\u73b0",id:"\u5b9e\u73b0",level:4},{value:"DFA",id:"dfa",level:5},{value:"\u6709\u5411\u56fe",id:"\u6709\u5411\u56fe",level:6},{value:"\u8f6c\u79fb\u8868",id:"\u8f6c\u79fb\u8868",level:6},{value:"Syntax Analysis(\u8bed\u6cd5\u5206\u6790)",id:"syntax-analysis\u8bed\u6cd5\u5206\u6790",level:2},{value:"\u81ea\u9876\u5411\u4e0b\u5206\u6790",id:"\u81ea\u9876\u5411\u4e0b\u5206\u6790",level:3},{value:"\u907f\u514d\u56de\u6eaf",id:"\u907f\u514d\u56de\u6eaf",level:4},{value:"\u9012\u5f52\u4e0b\u964d\u5206\u6790\u7b97\u6cd5(Recursive Descent/\u9884\u6d4b\u5206\u6790\u7b97\u6cd5)",id:"\u9012\u5f52\u4e0b\u964d\u5206\u6790\u7b97\u6cd5recursive-descent\u9884\u6d4b\u5206\u6790\u7b97\u6cd5",level:4},{value:"\u7b97\u6cd5\u5b9e\u73b0",id:"\u7b97\u6cd5\u5b9e\u73b0",level:5},{value:"LL(1)\u5206\u6790\u7b97\u6cd5",id:"ll1\u5206\u6790\u7b97\u6cd5",level:4},{value:"nullable sets",id:"nullable-sets",level:5},{value:"first sets",id:"first-sets",level:5},{value:"follow sets",id:"follow-sets",level:5},{value:"select sets",id:"select-sets",level:5},{value:"\u5206\u6790\u8868",id:"\u5206\u6790\u8868",level:5},{value:"\u89e3\u51b3\u51b2\u7a81(\u5206\u6790\u8868\u67d0\u9879\u6709\u591a\u4e2a\u7f16\u53f7)",id:"\u89e3\u51b3\u51b2\u7a81\u5206\u6790\u8868\u67d0\u9879\u6709\u591a\u4e2a\u7f16\u53f7",level:5},{value:"\u6d88\u9664\u76f4\u63a5\u5de6\u9012\u5f52",id:"\u6d88\u9664\u76f4\u63a5\u5de6\u9012\u5f52",level:6},{value:"\u6d88\u9664\u95f4\u63a5\u5de6\u9012\u5f52",id:"\u6d88\u9664\u95f4\u63a5\u5de6\u9012\u5f52",level:6},{value:"\u975e LL(1) \u6587\u6cd5/\u8bed\u8a00",id:"\u975e-ll1-\u6587\u6cd5\u8bed\u8a00",level:5},{value:"\u81ea\u5e95\u5411\u4e0a\u5206\u6790",id:"\u81ea\u5e95\u5411\u4e0a\u5206\u6790",level:3},{value:"LR(0) \u5206\u6790\u7b97\u6cd5",id:"lr0-\u5206\u6790\u7b97\u6cd5",level:4},{value:"\u77ed\u8bed",id:"\u77ed\u8bed",level:5},{value:"\u5206\u6790\u8868\u6784\u9020",id:"\u5206\u6790\u8868\u6784\u9020",level:5},{value:"\u9a71\u52a8\u4ee3\u7801",id:"\u9a71\u52a8\u4ee3\u7801",level:5},{value:"\u89e3\u51b3\u51b2\u7a81",id:"\u89e3\u51b3\u51b2\u7a81",level:5},{value:"LALR-K",id:"lalr-k",level:4},{value:"SLR",id:"slr",level:4},{value:"SLR \u5b9e\u73b0",id:"slr-\u5b9e\u73b0",level:5},{value:"\u62bd\u8c61\u8bed\u6cd5\u6811",id:"\u62bd\u8c61\u8bed\u6cd5\u6811",level:3},{value:"\u8bed\u6cd5\u5236\u5bfc\u7ffb\u8bd1(Syntax-Directed Translation)",id:"\u8bed\u6cd5\u5236\u5bfc\u7ffb\u8bd1syntax-directed-translation",level:4},{value:"\u62bd\u8c61\u8bed\u6cd5",id:"\u62bd\u8c61\u8bed\u6cd5",level:4},{value:"AST \u7684\u5b9e\u73b0",id:"ast-\u7684\u5b9e\u73b0",level:4},{value:"\u6570\u636e\u7ed3\u6784",id:"\u6570\u636e\u7ed3\u6784",level:5},{value:"\u76f8\u5173\u7b97\u6cd5",id:"\u76f8\u5173\u7b97\u6cd5",level:5},{value:"\u6784\u9020\u7b97\u6cd5",id:"\u6784\u9020\u7b97\u6cd5",level:5},{value:"Semantic Analysis(\u8bed\u4e49\u5206\u6790)",id:"semantic-analysis\u8bed\u4e49\u5206\u6790",level:2},{value:"\u7c7b\u578b\u7cfb\u7edf(type system)",id:"\u7c7b\u578b\u7cfb\u7edftype-system",level:3},{value:"Type Checking",id:"type-checking",level:4},{value:"Type Environments",id:"type-environments",level:4},{value:"Typing Methods",id:"typing-methods",level:4},{value:"\u7b26\u53f7\u8868(\u4e0a\u4e0b\u6587\u76f8\u5173)",id:"\u7b26\u53f7\u8868\u4e0a\u4e0b\u6587\u76f8\u5173",level:3},{value:"\u7c7b\u578b\u68c0\u67e5",id:"\u7c7b\u578b\u68c0\u67e5",level:3},{value:"\u4f5c\u7528\u57df\u68c0\u67e5",id:"\u4f5c\u7528\u57df\u68c0\u67e5",level:3},{value:"\u7c7b\u578b\u76f8\u5bb9\u6027",id:"\u7c7b\u578b\u76f8\u5bb9\u6027",level:3},{value:"\u9519\u8bef\u8bca\u65ad",id:"\u9519\u8bef\u8bca\u65ad",level:3},{value:"Immediate Representation",id:"immediate-representation",level:2},{value:"\u4e09\u5730\u5740\u7801",id:"\u4e09\u5730\u5740\u7801",level:3},{value:"\u63a7\u5236\u6d41\u56fe",id:"\u63a7\u5236\u6d41\u56fe",level:3},{value:"Block",id:"block",level:4},{value:"\u6570\u636e\u6d41\u5206\u6790\u4e0e\u7a0b\u5e8f\u91cd\u5199",id:"\u6570\u636e\u6d41\u5206\u6790\u4e0e\u7a0b\u5e8f\u91cd\u5199",level:4},{value:"\u6570\u636e\u5206\u6790\u65b9\u6cd5",id:"\u6570\u636e\u5206\u6790\u65b9\u6cd5",level:5},{value:"\u5230\u8fbe\u5b9a\u4e49\u5206\u6790",id:"\u5230\u8fbe\u5b9a\u4e49\u5206\u6790",level:6},{value:"\u6d3b\u6027\u5206\u6790",id:"\u6d3b\u6027\u5206\u6790",level:6},{value:"\u4ee3\u7801\u4f18\u5316",id:"\u4ee3\u7801\u4f18\u5316",level:2},{value:"\u7ec4\u7ec7\u7ba1\u7406",id:"\u7ec4\u7ec7\u7ba1\u7406",level:3},{value:"Activation Record and Frame",id:"activation-record-and-frame",level:4},{value:"\u5168\u5c40\u53d8\u91cf",id:"\u5168\u5c40\u53d8\u91cf",level:4},{value:"\u5806\u533a",id:"\u5806\u533a",level:4},{value:"\u4f18\u5316\u7c7b\u578b",id:"\u4f18\u5316\u7c7b\u578b",level:3},{value:"\u5c40\u90e8\u4f18\u5316",id:"\u5c40\u90e8\u4f18\u5316",level:3},{value:"\u5168\u5c40\u4f18\u5316",id:"\u5168\u5c40\u4f18\u5316",level:3},{value:"Dead Code Elimination",id:"dead-code-elimination",level:4},{value:"Constant Propagation",id:"constant-propagation",level:4},{value:"Liveness Analysis",id:"liveness-analysis",level:4},{value:"\u5bc4\u5b58\u5668\u5206\u914d",id:"\u5bc4\u5b58\u5668\u5206\u914d",level:4},{value:"Code Generation(\u4ee3\u7801\u751f\u6210)",id:"code-generation\u4ee3\u7801\u751f\u6210",level:2},{value:"\u9012\u5f52\u4e0b\u964d\u4ee3\u7801\u751f\u6210\u7b97\u6cd5",id:"\u9012\u5f52\u4e0b\u964d\u4ee3\u7801\u751f\u6210\u7b97\u6cd5",level:3},{value:"\u57fa\u4e8e\u6808\u8ba1\u7b97\u673a",id:"\u57fa\u4e8e\u6808\u8ba1\u7b97\u673a",level:4},{value:"\u57fa\u4e8e\u5bc4\u5b58\u5668\u8ba1\u7b97\u673a (RISC)",id:"\u57fa\u4e8e\u5bc4\u5b58\u5668\u8ba1\u7b97\u673a-risc",level:4},{value:"Garbage Collection",id:"garbage-collection",level:2},{value:"Mark and Sweep",id:"mark-and-sweep",level:3},{value:"Stop and Copy",id:"stop-and-copy",level:3},{value:"Compilers Exercise",id:"compilers-exercise",level:2},{value:"C Declaration Interpreter",id:"c-declaration-interpreter",level:3},{value:"Cool Language",id:"cool-language",level:3},{value:"Parser Implementation",id:"parser-implementation",level:3}],c={toc:k};function m(e){var n=e.components,t=(0,a.Z)(e,r);return(0,i.kt)("wrapper",(0,l.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"compiler-basic-notes"},"Compiler Basic Notes"),(0,i.kt)("h2",{id:"basic-concepts"},"Basic Concepts"),(0,i.kt)("h3",{id:"definition-of-compilers"},"Definition of compilers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"program_code")," ---compiler---\x3e executable"),(0,i.kt)("li",{parentName:"ul"},"data ---executable---\x3e output")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"e.g Fortran(formula translation) 1 project")),(0,i.kt)("h3",{id:"structure-of-compilers"},"Structure of compilers"),(0,i.kt)("p",null,"front-end to back-end:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"front-end: src ---lexical analysis---\x3e tokens\n---parsing/syntax analysis---\x3e AST(Abstract Syntax Tree)\n---semantic analysis---\x3e intermediate"),(0,i.kt)("li",{parentName:"ul"},"back-end: intermediate ---...---\x3e ... ---...---\x3e ... ---code generation---\x3e dist")),(0,i.kt)("p",null,"details:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"lexical analysis(\u8bcd\u6cd5\u5206\u6790)"),(0,i.kt)("li",{parentName:"ul"},"parsing/syntax analysis(\u8bed\u6cd5\u5206\u6790)"),(0,i.kt)("li",{parentName:"ul"},"semantic analysis(\u8bed\u4e49\u5206\u6790): type and scope"),(0,i.kt)("li",{parentName:"ul"},"optimization"),(0,i.kt)("li",{parentName:"ul"},"code generation: translate to other high level language/assembly code/machine code")),(0,i.kt)("h2",{id:"\u6587\u6cd5\u4e0e\u8bed\u8a00"},"\u6587\u6cd5\u4e0e\u8bed\u8a00"),(0,i.kt)("h3",{id:"\u7b26\u53f7\u4e0e\u7b26\u53f7\u4e32"},"\u7b26\u53f7\u4e0e\u7b26\u53f7\u4e32"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5b57\u6bcd\u8868/\u7b26\u53f7\u96c6: \u5143\u7d20\u7684\u975e\u7a7a\u6709\u7a77\u96c6\u5408"),(0,i.kt)("li",{parentName:"ul"},"\u7b26\u53f7\u4e32: \u5b57\u6bcd\u8868\u4e2d\u7684\u7b26\u53f7\u7ec4\u6210\u7684\u4efb\u4f55\u6709\u7a77\u5e8f\u5217"),(0,i.kt)("li",{parentName:"ul"},"\u56fa\u6709\u5934/\u5c3e: \u975e\u7a7a\u9996/\u5c3e\u5b50\u4e32"),(0,i.kt)("li",{parentName:"ul"},"\u95ed\u5305: ",(0,i.kt)("inlineCode",{parentName:"li"},"\u03a3* = \u03a30 U \u03a31 U ... U \u03a3n ..."),"."),(0,i.kt)("li",{parentName:"ul"},"\u6b63\u95ed\u5305: ",(0,i.kt)("inlineCode",{parentName:"li"},"\u03a3* = \u03a31 U ... U \u03a3n ..."),".")),(0,i.kt)("h3",{id:"\u6587\u6cd5\u4e0e\u8bed\u8a00\u7684\u5f62\u5f0f\u5316\u8868\u793a"},"\u6587\u6cd5\u4e0e\u8bed\u8a00\u7684\u5f62\u5f0f\u5316\u8868\u793a"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6587\u6cd5 (Grammar): ",(0,i.kt)("inlineCode",{parentName:"li"},"G = (Vn, Vt, P, S)"),", \u975e\u7ec8\u7ed3\u7b26\u96c6, \u7ec8\u7ed3\u7b26\u96c6, \u89c4\u5219/\u4ea7\u751f\u5f0f\u96c6, \u5f00\u59cb\u7b26\u53f7."),(0,i.kt)("li",{parentName:"ul"},"\u8bed\u8a00 (Language): ",(0,i.kt)("inlineCode",{parentName:"li"},"L(G) = {x | S -> x, x <- Vt}")," \u6587\u6cd5 G \u4e00\u5207\u53e5\u5b50\u7684\u96c6\u5408."),(0,i.kt)("li",{parentName:"ul"},"\u53e5\u578b: rhs of P, \u53e5\u5b50: \u4e0d\u542b\u975e\u7ec8\u7ed3\u7b26\u7684\u53f3\u90e8"),(0,i.kt)("li",{parentName:"ul"},"\u76f4\u63a5\u63a8\u5bfc: ",(0,i.kt)("inlineCode",{parentName:"li"},"v -> w"),", \u95ed\u5305\u63a8\u5bfc: ",(0,i.kt)("inlineCode",{parentName:"li"},"v -*> w"),", \u6b63\u95ed\u5305\u63a8\u5bfc: ",(0,i.kt)("inlineCode",{parentName:"li"},"v -+> w"),".")),(0,i.kt)("h3",{id:"\u4e54\u59c6\u65af\u57fa\u6587\u6cd5\u4f53\u7cfb"},"\u4e54\u59c6\u65af\u57fa\u6587\u6cd5\u4f53\u7cfb"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"((((3)2)1)0)"),(0,i.kt)("li",{parentName:"ul"},"0 \u578b\u6587\u6cd5: \u4efb\u610f\u6587\u6cd5"),(0,i.kt)("li",{parentName:"ul"},"1 \u578b\u6587\u6cd5: \u4e0a\u4e0b\u6587\u6709\u5173\u6587\u6cd5(context sensitive) \u03b1A\u03b2 -> \u03b1\u03b7\u03b2"),(0,i.kt)("li",{parentName:"ul"},"2 \u578b\u6587\u6cd5(\u8bed\u6cd5\u5de5\u5177): \u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5 A -> \u03b1"),(0,i.kt)("li",{parentName:"ul"},"3 \u578b\u6587\u6cd5(\u8bcd\u6cd5\u5de5\u5177): \u6b63\u89c4\u6587\u6cd5")),(0,i.kt)("h3",{id:"\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5"},"\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5"),(0,i.kt)("h4",{id:"\u6587\u6cd5\u8868\u793a"},"\u6587\u6cd5\u8868\u793a"),(0,i.kt)("p",null,"G = (S, N, T, P):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"S: \u5f00\u59cb\u7b26"),(0,i.kt)("li",{parentName:"ul"},"N: \u975e\u7ec8\u7ed3\u7b26\u96c6\u5408"),(0,i.kt)("li",{parentName:"ul"},"T: \u7ec8\u7ed3\u7b26\u96c6\u5408"),(0,i.kt)("li",{parentName:"ul"},"P: \u4ea7\u751f\u5f0f\u89c4\u5219\u96c6\u5408 X -> beta1, beta2, ..., betaN, X <- N, beta <- N+T")),(0,i.kt)("h4",{id:"\u5f62\u5f0f\u5316\u8868\u793a"},"\u5f62\u5f0f\u5316\u8868\u793a"),(0,i.kt)("h5",{id:"\u7b80\u6613\u8868\u793a"},"\u7b80\u6613\u8868\u793a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Sentence -> Noun Verb Noun\nNoun -> sheep\n  | tiger\n  | grass\n  | water\nVerb -> eat\n  | drink\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"S: Sentence, N: Sentence/Verb/Noun, T: sheep/tiger/grass/water/eat/drink")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"E -> num\n  |id\n  |E + E\n  |E `*` E\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"S: E"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"N: E"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"T: num/id/+/*"),"."),(0,i.kt)("h5",{id:"\u5df4\u79d1\u65af\u8303\u5f0f"},"\u5df4\u79d1\u65af\u8303\u5f0f"),(0,i.kt)("p",null,"Backus-Naur Form:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"::="),": ",(0,i.kt)("inlineCode",{parentName:"li"},"\u88ab\u5b9a\u4e49\u4e3a"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"word"),": \u5b57\u7b26\u672c\u8eab."),(0,i.kt)("li",{parentName:"ul"},"\u53cc\u5f15\u53f7\u5916\u7684\u5b57: \u8bed\u6cd5\u90e8\u5206."),(0,i.kt)("li",{parentName:"ul"},"\u5c16\u62ec\u53f7(",(0,i.kt)("inlineCode",{parentName:"li"},"< >"),"): \u5fc5\u9009\u9879(\u975e\u7ec8\u7ed3\u7b26)."),(0,i.kt)("li",{parentName:"ul"},"\u65b9\u62ec\u53f7(",(0,i.kt)("inlineCode",{parentName:"li"},"[ ]"),") : 0/1."),(0,i.kt)("li",{parentName:"ul"},"\u5927\u62ec\u53f7(",(0,i.kt)("inlineCode",{parentName:"li"},"{ }"),") : 0/n."),(0,i.kt)("li",{parentName:"ul"},"\u7ad6\u7ebf(",(0,i.kt)("inlineCode",{parentName:"li"},"|"),") : ",(0,i.kt)("inlineCode",{parentName:"li"},"OR"),".")),(0,i.kt)("h3",{id:"\u6b63\u89c4\u6587\u6cd5"},"\u6b63\u89c4\u6587\u6cd5"),(0,i.kt)("p",null,"\u6b63\u89c4\u6587\u6cd5\u53ef\u4e0e\u6b63\u5219\u8bed\u8a00\u76f8\u4e92\u8f6c\u5316:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A -> aB|Ba"),(0,i.kt)("li",{parentName:"ul"},"A -> a")),(0,i.kt)("h3",{id:"\u6b63\u5219\u8bed\u8a00regular-expressions"},"\u6b63\u5219\u8bed\u8a00(Regular Expressions)"),(0,i.kt)("h4",{id:"\u57fa\u672c\u5b9a\u4e49"},"\u57fa\u672c\u5b9a\u4e49"),(0,i.kt)("p",null,"\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u5b57\u7b26\u96c6 C:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u7a7a\u4e32 ",(0,i.kt)("inlineCode",{parentName:"li"},'"\\0"')," \u662f\u6b63\u5219\u8868\u8fbe\u5f0f."),(0,i.kt)("li",{parentName:"ul"},"\u4efb\u610f ",(0,i.kt)("inlineCode",{parentName:"li"},"char <- C")," \u662f\u6b63\u5219\u8868\u8fbe\u5f0f."),(0,i.kt)("li",{parentName:"ul"},"\u82e5 ",(0,i.kt)("inlineCode",{parentName:"li"},"M"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"N")," \u662f\u6b63\u5219\u8868\u8fbe\u5f0f, \u5219 ",(0,i.kt)("inlineCode",{parentName:"li"},"M|N = {M, N}"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"MN = {mn|m <- M, n <- N}"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},'M* = {"\\0", M, MM, MMM, ...}')," (\u9009\u62e9/\u8fde\u63a5/\u95ed\u5305) \u4e5f\u662f\u6b63\u5219\u8868\u8fbe\u5f0f.")),(0,i.kt)("h4",{id:"\u5f62\u5f0f\u8868\u793a"},"\u5f62\u5f0f\u8868\u793a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'# \u5177\u6709\u987a\u5e8f\u6027\ne -> "\\0" # basic definition\n  | c # basic definition\n  | e | e # recursive definition\n  | ee # recursive definition\n  | e* # recursive definition\n')),(0,i.kt)("h4",{id:"\u6b63\u5219\u8bed\u6cd5\u7cd6syntax-sugar"},"\u6b63\u5219\u8bed\u6cd5\u7cd6(Syntax Sugar)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[a-z]")," : a|...|z"),(0,i.kt)("li",{parentName:"ul"},"c? : 0/1 \u4e2a c"),(0,i.kt)("li",{parentName:"ul"},"c+ : 1/n \u4e2a c"),(0,i.kt)("li",{parentName:"ul"},"c{i, j} : i-j \u4e2a c"),(0,i.kt)("li",{parentName:"ul"},'"a',(0,i.kt)("em",{parentName:"li"},'" : a')," \u81ea\u8eab(\u975e Kleene Closure)"),(0,i.kt)("li",{parentName:"ul"},". : \u9664 \u2018\\n\u2019 \u5916\u7684\u4efb\u610f\u5b57\u7b26")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// \u6807\u8bc6\u7b26\nconst identifier = /[a-zA-Z\\_][a-zA-Z\\_0-9]*/g;\n\n// decimal integer\nconst integer = /(+|-)?(0|[1-9][0-9]*)/g;\n\n// decimal float\nconst float = /(+|-)?(0|[1-9][0-9]*|)?\\.[0-9]+/g;\n")),(0,i.kt)("h3",{id:"\u5206\u6790\u6811"},"\u5206\u6790\u6811"),(0,i.kt)("p",null,"\u8fdb\u884c\u6587\u6cd5\u63a8\u5bfc\u65f6\u751f\u6210\u7684\u6811:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6839 : \u5f00\u59cb\u7b26"),(0,i.kt)("li",{parentName:"ul"},"\u5185\u90e8\u7ed3\u70b9 : \u975e\u7ec8\u7ed3\u7b26"),(0,i.kt)("li",{parentName:"ul"},"\u53f6\u5b50\u7ed3\u70b9 : \u7ec8\u7ed3\u7b26"),(0,i.kt)("li",{parentName:"ul"},"\u5c42 : \u4e00\u6b65\u63a8\u5bfc(\u4f18\u5148\u7ea7\u5f71\u54cd\u63a8\u5bfc\u987a\u5e8f)"),(0,i.kt)("li",{parentName:"ul"},"\u53f6\u5b50\u7ed3\u70b9\u4e32: \u6700\u7ec8\u8868\u8fbe\u5f0f"),(0,i.kt)("li",{parentName:"ul"},"\u540e\u5e8f\u904d\u5386 : \u6700\u7ec8\u7ed3\u679c")),(0,i.kt)("h4",{id:"\u63a8\u5bfc\u7c7b\u578b"},"\u63a8\u5bfc\u7c7b\u578b"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6700\u5de6\u63a8\u5bfc(leftmost)"),(0,i.kt)("li",{parentName:"ul"},"\u6700\u53f3\u63a8\u5bfc(rightmost)(",(0,i.kt)("strong",{parentName:"li"},"\u89c4\u8303\u63a8\u5bfc"),")")),(0,i.kt)("h4",{id:"\u53e5\u578b\u5206\u6790"},"\u53e5\u578b\u5206\u6790"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u77ed\u8bed: \u82e5 ",(0,i.kt)("inlineCode",{parentName:"li"},"S -*> A\u03b2, A -+> \u03b1"),", \u5219\u79f0 \u03b1 \u662f\u53e5\u578b \u03b1\u03b2 \u76f8\u5bf9\u4e8e\u975e\u7ec8\u7ed3\u7b26 A \u7684\u77ed\u8bed"),(0,i.kt)("li",{parentName:"ul"},"\u76f4\u63a5\u77ed\u8bed: ",(0,i.kt)("inlineCode",{parentName:"li"},"S -*> A\u03b2, A -> \u03b1"),"."),(0,i.kt)("li",{parentName:"ul"},"\u4e00\u4e2a\u53f3\u53e5\u578b\u7684\u76f4\u63a5\u77ed\u8bed\u79f0\u4e3a\u8be5\u53e5\u578b\u7684\u53e5\u67c4(\u7528\u4e8e",(0,i.kt)("strong",{parentName:"li"},"\u81ea\u4e0b\u800c\u4e0a"),"\u7684\u5f52\u7ea6\u5206\u6790)"),(0,i.kt)("li",{parentName:"ul"},"\u6700\u5de6\u5f52\u7ea6: \u5f52\u7ea6\u6700\u5de6\u7684\u53e5\u67c4, \u6700\u53f3\u5f52\u7ea6: \u5f52\u7ea6\u6700\u53f3\u7684\u53e5\u67c4")),(0,i.kt)("h4",{id:"meaning-function\u591a\u5bf9\u4e00"},"meaning function(\u591a\u5bf9\u4e00)"),(0,i.kt)("p",null,"L(syntax) = semantic: \u591a\u4e2a\u8bed\u6cd5\u5bf9\u5e94\u4e00\u4e2a\u8bed\u4e49(\u4e0d\u540c\u5f62\u5f0f\u7684\u8868\u8fbe\u5f0f\u5bf9\u5e94\u540c\u4e00\u4e2a\u610f\u601d)"),(0,i.kt)("h4",{id:"\u4e8c\u4e49\u6027\u6587\u6cd5\u4e00\u5bf9\u591a"},"\u4e8c\u4e49\u6027\u6587\u6cd5(\u4e00\u5bf9\u591a)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6700\u5de6\u63a8\u5bfc\u4e0e\u6700\u53f3\u63a8\u5bfc\u5f97\u51fa\u7684\u5206\u6790\u6811\u4e0d\u4e00\u81f4"),(0,i.kt)("li",{parentName:"ul"},"\u82e5\u7ed9\u5b9a\u6587\u6cd5 G, \u5bf9\u4e8e\u53e5\u5b50 s, \u5176\u6709 2 \u79cd\u4e0d\u540c\u7684\u5206\u6790\u6811, \u5219\u79f0 G \u662f\u4e8c\u4e49\u6027\u6587\u6cd5"),(0,i.kt)("li",{parentName:"ul"},"\u82e5\u4e00\u4e2a\u4e0a\u4e0b\u6587\u65e0\u5173\u8bed\u8a00\u7684\u6240\u6709\u6587\u6cd5\u90fd\u662f\u4e8c\u4e49\u6027\u6587\u6cd5, \u5219\u79f0\u6b64\u8bed\u8a00\u662f\u5148\u5929\u4e8c\u4e49\u8bed\u8a00")),(0,i.kt)("h5",{id:"\u6587\u6cd5\u91cd\u5199"},"\u6587\u6cd5\u91cd\u5199"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"E -> E + T\n  |T\nT -> T * F\n  |F\nF -> num\n  |id\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u6d88\u9664 + \u4e0e ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," \u7684\u4e8c\u4e49\u6027, \u5982 3+4",(0,i.kt)("inlineCode",{parentName:"p"},"*"),"5")),(0,i.kt)("h5",{id:"\u4f18\u5148\u7ea7\u4e0e\u7ed3\u5408\u6027"},"\u4f18\u5148\u7ea7\u4e0e\u7ed3\u5408\u6027"),(0,i.kt)("p",null,"\u58f0\u660e\u4f18\u5148\u7ea7\u4e0e\u7ed3\u5408\u6027\u53ef\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u6d88\u9664\u6587\u6cd5\u7684\u4e8c\u4e49\u6027"),(0,i.kt)("h3",{id:"\u6587\u6cd5\u89c4\u5219"},"\u6587\u6cd5\u89c4\u5219"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6709\u5bb3\u89c4\u5219: \u4f7f\u6587\u6cd5\u4ea7\u751f\u4e8c\u4e49\u6027\u7684\u89c4\u5219"),(0,i.kt)("li",{parentName:"ul"},"\u591a\u4f59\u89c4\u5219: \u4e0d\u53ef\u8fbe/\u4e0d\u53ef\u7ec8\u6b62\u7684\u89c4\u5219"),(0,i.kt)("li",{parentName:"ul"},"2 \u578b\u6587\u6cd5\u7684 \u03b5 \u89c4\u5219: \u5f53\u8bed\u8a00\u4e2d\u4e0d\u542b\u6709 \u03b5 \u7b26\u53f7\u4e32, \u5219\u4e00\u5b9a\u5b58\u5728\u7ec8\u7ed3\u7b26\u96c6\u4e0d\u542b\u6709 \u03b5 \u7684\u7b49\u4ef7\u6587\u6cd5(\u4ee3\u5165\u6cd5\u6d88\u9664 \u03b5)"),(0,i.kt)("li",{parentName:"ul"},"\u4fdd\u8bc1\u975e\u7ec8\u7ed3\u7b26 A \u7684\u6709\u6548\u6027: ",(0,i.kt)("inlineCode",{parentName:"li"},"S -*> \u03b1A\u03b2, A -+> t"),".")),(0,i.kt)("h2",{id:"lexical-analysis"},"Lexical Analysis"),(0,i.kt)("h3",{id:"tokenizer---\u8bcd\u6cd5\u5206\u6790\u5668"},"Tokenizer - \u8bcd\u6cd5\u5206\u6790\u5668"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Maximal match"),(0,i.kt)("li",{parentName:"ul"},"Higher priority match")),(0,i.kt)("h4",{id:"\u8f6c\u79fb\u56fe\u7b97\u6cd5"},"\u8f6c\u79fb\u56fe\u7b97\u6cd5"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"token nextToken(void) {\n  char c = getChar();\n  switch(c) {\n    case '<':\n      c = getChar();\n      switch (c) {\n        case '=':\n          return LE;\n        case '>':\n          return NE;\n        default:\n          rollback();\n          return LT;\n      }\n\n    case '=':\n      return EQ;\n    case '>':\n      c = getChar();\n      switch (c) {\n        case '=':\n          return GE;\n        case '<':\n          return NE;\n        default:\n          rollback();\n          return GT;\n      }\n  }\n}\n")),(0,i.kt)("h4",{id:"\u5173\u952e\u5b57keyword\u5904\u7406"},"\u5173\u952e\u5b57(keyword)\u5904\u7406"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6839\u636e \u5b8c\u7f8e\u54c8\u5e0c\u7b97\u6cd5(\u65e0\u51b2\u7a81\u54c8\u5e0c\u51fd\u6570) , \u5efa\u7acb\u6240\u6709\u5173\u952e\u5b57\u5bf9\u5e94\u7684\u5173\u952e\u5b57\u5b8c\u7f8e\u54c8\u5e0c\u8868"),(0,i.kt)("li",{parentName:"ul"},"\u8bfb\u5165\u6709\u6548\u6807\u8bc6\u7b26(\u5b57\u7b26\u4e32\u578b)\u540e, \u67e5\u8be2\u5173\u952e\u5b57\u54c8\u5e0c\u8868, \u68c0\u67e5\u5f53\u524d\u6807\u8bc6\u7b26\u662f\u5426\u4e3a\u5173\u952e\u5b57")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#define KEYWORD_MAX_LEN 10\n\nhash_one(char *str, int len) {\n    unsigned int keyValue = 0;\n\n    for (int i = 0; i < len; i++) {\n        keyValue += str[i] * ((int)pow(33, len - i));\n    }\n\n    keyValue = (keyValue * 3 + 7) % KEYWORD_MAX_LEN;\n  return keyValue;\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#define KEYWORD_HASH_SEED 131\n\nhash_two(char *str, int len) {\n  unsigned int keyValue = 0,\n           hash = 0;\n\n    for (int i = 0; i < len; i++) {\n        hash = hash * KEYWORD_HASH_SEED + str[i];\n    }\n\n    keyValue = hash & 0x7fffffff;\n    return keyValue;\n}\n")),(0,i.kt)("h3",{id:"\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673afinite-automaton"},"\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a(Finite Automaton)"),(0,i.kt)("h4",{id:"\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673adeterministic-finite-automaton"},"\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a(Deterministic Finite Automaton)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Only a transition for a state with a input"),(0,i.kt)("li",{parentName:"ul"},"No epsilon moves")),(0,i.kt)("p",null,"M = (AlphaSet/InputSet, StateSet, currentState, FiniteStateSet, transferFunction)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"A = {a, b}, SS = {0, 1, 2}, cS = 0, FS = {2},\ntransferFunction = {\n  (cS0, a) -> cS1, (cS0, b) -> cS0,\n  (cS1, a) -> cS2, (cS1, b) -> cS1,\n  (cS2, a) -> cS2, (cS2, b) -> cS2,\n}\n")),(0,i.kt)("h5",{id:"\u72b6\u6001\u8f6c\u79fb\u8868\u5b9e\u73b0-dfa"},"\u72b6\u6001\u8f6c\u79fb\u8868\u5b9e\u73b0 DFA"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"\u72b6\u6001\\\u5b57\u7b26"),(0,i.kt)("th",{parentName:"tr",align:"left"},"a"),(0,i.kt)("th",{parentName:"tr",align:"left"},"b"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0"),(0,i.kt)("td",{parentName:"tr",align:"left"},"1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2"),(0,i.kt)("td",{parentName:"tr",align:"left"},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"2"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2")))),(0,i.kt)("h4",{id:"\u975e\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673anondeterministic-finite-automaton"},"\u975e\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a(Nondeterministic Finite Automaton)"),(0,i.kt)("p",null,"transferFunction \u4e2d\u7684\u6b21\u6001\u4e0d\u786e\u5b9a/\u4e0d\u552f\u4e00(\u4e3a\u4e00\u4e2a\u5f00\u96c6\u5408):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Multiple transitions for a state with a input"),(0,i.kt)("li",{parentName:"ul"},"can epsilon moves")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(cS0, a) -> {cS1, cS2}")),(0,i.kt)("h3",{id:"\u81ea\u52a8\u8bcd\u6cd5\u5206\u6790\u5668"},"\u81ea\u52a8\u8bcd\u6cd5\u5206\u6790\u5668"),(0,i.kt)("p",null,"RegExp --Thompson \u7b97\u6cd5--\x3e NFA --\u5b50\u96c6\u6784\u9020\u7b97\u6cd5--\x3e DFA --Hopcroft \u6700\u5c0f\u5316\u7b97\u6cd5--\x3e \u8bcd\u6cd5\u5206\u6790\u5668\u4ee3\u7801"),(0,i.kt)("h4",{id:"thompson-\u7b97\u6cd5"},"Thompson \u7b97\u6cd5"),(0,i.kt)("p",null,"RegExp --\x3e NFA:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u76f4\u63a5\u6784\u9020\u57fa\u672c RegExp"),(0,i.kt)("li",{parentName:"ul"},"\u9012\u5f52\u6784\u9020\u590d\u5408 RegExp"),(0,i.kt)("li",{parentName:"ul"},"epsilon : i --epsilon--\x3e f"),(0,i.kt)("li",{parentName:"ul"},"RegExp : i --NFA(RegExp)--\x3e f"),(0,i.kt)("li",{parentName:"ul"},"\u9009\u62e9 : i --NFA(RegExp1)--\x3e f, i --NFA(RegExp2)--\x3e f"),(0,i.kt)("li",{parentName:"ul"},"\u8fde\u63a5 : i --NFA(RegExp1)--\x3e m --NFA(RegExp2)--\x3e f"),(0,i.kt)("li",{parentName:"ul"},"\u95ed\u5305 : i --epsilon--\x3e m --epsilon--\x3e f, m --RegExp--\x3e m")),(0,i.kt)("h4",{id:"\u5b50\u96c6\u6784\u9020\u7b97\u6cd5"},"\u5b50\u96c6\u6784\u9020\u7b97\u6cd5"),(0,i.kt)("p",null,"NFA --\x3e DFA:"),(0,i.kt)("p",null,"\u7531 Thompson \u7b97\u6cd5\u751f\u6210\u7684 NFA, \u5f53\u4e14\u4ec5\u5f53\u8f93\u5165\u4e3a epsilon \u65f6, \u6b21\u6001\u4e0d\u552f\u4e00"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5c06\u6240\u6709\u53ef\u8fbe\u5230\u6b21\u6001\u4f5c\u4e3a\u4e00\u4e2a\u96c6\u5408 s, \u89c6\u4e3a\u5355\u4e00\u6b21\u6001 s"),(0,i.kt)("li",{parentName:"ul"},"delta(Sigma) + epsilon-closure(\u6df1\u5ea6/\u5e7f\u5ea6\u4f18\u5148\u904d\u5386\u627e\u5bfb\u53ef\u8fbe\u5230\u6b21\u6001\u8fb9\u754c)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"DFA subset_construction(NFA nfa) {\n  s0 = eps_closure(n0);\n\n  StateSet += s0;\n  enqueue(s0);\n\n  while (work_queue != []) {\n    dequeue(s);\n\n    foreach (ch in InputSet) {\n      next_state = eps_closure(delta(s, ch));\n      Fn[s, ch] = next_state;  // DFA \u4e2d\u7684\u8f6c\u79fb\u51fd\u6570\n\n      if (next_state not in StateSet) {\n        StateSet += next_state;\n        enqueue(next_state);\n      }\n    }\n  }\n\n  return DFA(StateSet, Fn);\n}\n")),(0,i.kt)("h4",{id:"hopcroft-\u7b97\u6cd5"},"Hopcroft \u7b97\u6cd5"),(0,i.kt)("p",null,"\u6700\u5c0f\u5316 DFA(\u6570\u5b57\u903b\u8f91\u4e2d\u7684\u6700\u7b80\u72b6\u6001\u8868), \u5408\u5e76\u7b49\u4ef7\u72b6\u6001(\u7b49\u4ef7\u7c7b)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"split(StateSet S) {\n  foreach (char ch) {\n    if (ch can split S) {\n      split S into S1, ..., Sk;\n    }\n  }\n}\n\nhopcroft(DFA) {\n  split all nodes into InitStateSet and FiniteStateSet (Two State Sets);\n\n  while (set is still changes) {\n    split(S);\n  }\n}\n")),(0,i.kt)("h4",{id:"\u5b9e\u73b0"},"\u5b9e\u73b0"),(0,i.kt)("h5",{id:"dfa"},"DFA"),(0,i.kt)("h6",{id:"\u6709\u5411\u56fe"},"\u6709\u5411\u56fe"),(0,i.kt)("h6",{id:"\u8f6c\u79fb\u8868"},"\u8f6c\u79fb\u8868"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u884c: \u73b0\u6001"),(0,i.kt)("li",{parentName:"ul"},"\u5217: \u8f93\u5165"),(0,i.kt)("li",{parentName:"ul"},"\u503c: \u6b21\u6001/ERROR/-1")),(0,i.kt)("p",null,"\u9a71\u52a8\u4ee3\u7801: table \u7528\u4e8e\u5b9e\u73b0 switch/case, stack \u7528\u4e8e\u5b9e\u73b0\u6700\u957f\u5339\u914d"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"next_token() {\n  state = 0;\n  stack = [];\n\n  while (state != ERROR) {\n    c = getChar();\n\n    if (state is ACCEPT/FINITE) {\n      clear(stack);\n    }\n\n    push(state);\n    state = table[state][c];\n  }\n\n  while (state is not ACCEPT/FINITE) {\n    state = pop();\n    rollback();\n  }\n}\n")),(0,i.kt)("h2",{id:"syntax-analysis\u8bed\u6cd5\u5206\u6790"},"Syntax Analysis(\u8bed\u6cd5\u5206\u6790)"),(0,i.kt)("p",null,"Tokens + Grammar --Syntax Analysis--\x3e AST(Abstract Syntax Tree)"),(0,i.kt)("h3",{id:"\u81ea\u9876\u5411\u4e0b\u5206\u6790"},"\u81ea\u9876\u5411\u4e0b\u5206\u6790"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u4ece\u5f00\u59cb\u7b26\u53f7\u51fa\u53d1\u63a8\u5bfc\u4efb\u610f\u53e5\u5b50 t, \u4e0e\u7ed9\u5b9a\u53e5\u5b50 s \u8fdb\u884c\u6bd4\u8f83\u5206\u6790"),(0,i.kt)("li",{parentName:"ul"},"\u5229\u7528\u5206\u6790\u6811\u8fdb\u884c\u9010\u53f6\u5b50\u5339\u914d, \u82e5\u5339\u914d\u5931\u8d25\u5219\u8fdb\u884c\u56de\u6eaf")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"bool top_down_parsing(tokens[]) {\n  i = 0;\n  stack = [S];\n\n  while (stack != []) {\n    if (stack[top] is a terminal t) {\n      t == tokens[i] ? pop(i++) : backtrack();\n    } else if (stack[top] is a non_terminal T) {\n      pop();\n      push(T next expansion); // \u81ea\u53f3\u5411\u5de6\u538b\u6808, e.g pop(S), push(N_right), push(V), push(N_left)\n    } else {\n      throw new SyntaxError();\n    }\n  }\n\n  return i >= tokens.length && is_empty(stack) ? true : false;\n}\n")),(0,i.kt)("h4",{id:"\u907f\u514d\u56de\u6eaf"},"\u907f\u514d\u56de\u6eaf"),(0,i.kt)("p",null,"\u5229\u7528\u524d\u770b\u7b26\u53f7\u907f\u514d\u56de\u6eaf"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Sentence -> Noun Verb Noun\nNoun -> sheep\n  | tiger\n  | grass\n  | water\nVerb -> eat\n  | drink\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"tiger eat water: \u5411\u524d\u770b\u975e\u7ec8\u7ed3\u7b26\u63a8\u5bfc\u51fa\u7684\u6240\u6709\u7ec8\u7ed3\u7b26\u4e2d\u5339\u914d tiger \u7684\u7ec8\u7ed3\u7b26;\n\u4e0d\u5411\u524d\u770b,\u5219\u5148\u63a8\u5bfc N, \u518d\u63a8\u5bfc n, \u4f46 n \u4e0d\u4e00\u5b9a\u5339\u914d tiger, \u5219\u9700\u8fdb\u884c\u56de\u6eaf;\n\u5411\u524d\u770b\u4e00\u4e2a\u5b57\u7b26, \u76f4\u63a5\u63a8\u5bfc N --\x3e n, \u540c\u65f6\u76f4\u63a5\u627e\u5bfb\u5339\u914d tiger \u7684\u7ec8\u7ed3\u7b26")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"S -> N V N\nN -> (sheep)tiger\nV -> eat\nN -> (sheep-tiger-grass)water\n")),(0,i.kt)("h4",{id:"\u9012\u5f52\u4e0b\u964d\u5206\u6790\u7b97\u6cd5recursive-descent\u9884\u6d4b\u5206\u6790\u7b97\u6cd5"},"\u9012\u5f52\u4e0b\u964d\u5206\u6790\u7b97\u6cd5(Recursive Descent/\u9884\u6d4b\u5206\u6790\u7b97\u6cd5)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5206\u6cbb\u7b97\u6cd5: \u6bcf\u4e2a\u975e\u7ec8\u7ed3\u7b26\u6784\u9020\u4e00\u4e2a",(0,i.kt)("strong",{parentName:"li"},"\u5206\u6790\u51fd\u6570")),(0,i.kt)("li",{parentName:"ul"},"\u524d\u770b\u7b26\u53f7: \u7528",(0,i.kt)("strong",{parentName:"li"},"\u524d\u770b\u7b26\u53f7"),"\u6307\u5bfc\u4ea7\u751f\u5f0f\u89c4\u5219\u7684\u9009\u62e9(expansion)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"parse_S(tokens[]) {\n  parse_N(tokens[0]);\n  parse_V(tokens[1]);\n  parse_N(tokens[2]);\n}\n\nparse_N(token) {\n  if (token == s|t|g|w) {\n    return true;\n  } else {\n    throw new SyntaxError();\n  }\n}\n\nparse_V(token) {\n  if (token == e|d) {\n    return true;\n  } else {\n    throw new SyntaxError();\n  }\n}\n")),(0,i.kt)("h5",{id:"\u7b97\u6cd5\u5b9e\u73b0"},"\u7b97\u6cd5\u5b9e\u73b0"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"tip one: use save pointer to implement roll back"),(0,i.kt)("li",{parentName:"ul"},"tip two: use logical OR expression to replace nested if-else structure")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"bool term(TOKEN tok) {\n    return *next++ == tok;\n}\n\nbool E1(void) {\n    return T();\n}\n\nbool E2(void) {\n    return T()\n        && term(PLUS)\n        && E();\n}\n\nbool E(void) {\n    // roll back pointer\n    TOKEN *save = next;\n\n    return (next = save, E1())\n        || (next = save, E2());\n}\n\nbool T1(void) {\n    return term(INT);\n}\n\nbool T2(void) {\n    return term(INT)\n        && term(TIMES)\n        && T();\n}\n\nbool T3(void) {\n    return term(OPEN)\n        && E()\n        && term(CLOSE);\n}\n\nbool T(void) {\n    // roll back pointer\n    TOKEN *save = next;\n\n    return (next = save, T1())\n        || (next = save, T2())\n        || (next = save, T3());\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// X -> a\n//  | XX\n//  | aXXX\n//  | aXXXXb\nparse_X() {\n  token = nextToken();\n\n  switch (token) {\n    case ...: // i: token == atom_char or parse_XX();\n    case ...: // j: token == atom_char, token = nextToken(), parse_XXX();\n    // k: token == atom_char, token = nextToken(),\n    // parse_XXXX(), token=nextToken(), token == b\n    case ...:\n    default: throw new SyntaxError();\n  }\n}\n")),(0,i.kt)("h4",{id:"ll1\u5206\u6790\u7b97\u6cd5"},"LL(1)\u5206\u6790\u7b97\u6cd5"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u4ece\u5de6(L)\u5411\u53f3\u8bfb\u5165\u7a0b\u5e8f(left to right scan)"),(0,i.kt)("li",{parentName:"ul"},"\u6700\u5de6(L)\u63a8\u5bfc: \u4f18\u5148\u63a8\u5bfc\u6700\u5de6\u4fa7\u975e\u7ec8\u7ed3\u7b26(leftmost derivation)"),(0,i.kt)("li",{parentName:"ul"},"\u4e00\u4e2a(1)\u524d\u770b\u7b26\u53f7(look ahead)"),(0,i.kt)("li",{parentName:"ul"},"\u5206\u6cbb\u7b97\u6cd5: \u6bcf\u4e2a\u975e\u7ec8\u7ed3\u7b26\u6784\u9020\u4e00\u4e2a",(0,i.kt)("strong",{parentName:"li"},"first set")," \u548c\u4e00\u4e2a ",(0,i.kt)("strong",{parentName:"li"},"follow set"),", \u6700\u540e\u4e3a\u6bcf\u4e2a\u89c4\u5219\u6784\u9020\u4e00\u4e2a ",(0,i.kt)("strong",{parentName:"li"},"select set")),(0,i.kt)("li",{parentName:"ul"},"\u5206\u6790\u8868\u9a71\u52a8(\u7531 first sets/follow sets/select sets \u63a8\u5bfc\u5206\u6790\u8868)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"bool ll1_parsing(tokens[]) {\n  i = 0;\n  stack = [S];\n\n  while (stack != []) {\n    if (stack[top] is a terminal t) {\n      t == tokens[i] ? pop(i++) : throw new SyntaxError();\n    } else if (stack[top] is a non_terminal T) {\n      pop();\n      // push(T correct expansion);\n      // \u81ea\u53f3\u5411\u5de6\u538b\u6808, e.g pop(S), push(N_right), push(V), push(N_left)\n      push(select_table[T][tokens[i]] \u5bf9\u5e94\u9879(\u89c4\u5219\u7f16\u53f7)\u6240\u5bf9\u5e94\u89c4\u5219\u7684\u53f3\u8fb9\u5f0f\u5b50);\n    } else {\n      throw new SyntaxError();\n    }\n  }\n\n  return i >= tokens.length && is_empty(stack) ? true : false;\n}\n")),(0,i.kt)("h5",{id:"nullable-sets"},"nullable sets"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5b58\u5728\u89c4\u5219: ",(0,i.kt)("inlineCode",{parentName:"li"},"X -> epsilon"),"."),(0,i.kt)("li",{parentName:"ul"},"\u6216\u8005: ",(0,i.kt)("inlineCode",{parentName:"li"},"X -> Y1Y2...Yn"),", \u4e14\u5b58\u5728\u89c4\u5219 ",(0,i.kt)("inlineCode",{parentName:"li"},"Y1 -> epsilon, ..., Yn -> epsilon"),"."),(0,i.kt)("li",{parentName:"ul"},"\u5373 : ",(0,i.kt)("inlineCode",{parentName:"li"},"X -*> epsilon")," (epsilon <- first(X)).")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"nullable = {};\n\nwhile (nullable is still changing) {\n  foreach (production p: X -> beta) {\n    if ((beta == epsilon) || (beta == Y1...Yn\n      && Y1 <- nullable && ... && Yn <- nullable)) {\n      nullable += X;\n    }\n  }\n}\n")),(0,i.kt)("h5",{id:"first-sets"},"first sets"),(0,i.kt)("p",null,"first(X) = {t | X -",(0,i.kt)("em",{parentName:"p"},"> talpha} U {epsilon | X-"),">epsilon} :"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"first(t) = {t}"),(0,i.kt)("li",{parentName:"ul"},"epsilon<-first(X): X -> epsilon or X -> A1...An, epsilon<-first(Ai)"),(0,i.kt)("li",{parentName:"ul"},"first(alpha)<-first(X): X -> A1..Analpha, epsilon<-first(Ai)")),(0,i.kt)("p",null,"first sets \u4e0d\u52a8\u70b9\u7b97\u6cd5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"foreach (non_terminal N) {\n  first(N) = {};\n}\n\nwhile (some sets is changing) {\n  foreach (production p: N->beta1...beta_n) {\n    foreach (beta_i from beta1 up to beta_n) {\n      if (beta_i == a) {\n      // e.g N->abX: first(N) += {a}\n        first(N) += {a};\n        break;\n      } else if (beta_i == M) {\n        first(N) += first(M);\n        if (M is not in nullable) {\n          break;\n        } // else continue this loop to add first(beta_next) into first(N)\n      }\n    }\n  }\n}\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"NonTerminal"),(0,i.kt)("th",{parentName:"tr",align:"left"},"First Set"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"S"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{s, t, g, w}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"N"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{s, t, g, w}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"V"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{e, d}")))),(0,i.kt)("h5",{id:"follow-sets"},"follow sets"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"follow(X) = {t | S -*> beta X t epsilon}"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"for ",(0,i.kt)("inlineCode",{parentName:"li"},"X -> AB"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"first(B) <- follow(A)"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"follow(X) <- follow(B)"),"."),(0,i.kt)("li",{parentName:"ul"},"if ",(0,i.kt)("inlineCode",{parentName:"li"},"B -*> epsilon"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"follow(X) <- follow(A)"),"."))),(0,i.kt)("li",{parentName:"ul"},"for ",(0,i.kt)("inlineCode",{parentName:"li"},"A -> alpha X beta"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"first(beta) - {epsilon} <- follow(X)"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$ <- follow(S)"),".")),(0,i.kt)("p",null,"follow sets \u4e0d\u52a8\u70b9\u7b97\u6cd5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"foreach (non_terminal N) {\n  follow(N) = {};\n}\n\nwhile (some sets is changing) {\n  foreach (production p: N->beta1...beta_n) {\n\n        // temp: follow(left) <- follow(right)\n    temp = follow(N);\n\n    foreach (beta_i from beta_n down to beta1) {\n      if (beta_i == a) {\n        temp = {a};\n      } else if (beta_i == M) {\n        follow(M) += temp\n        temp = (M is not nullable) ? (first(M)) : (temp + first(M))\n      }\n    }\n  }\n}\n")),(0,i.kt)("h5",{id:"select-sets"},"select sets"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5f53 N -> Y1...Yn \u53f3\u8fb9 Y \u5168\u4e3a nullable \u65f6, select(p) += follow(N)")),(0,i.kt)("p",null,"select sets \u4e0d\u52a8\u70b9\u7b97\u6cd5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"foreach (production p) {\n  select(p) = {}\n}\n\ncalculate_select_set(production p: N->beta1...beta_n) {\n  foreach (beta_i from beta1 up to beta_n) {\n    if (beta_i == a) {\n      select(p) += {a};\n      break;\n    } else if (beta_i == M) {\n      select(p) += first(M);\n      if (M is not in nullable) {\n        break;\n      }\n    }\n  }\n\n  // all betas are in nullable (\u5f53\u524d\u89c4\u5219\u7684\u6240\u6709\u53f3\u8fb9\u7b26\u53f7\u90fd\u662f\u53ef\u7a7a\u96c6)\n  //\u3000\u6545, select(p) \u5fc5\u987b\u5305\u62ec follow(M) (\u5f53\u63a8\u5bfc\u51fa\u53f3\u8fb9\u7b26\u53f7\u90fd\u4e3a\u7a7a\u65f6, first(p) \u5373\u4e3a follow(M))\n  if (i > n) {\n    first(N) += follow(N);\n  }\n}\n")),(0,i.kt)("h5",{id:"\u5206\u6790\u8868"},"\u5206\u6790\u8868"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u7ed3\u5408 nullable sets \u51c6\u786e\u6c42\u51fa first sets"),(0,i.kt)("li",{parentName:"ul"},"\u518d\u5229\u7528 first sets \u51c6\u786e\u6c42\u51fa follow sets"),(0,i.kt)("li",{parentName:"ul"},"\u518d\u5229\u7528 first sets, \u5e76\u7ed3\u5408 follow sets(\u5168\u7a7a\u96c6\u4fee\u6b63) \u51c6\u786e\u6c42\u51fa \u5206\u6790\u8868:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"0: z -> d\n1: | X Y Z\n2: Y -> c\n3: |\n4: X -> Y\n5: | a\n")),(0,i.kt)("p",null,"nullable = {X, Y}"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"}),(0,i.kt)("th",{parentName:"tr",align:"left"},"X"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Y"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Z"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"first"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a, c}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{c}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a, c, d}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"follow"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a, c, d}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a, c, d}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{}")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"production"),(0,i.kt)("th",{parentName:"tr",align:"left"},"0"),(0,i.kt)("th",{parentName:"tr",align:"left"},"1"),(0,i.kt)("th",{parentName:"tr",align:"left"},"2"),(0,i.kt)("th",{parentName:"tr",align:"left"},"3"),(0,i.kt)("th",{parentName:"tr",align:"left"},"4"),(0,i.kt)("th",{parentName:"tr",align:"left"},"5"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"select"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{d}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a, c, d}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{c}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a, c, d}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a, c, d}"),(0,i.kt)("td",{parentName:"tr",align:"left"},"{a}")))),(0,i.kt)("p",null,"|Non\\Terminal|a|c|d|\n|Z|1|1|0, 1|\n|Y|3|2, 3|3|\n|X|4, 5|4|4|"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u6570\u5b57\u4e3a\u89c4\u5219\u7f16\u53f7")),(0,i.kt)("h5",{id:"\u89e3\u51b3\u51b2\u7a81\u5206\u6790\u8868\u67d0\u9879\u6709\u591a\u4e2a\u7f16\u53f7"},"\u89e3\u51b3\u51b2\u7a81(\u5206\u6790\u8868\u67d0\u9879\u6709\u591a\u4e2a\u7f16\u53f7)"),(0,i.kt)("p",null,"\u901a\u8fc7\u6587\u6cd5\u91cd\u5199\u6d88\u9664\u5de6\u9012\u5f52, \u4f7f\u6587\u6cd5\u9002\u5e94 L(\u6700\u5de6\u63a8\u5bfc):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6539\u5199\u6210\u53f3\u9012\u5f52\u6587\u6cd5"),(0,i.kt)("li",{parentName:"ul"},"\u89c4\u5b9a\u4f18\u5148\u7ea7\u4e0e\u7ed3\u5408\u6027"),(0,i.kt)("li",{parentName:"ul"},"\u63d0\u53d6\u5de6\u516c\u56e0\u5f0f(Common Prefix)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"E -> T+E\n    |T\n\nE -> TX\nX -> +E\n    |epsilon\n")),(0,i.kt)("h6",{id:"\u6d88\u9664\u76f4\u63a5\u5de6\u9012\u5f52"},"\u6d88\u9664\u76f4\u63a5\u5de6\u9012\u5f52"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"S -> Salpha1\n    |Salpha2\n    ...\n    |Salpha_n\n    |beta1\n    |beta2\n    ...\n    |beta_m\n\nS -> beta1S'\n    |beta2S'\n    ...\n    |beta_nS'\nS'-> alpha1S'\n    |alpha2S'\n    ...\n    |alpha_nS'\n    |epsilon\n")),(0,i.kt)("h6",{id:"\u6d88\u9664\u95f4\u63a5\u5de6\u9012\u5f52"},"\u6d88\u9664\u95f4\u63a5\u5de6\u9012\u5f52"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u628a\u6587\u6cd5 G \u7684\u6240\u6709\u975e\u7ec8\u7ed3\u7b26\u6309\u4efb\u4e00\u987a\u5e8f\u6392\u5217, e.g A1, A2, \u2026, An"),(0,i.kt)("li",{parentName:"ul"},"\u6d88\u9664 Ai \u89c4\u5219\u4e2d\u7684\u76f4\u63a5\u5de6\u9012\u5f52: \u628a\u5f62\u5982 Ai\u2192Aj\u03b3 \u7684\u4ea7\u751f\u5f0f\n\u6539\u5199\u6210 Ai\u2192\u03b41\u03b3 /\u03b42\u03b3 /\u2026/\u03b4k\u03b3(\u5176\u4e2d Aj\u2192\u03b41 /\u03b42 /\u2026/\u03b4k \u662f\u5173\u4e8e\u7684 Aj \u5168\u90e8\u89c4\u5219)"),(0,i.kt)("li",{parentName:"ul"},"\u53bb\u6389\u591a\u4f59\u7684\u89c4\u5219(\u4e0d\u53ef\u8fbe\u89c4\u5219)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nstruct WF {\n    string left; //\u5b9a\u4e49\u4ea7\u751f\u5f0f\u7684\u5de6\u90e8\n    string right; //\u5b9a\u4e49\u4ea7\u751f\u5f0f\u7684\u53f3\u90e8\n};\n\n/*\n * count: number of non-terminal symbols\n */\nvoid Removing(WF *p,char *q,int n,int count) {\n\n    int count1 = n;\n    int flag = 0;\n\n  // \u5224\u65ad\u7b2c\u4e00\u4e2a\u975e\u7ec8\u7ed3\u7b26\u662f\u5426\u5b58\u5728\u76f4\u63a5\u5de6\u9012\u5f52 if(p[i].left[0]==q[0])\n    for (int i = 0; i < n; i++) {\n        if (p[i].left[0] == p[i].right[0]) {\n            flag++;\n        }\n    }\n\n  // \u5982\u679c\u5b58\u5728\u76f4\u63a5\u5de6\u9012\u5f52\u5219\u6d88\u9664\u76f4\u63a5\u5de6\u9012\u5f52\n    if (flag != 0)\n    {\n        for (int i = 0; i < n; i++) {\n            if (p[i].left[0] == q[0]) {\n                if (p[i].left[0] == p[i].right[0]) {\n                  string str;\n                    str = p[i].right.substr(1,int (p[i].right.length())); // \u53d6\u53f3\u90e8\u7b2c\u4e8c\u4f4d\u5f00\u59cb\u7684\u5b57\u4e32\u8d4b\u7ed9str\n\n                    // E->E+T => E\'->+TE\'\n                    string temp = p[i].left;\n                    string temp1 = "\'";\n                    p[i].left = temp+temp1;\n                    p[i].right = str+p[i].left;\n                } else {\n                    // E->T => E->TE\'\n                    string temp=p[i].left;\n                    string temp1="\'";\n                    temp=temp+temp1;\n                    p[i].right=p[i].right+temp;\n                }\n            }\n        }\n\n        string str="\'";\n        p[count1].left=p[0].left[0]+str;\n        p[count1].right="\u03b5";\n    }\n\n\n  // \u5bf9\u6bcf\u4e00\u4e2a\u975e\u7ec8\u7ed3\u7b26\u8fed\u4ee3\n    for ( int i = 0; i <= count; i++) {\n\n      // \u5bf9\u6bcf\u4e00\u4e2a\u5c0f\u4e8e i \u7684\u975e\u7ec8\u7ed3\u7b26\n        for (int j = 0; j < i; j++) {\n\n          // \u5bf9\u6bcf\u4e00\u4e2a\u4ea7\u751f\u5f0f\n            for (int g = 0; g < n; g++) {\n\n              // i \u975e\u7ec8\u7ed3\u7b26\u4e0e\u7b2c g \u4ea7\u751f\u5f0f\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u76f8\u7b49\n                if (q[i] == p[g].left[0]) {\n\n          // g \u4ea7\u751f\u5f0f\u53f3\u8fb9\u4ea7\u751f\u5f0f\u7b2c\u4e00\u4e2a\u7b26\u53f7\u4e0e\u7b2c j \u4e2a\u975e\u7ec8\u7ed3\u7b26\u76f8\u7b49\n                    if (p[g].right[0] == q[j]) {\n                        for (int h = 0; h < n*n; h++) {\n                            if (p[h].left[0] == q[j]\n                              && int (p[h].left.length()) == 1) {\n                                string str;\n                                str = p[g].right.substr(\n                                  1,\n                                  int (p[g].right.length ()));\n                                p[++count1].left = p[g].left;\n                                p[count1].right = p[h].right + str;\n                            }\n                        }\n\n                        p[g].left="";\n                        p[g].right="";\n                    }\n                }\n            }\n        }\n    }\n\n  // \u53bb\u9664\u95f4\u63a5\u9012\u5f52\u4ea7\u751f\u5f0f\n    for(int i = 0; i <= count; i++) {\n        flag = 0;\n\n        for (int j = 0; j < n*n; j++) {\n            if (p[j].left[0] == q[i]) {\n                if(p[j].left[0] == p[j].right[0]) {\n                    flag++;\n                }\n            }\n        }\n\n        if (flag != 0) {\n            for (int j = 0; j <= n*n; j++) {\n                if (p[j].left[0] == q[i]) {\n                    if (p[j].left[0] == p[j].right[0]) {\n                        string str;\n                        str = p[j].right.substr(1,int (p[j].right.length()));\n                        string temp = p[j].left;\n                        string temp1 = "\'";\n                        p[j].left = temp + temp1;\n                        p[j].right = str + p[j].left;\n                    } else {\n                        string temp = p[j].left;\n                        string temp1 = "\'";\n                        temp = temp + temp1;\n                        p[j].right = p[j].right + temp;\n                    }\n                }\n            }\n\n            string str = "\'";\n            p[++count1].left = q[i] + str;\n            p[count1].right = "\u03b5";\n        }\n    }\n}\n\nint Delete(WF *p,int n) {\n    return 0;\n}\n\nint main() {\n    ofstream OutFile("result.txt");\n\n    int i,\n      j,\n      flag = 0,\n      count = 1,\n      n;\n\n    cout<<"\u8bf7\u8f93\u5165\u6587\u6cd5\u4ea7\u751f\u5f0f\u4e2a\u6570n\uff1a"<<endl;\n    cin>>n;\n    WF *p=new WF[50];\n    cout<<"\u8bf7\u8f93\u5165\u6587\u6cd5\u7684\u4e2a\u4ea7\u751f\u5f0f\uff1a"<<endl;\n\n  // input productions\n    for (i = 0; i < n; i++) {\n        cin>>p[i].left;\n        cout<<"->"<<endl;\n        cin>>p[i].right;\n        cout<<endl;\n    }\n    cout<<endl;\n    OutFile<<"\u5373\u8f93\u5165\u7684\u6587\u6cd5\u4ea7\u751f\u5f0f\u4e3a\uff1a"<<endl;\n\n    // cout<<"\u5373\u8f93\u5165\u7684\u6587\u6cd5\u4ea7\u751f\u5f0f\u4e3a\uff1a"<<endl;\n    for (i = 0; i < n; i++) {\n        // cout<<p[i].left<<"--\x3e"<<p[i].right<<endl;\n        OutFile<<p[i].left<<"--\x3e"<<p[i].right<<endl;\n    }\n    OutFile<<"*********************"<<endl;\n\n    // cout<<"*********************"<<endl;\n    char q[20];    // \u5bf9\u4ea7\u751f\u5f0f\u7684\u975e\u7ec8\u7ed3\u7b26\u6392\u5e8f\u5e76\u5b58\u53d6\u5728\u5b57\u7b26\u6570\u7ec4q\n    q[0] = p[0].left[0]; // \u628a\u4ea7\u751f\u5f0f\u7684\u7b2c\u4e00\u4e2a\u975e\u7ec8\u7ed3\u7b26\u5b58\u5165q\u4e2d\n\n  // \u5bf9\u975e\u7ec8\u7ed3\u7b26\u6392\u5e8f\u5e76\u5b58\u53d6\n    for (i = 1; i < n; i++) {\n        flag = 0;\n        for (j = 0; j < i; j++) {\n      // \u6839\u636ej<i\u5faa\u73af\u907f\u514d\u91cd\u590d\u975e\u7ec8\u7ed3\u7b26\u56e0\u6b64\u7531\u6807\u5fd7\u4f4d\u5224\u65ad\n            if(p[i].left==p[j].left) {\n              flag++;\n            }\n        }\n\n        if(flag==0) {\n          // \u6ca1\u6709\u91cd\u590d\u52a0\u5165q\u6570\u7ec4\u4e2d\n            q[count++]=p[i].left[0];\n        }\n    }\n    count--;\n\n  // \u8c03\u7528\u6d88\u9664\u9012\u5f52\u5b50\u51fd\u6570\n    Removing(p,q,n,count);\n    // \u5220\u9664\u65e0\u7528\u4ea7\u751f\u5f0f\n    Delete(p,n);\n\n    OutFile<<"\u6d88\u9664\u9012\u5f52\u540e\u7684\u6587\u6cd5\u4ea7\u751f\u5f0f\u4e3a\uff1a"<<endl;\n    // cout<<"\u6d88\u9664\u9012\u5f52\u540e\u7684\u6587\u6cd5\u4ea7\u751f\u5f0f\u4e3a\uff1a"<<endl;\n    for (i = 0; i <= count; i++) {\n        for (int j = 0; j <= n*n; j++) {\n            if ((p[j].left[0] == q[i]) && int (p[j].left.length ()) == 1) {\n                OutFile<<p[j].left<<"--\x3e"<<p[j].right<<endl;\n        // cout<<p[j].left<<"--\x3e"<<p[j].right<<endl;\n            } else {\n              continue;\n            }\n        }\n\n        for (j = 0; j <= n*n; j++) {\n            if((p[j].left[0] == q[i]) && int (p[j].left.length ()) == 2) {\n                OutFile<<p[j].left<<"--\x3e"<<p [j].right<<endl;\n            // cout<<p[j].left<<"--\x3e"<<p[j].right<<endl;\n            } else {\n              continue;\n            }\n        }\n    }\n    return 0;\n}\n')),(0,i.kt)("h5",{id:"\u975e-ll1-\u6587\u6cd5\u8bed\u8a00"},"\u975e LL(1) \u6587\u6cd5/\u8bed\u8a00"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"ambiguous grammar"),(0,i.kt)("li",{parentName:"ul"},"left recursive grammar"),(0,i.kt)("li",{parentName:"ul"},"not left factored grammar(\u672a\u63d0\u53d6\u5c55\u5f00\u5f0f\u7684\u516c\u56e0\u5b50)")),(0,i.kt)("h3",{id:"\u81ea\u5e95\u5411\u4e0a\u5206\u6790"},"\u81ea\u5e95\u5411\u4e0a\u5206\u6790"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"0: S -> E\n1: E -> E + T\n2: | T\n3: T -> T * F\n4: | F\n5: F -> n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"2 + 3 * 4\n=> F + 3 * 4\n=> T + 3 * 4\n=> E + 3 * 4\n=> E + T * 4\n=> E + T * F\n=> E + T\n=> E\n=> S\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u6700\u53f3\u63a8\u5bfc(\u4f18\u5148\u63a8\u5bfc\u6700\u53f3\u4fa7\u975e\u7ec8\u7ed3\u7b26)\u9006\u8fc7\u7a0b")),(0,i.kt)("h4",{id:"lr0-\u5206\u6790\u7b97\u6cd5"},"LR(0) \u5206\u6790\u7b97\u6cd5"),(0,i.kt)("p",null,"\u79fb\u8fdb-\u5f52\u7ea6 (Reduce) \u7b97\u6cd5:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u4ece\u5de6\u5411\u53f3\u8bfb\u5165\u7a0b\u5e8f (left to right scan), \u9006\u5411\u6700\u53f3\u63a8\u5bfc (rightmost derivation), \u4e0d\u7528\u524d\u770b\u7b26\u53f7."),(0,i.kt)("li",{parentName:"ul"},"\u6dfb\u52a0\u4f2a\u5f00\u59cb\u7b26\u53f7: ",(0,i.kt)("inlineCode",{parentName:"li"},"S' -> . S$"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"$")," \u8868\u793a tokens/file \u7ed3\u675f\u7b26."),(0,i.kt)("li",{parentName:"ul"},"\u79fb\u8fdb : \u8bfb\u5165\u8bb0\u53f7 ",(0,i.kt)("inlineCode",{parentName:"li"},"push(token[i])"),"."),(0,i.kt)("li",{parentName:"ul"},"\u5f52\u7ea6 (Reduce): ",(0,i.kt)("inlineCode",{parentName:"li"},"pop(right expansion)")," ",(0,i.kt)("inlineCode",{parentName:"li"},"push(left expansion)"),".")),(0,i.kt)("h5",{id:"\u77ed\u8bed"},"\u77ed\u8bed"),(0,i.kt)("p",null,"Handles:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"S -*> \u03b1X\u03c9 -> \u03b1\u03b2\u03c9\n")),(0,i.kt)("p",null,"\u03b2 \u662f \u03b1\u03b2\u03c9 \u7684\u4e00\u4e2a\u77ed\u8bed (Handle)."),(0,i.kt)("h5",{id:"\u5206\u6790\u8868\u6784\u9020"},"\u5206\u6790\u8868\u6784\u9020"),(0,i.kt)("p",null,"LR(0) \u5206\u6790\u8868\u6784\u9020\u7b97\u6cd5: (\u539f\u7406\u540c\u4e8e Hopcroft \u7b97\u6cd5)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"E -> A, A -> B, B -> C ... :\nRecursively, right hand side of C production will be reduced to E finally")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"closure(production_set p) {\n  while (p is still changing) {\n    foreach (p's item i: A -> b . B ...) {\n      p += {B -> . y...}\n    }\n  }\n}\n\ngoto(production_set p, token x) {\n  temp = {}\n\n  foreach (p's item i: A -> b . x...) {\n    temp += {A -> bx . ...}\n  }\n\n  return closure(temp)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"p0 = closure(S'' -> . S $)\n(production_with_dot_)set = {p0}\nQ = enqueue(p0)\n\nwhile (Q is not empty) {\n  p = dequeue(Q)\n\n  foreach (x <- NonTerminal||Terminal) {\n    q = goto(p, x)\n\n    if (x <- Terminal) {\n      ACTION[p, x] = q\n    } else {\n      GOTO[p, x] = q\n    }\n\n    if (q not <- set) {\n      set += {q}\n      enqueue(q)\n    }\n  }\n}\n")),(0,i.kt)("h5",{id:"\u9a71\u52a8\u4ee3\u7801"},"\u9a71\u52a8\u4ee3\u7801"),(0,i.kt)("p",null,"LR(0) \u9a71\u52a8\u7b97\u6cd5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"stack[];\npush($)\npush(state1)\n\nwhile (true) {\n  token t = nextToken()\n  state s = stack[top]\n\n  if (ACTION[s, t] == shift_i) {\n    push(t)\n    push(state_i)\n  } else if (ACTION[s, t] == reduce_j) {\n    // X is the left side of production j: X->beta\n    // beta is the right side of production j: X->beta\n\n    // pop up right side\n    pop(beta && bundle state variables)\n\n    // current state after pop up all bundle state(of beta)\n    state s = stack[top]\n\n    // push left side\n    push(X)\n\n    // transfer state after reduce\n    push(GOTO[s, X])\n  } else {\n    throw new SyntaxError();\n  }\n}\n")),(0,i.kt)("h5",{id:"\u89e3\u51b3\u51b2\u7a81"},"\u89e3\u51b3\u51b2\u7a81"),(0,i.kt)("p",null,"SLR, LR(1), LALR,\n\u91c7\u53d6\u4e0e first/follow/select sets \u4ee5\u53ca \u524d\u770b\u7b26\u53f7 \u7c7b\u4f3c\u7b56\u7565:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"production_with_dot_set")," \u4e2d\u7684 item \u4fee\u6539\u4e3a ",(0,i.kt)("inlineCode",{parentName:"li"},"X -> [beta1 . beta_n..., a]")," \u4e8c\u5143\u7ec4"),(0,i.kt)("li",{parentName:"ul"},"closure(production_set p) \u4e2d\u95ed\u5305\u89c4\u5219\u4ece ",(0,i.kt)("inlineCode",{parentName:"li"},"X -> [a . Y beta,a]"),"\n\u4fee\u6539\u4e3a ",(0,i.kt)("inlineCode",{parentName:"li"},"Y -> [.y, b]")," b <- select(beta a)")),(0,i.kt)("h4",{id:"lalr-k"},"LALR-K"),(0,i.kt)("p",null,"LALR(k)"),(0,i.kt)("h4",{id:"slr"},"SLR"),(0,i.kt)("p",null,"Simple LR: improves LR(k) shift/reduce heuristic"),(0,i.kt)("p",null,"New reduce rule:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"state contains item X -> \u03b2."),(0,i.kt)("li",{parentName:"ul"},"next_token <- follow(X)")),(0,i.kt)("h5",{id:"slr-\u5b9e\u73b0"},"SLR \u5b9e\u73b0"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"stack pair: ",(0,i.kt)("inlineCode",{parentName:"li"},"<input, state>")),(0,i.kt)("li",{parentName:"ul"},"state i: if has item X -> \u03b1.a\u03b2 ,\ngoto","[i, a]"," = j then action","[i, a]"," = shift j(shift then to state j)"),(0,i.kt)("li",{parentName:"ul"},"state i: if has item ",(0,i.kt)("inlineCode",{parentName:"li"},"X -> \u03b1.")," , ",(0,i.kt)("inlineCode",{parentName:"li"},"a <- follow(X)"),"\nthen ",(0,i.kt)("inlineCode",{parentName:"li"},"action[i, a] = reduce(X -> \u03b1)")),(0,i.kt)("li",{parentName:"ul"},"state i: if has item S' -> S then action","[i, $]"," = accept"),(0,i.kt)("li",{parentName:"ul"},"otherwise: action","[i, a]"," = error")),(0,i.kt)("h3",{id:"\u62bd\u8c61\u8bed\u6cd5\u6811"},"\u62bd\u8c61\u8bed\u6cd5\u6811"),(0,i.kt)("h4",{id:"\u8bed\u6cd5\u5236\u5bfc\u7ffb\u8bd1syntax-directed-translation"},"\u8bed\u6cd5\u5236\u5bfc\u7ffb\u8bd1(Syntax-Directed Translation)"),(0,i.kt)("p",null,"\u5728\u8fdb\u884c\u5f52\u7ea6(reduce)\u7684\u540c\u65f6, \u8fdb\u884c\u8bed\u4e49\u52a8\u4f5c:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u7ed9\u6bcf\u6761\u4ea7\u751f\u89c4\u5219\u9644\u52a0\u4e00\u4e2a\u8bed\u4e49\u52a8\u4f5c")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bison"},"exp : exp '+' exp { $$ = $1 + $3; }\n;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5728\u5206\u6790\u6808\u4e2d\u538b\u5165 symbol, value, state (\u539f\u672c\u53ea\u538b\u5165 symbol, state)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"push(right side symbol);\npush(right side value);\npush(next state);\n")),(0,i.kt)("h4",{id:"\u62bd\u8c61\u8bed\u6cd5"},"\u62bd\u8c61\u8bed\u6cd5"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u8868\u8fbe\u8bed\u6cd5\u7ed3\u6784\u7684\u5185\u90e8\u8868\u793a, \u4f5c\u4e3a\u524d\u7aef(\u8bcd\u6cd5\u8bed\u6cd5\u5206\u6790)\u548c\u540e\u7aef(\u4ee3\u7801\u751f\u6210)\u7684\u4e2d\u95f4\u4ef6, tokens --\u8bed\u6cd5\u5206\u6790\u5668--\x3e \u62bd\u8c61\u8bed\u6cd5(\u6811) --\u4ee3\u7801\u751f\u6210\u5668--\x3e \u76ee\u6807\u4ee3\u7801"),(0,i.kt)("li",{parentName:"ul"},"\u62bd\u8c61\u8bed\u6cd5\u65e0\u9700\u8003\u8651\u5de6/\u53f3\u9012\u5f52, \u5de6\u516c\u56e0\u5b50\u63d0\u53d6, \u5206\u9694\u7b26\u7b49")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// \u5177\u4f53\u8bed\u6cd5\nE: E + T\n | T\n ;\nT: T * F\n | F\n ;\nF: n\n | (E)\n ;\n\n// \u62bd\u8c61\u8bed\u6cd5\nE: n\n | E + E\n | E * E\n")),(0,i.kt)("h4",{id:"ast-\u7684\u5b9e\u73b0"},"AST \u7684\u5b9e\u73b0"),(0,i.kt)("h5",{id:"\u6570\u636e\u7ed3\u6784"},"\u6570\u636e\u7ed3\u6784"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"E: n\n | E + E\n | E * E\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"enum kind {\n  E_INT,\n  E_ADD,\n  E_TIMES\n};\n\nstruct exp {\n  enum kind kind;\n};\n\nstruct exp_int {\n  enum kind kind;\n  int value;\n};\n\nstruct exp_add {\n  enum kind kind;\n  struct exp *left;\n  struct exp *right;\n};\n\nstruct exp_times {\n  enum kind kind;\n  struct exp *left;\n  struct exp *right;\n};\n\nstruct exp_int *new_exp_int(int value) {\n  struct exp_int *p = (struct exp_int *)malloc(sizeof(struct exp_int));\n  if (!p) throw new Error();\n  p->kind = E_INT;\n  p->value = value;\n  return p;\n}\n\nstruct exp_add *new_exp_add(exp *left, exp *right) {\n  struct exp_add *p = (struct exp_add *)malloc(sizeof(struct exp_add));\n  if (!p) throw new Error();\n  p->kind = E_ADD;\n  p->left = left;\n  p->right = right;\n  return p;\n}\n\nstruct exp_times *new_exp_times(exp *left, exp *right) {\n  struct exp_times *p = (struct exp_times *)malloc(sizeof(struct exp_times));\n  if (!p) throw new Error();\n  p->kind = E_TIMES;\n  p->left = left;\n  p->right = right;\n  return p;\n}\n")),(0,i.kt)("h5",{id:"\u76f8\u5173\u7b97\u6cd5"},"\u76f8\u5173\u7b97\u6cd5"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'int nodes_num(exp *e) {\n  switch (e->kind) {\n    case E_INT:\n      return 1;\n    case E_ADD: // fall through\n    case E_TIMES:\n      return 1 + nodes_num(e->left) + nodes_num(e->right);\n    default:\n      throw new SyntaxError("compile bug");\n  }\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'int pretty_print(exp *e) {\n  switch (e->kind) {\n    case E_INT:\n      printf("%d", e->value);\n      return 1;\n    case E_ADD:\n      printf("(");\n      pretty_print(e->left);\n      printf(")");\n      printf("+");\n      printf("(");\n      pretty_print(e->right);\n      printf(")");\n      return 1;\n    case E_TIMES:\n      printf("(");\n      pretty_print(e->left);\n      printf(")");\n      printf("*");\n      printf("(");\n      pretty_print(e->right);\n      printf(")");\n      return 1;\n    default:\n      throw new SyntaxError();\n      break;\n  }\n}\n')),(0,i.kt)("h5",{id:"\u6784\u9020\u7b97\u6cd5"},"\u6784\u9020\u7b97\u6cd5"),(0,i.kt)("p",null,"\u5229\u7528\u8bed\u6cd5\u5236\u5bfc\u7ffb\u8bd1, \u5728\u8bed\u6cd5\u52a8\u4f5c(action)/\u8bed\u6cd5\u5f52\u7ea6(reduce)\u4e2d\u52a0\u5165\u751f\u6210\u8bed\u6cd5\u6811\u7684\u4ee3\u7801(\u81ea\u5e95(\u53f6\u5b50)\u5411\u4e0a(\u6839)\u6784\u9020\u51fd\u6570)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"E: E + E { $$ = new_exp_add($1, $3); }\n | E * E { $$ = new_exp_times($1, $3); }\n | n     { $$ = new_exp_int($1); }\n ;\n")),(0,i.kt)("h2",{id:"semantic-analysis\u8bed\u4e49\u5206\u6790"},"Semantic Analysis(\u8bed\u4e49\u5206\u6790)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u58f0\u660e\u68c0\u67e5(identifiers declaration)"),(0,i.kt)("li",{parentName:"ul"},"\u5b9a\u4e49\u68c0\u67e5:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"class \u4ec5\u53ef\u5b9a\u4e49\u4e00\u6b21"),(0,i.kt)("li",{parentName:"ul"},"method \u5728\u540c\u4e00 class \u4e2d\u4ec5\u53ef\u5b9a\u4e49\u4e00\u6b21"))),(0,i.kt)("li",{parentName:"ul"},"\u7c7b\u578b\u68c0\u67e5(types)"),(0,i.kt)("li",{parentName:"ul"},"\u4f5c\u7528\u57df\u68c0\u67e5"),(0,i.kt)("li",{parentName:"ul"},"\u7ee7\u627f\u5173\u7cfb(inheritance relationships)"),(0,i.kt)("li",{parentName:"ul"},"\u4e0a\u4e0b\u6587",(0,i.kt)("strong",{parentName:"li"},"\u76f8\u5173"),"\u5206\u6790(\u68c0\u67e5\u62bd\u8c61\u8bed\u6cd5\u6811\u4e0a\u4e0b\u6587\u76f8\u5173\u7684\u5c5e\u6027)")),(0,i.kt)("p",null,"AST + semantic of programming language --semantic analysis--\x3e intermediate"),(0,i.kt)("p",null,"e.g \u53d8\u91cf/\u51fd\u6570\u5fc5\u987b\u5148\u58f0\u660e\u518d\u4f7f\u7528; \u6bcf\u4e2a\u8868\u8fbe\u5f0f\u5fc5\u987b\u6709\u5408\u9002\u7c7b\u578b(\u5de6\u503c/\u53f3\u503c); \u51fd\u6570\u8c03\u7528\u4e0e\u51fd\u6570\u5b9a\u4e49\u4fdd\u6301\u4e00\u81f4(\u51fd\u6570\u7b7e\u540d)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"P: D S\n ;\n\nD: T id ';' D\n |\n ;\n\nT: int\n | bool\n ;\n\nS: id = E\n | printi (E)\n | printb (E)\n ;\n\nE: n\n | id\n | true\n | false\n | E + E\n | E && E\n ;\n")),(0,i.kt)("h3",{id:"\u7c7b\u578b\u7cfb\u7edftype-system"},"\u7c7b\u578b\u7cfb\u7edf(type system)"),(0,i.kt)("h4",{id:"type-checking"},"Type Checking"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"\u251c e: T")," meas e \u53ef\u8ba1\u7b97\u4e3a\u7c7b\u578b\u4e3a T \u7684\u503c"),(0,i.kt)("h4",{id:"type-environments"},"Type Environments"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Object(identifier) = Type"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"O")," Type environments \u662f\u4e00\u4e2a\u51fd\u6570, \u5c06 object identifiers \u6620\u5c04\u6210 types"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"O \u251c e: T")," \u8868\u793a\u5728 O \u51fd\u6570\u4f5c\u7528\u4e0b, \u53ef\u8bc1\u660e e \u7684\u7c7b\u578b\u4e3a T")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// input x\n// output T\nO[T/x](x) = T\n\nO[T/x](y) = O(y)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"[Var]\nO(x) = T\n----------\nO \u251c x: T\n\n[Let without Init]\nO[T0/x] \u251c e1: T1\n--------------------\nO \u251c let x: T0 in e1: T1\n")),(0,i.kt)("h4",{id:"typing-methods"},"Typing Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Method(ClassName, functionName) = (Type1, ..., Type_n, Type_n+1)"),(0,i.kt)("li",{parentName:"ul"},"Type_n+1 \u4e3a\u8fd4\u56de\u503c\u7684\u7c7b\u578b, \u5373\u65b9\u6cd5\u81ea\u8eab\u7684\u7c7b\u578b")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"[Dispatch]\nO,M \u251c e0: T0\nO,M \u251c e1: T1\n...\nO,M \u251c en: Tn\nM(T0, func) = (T1', ..., Tn', Tn+1')\nTi <= Ti'\n----------\nO,M \u251c e0.func(e1, ..., en): Tn+1'\n")),(0,i.kt)("h3",{id:"\u7b26\u53f7\u8868\u4e0a\u4e0b\u6587\u76f8\u5173"},"\u7b26\u53f7\u8868(\u4e0a\u4e0b\u6587\u76f8\u5173)"),(0,i.kt)("p",null,"\u7528\u6765\u5b58\u50a8\u7a0b\u5e8f\u4e2d\u53d8\u91cf\u7684\u76f8\u5173\u4fe1\u606f:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u7c7b\u578b: \u5b57\u5178\u7ed3\u6784 (key, type)"),(0,i.kt)("li",{parentName:"ul"},"\u4f5c\u7528\u57df:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"\u8fdb\u5165\u4f5c\u7528\u57df, \u63d2\u5165\u5143\u7d20(\u63d2\u5165\u54c8\u5e0c\u8868\u9996, \u5c4f\u853d\u5916\u90e8\u540c\u540d\u53d8\u91cf); \u79bb\u5f00\u4f5c\u7528\u57df, \u5220\u9664\u5143\u7d20"),(0,i.kt)("li",{parentName:"ul"},"\u8fdb\u5165\u4f5c\u7528\u57df, \u538b\u5165\u65b0\u7b26\u53f7\u8868; \u79bb\u5f00\u4f5c\u7528\u57df, \u5f39\u51fa\u6808\u9876\u7b26\u53f7\u8868"))),(0,i.kt)("li",{parentName:"ul"},"\u8bbf\u95ee\u63a7\u5236\u6743"),(0,i.kt)("li",{parentName:"ul"},"\u547d\u540d\u7a7a\u95f4: \u53d8\u91cf, \u6807\u7b7e, \u5f62\u53c2, \u6807\u53f7 \u5404\u81ea\u62e5\u6709\u4e00\u7c7b\u7b26\u53f7\u8868")),(0,i.kt)("p",null,"\u53ef\u5c06\u7b26\u53f7\u8868\u5b9e\u73b0\u4e3a:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u54c8\u5e0c\u8868: \u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6 O(1);"),(0,i.kt)("li",{parentName:"ul"},"\u7ea2\u9ed1\u6811: \u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6 O(lg N);")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#ifndef XX_SEMANTIC_TABLE_H\n#define XX_SEMANTIC_TABLE_H\n\ntypedef enum type type_t;\ntypedef char * key_t;    // typedef int hash_t; typedef hash_t key_t;\ntypedef struct value {\n  type_t type;\n  scope_t scope;\n} value_t;\n\ntypedef ... table_t;// \u7b26\u53f7\u8868\u6570\u636e\u7ed3\u6784\n\ntable_t new_table(void);\nint table_insert(table_t table, key_t id, value_t info);\nvalue_t table_search(table_t table, key_t id);\n\n#endif\n")),(0,i.kt)("h3",{id:"\u7c7b\u578b\u68c0\u67e5"},"\u7c7b\u578b\u68c0\u67e5"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"table: \u5b57\u5178\u7ed3\u6784 (key, type) (Hash Table/Red Black Tree)"),(0,i.kt)("li",{parentName:"ul"},"type environment(Object, Methods, Class)\nis passed from parent to child(down the tree)"),(0,i.kt)("li",{parentName:"ul"},"types are passed from child to parent(up the tree)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"TypeCheck(Environment/OMC, e1+e2) = {\n    T1 = TypeCheck(OMC, e1);\n    T2 = TypeCheck(OMC, e2);\n    Check T1 == T2 == Int;\n    return Int;\n}\n\nTypeCheck(OMC, let x: T <- e0 in e1) = {\n    T0 = TypeCheck(OMC, e0);\n    T1 = TypeCheck(OMC.add(O(x)=T), e1);\n    Check subtype(T0, T1);  // T0 <= T1\n    return T1;\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'enum type {INT, BOOL};\ntable_t table;// symbol table\n\n// dec_t, stm_t, exp_t: AST \u4e2d\u7684\u7ed3\u70b9\n\nenum type check_prog(dec_t d, stm_t s) {\n  // \u751f\u6210\u7b26\u53f7\u8868\n  table = check_dec(d);\n  // \u6839\u636e\u7b26\u53f7\u8868\u68c0\u67e5\u8bed\u53e5\n  return check_stm(s);\n}\n\n// \u751f\u6210\u7b26\u53f7\u8868\ntable_t check_dec(dec_t d){\n  foreach(T id <- d) {\n    table_insert(table, id, T);\n  }\n}\n\nenum type check_stm(table_t table, stm_t s) {\n  switch (s->kind) {\n    case STM_ASSIGN:\n      t1 = table_search(table, id);\n      t2 = check_exp(table, s->exp);\n      if (t1 != t2) {\n        throw new SemanticError("type mismatch");\n      } else {\n        return t1;\n      }\n    case STM_PRINTI:\n      t = check_exp(s->exp);\n      if (t != INT) {\n        throw new SemanticError("type mismatch");\n      } else {\n        return INT;\n      }\n    case STM_PRINTB:\n      t = check_exp(s->exp);\n      if (t != BOOL) {\n        throw new SemanticError("type mismatch");\n      } else {\n        return BOOL;\n      }\n  }\n}\n\nenum type check_exp(exp_t e) {\n  switch (e->kind) {\n    case EXP_INT:\n      return INT;\n    case EXP_ID:\n      t = table_search(table, id);// \u67e5\u8be2\u7b26\u53f7\u8868, \u5f97\u5230\u53d8\u91cf\u7c7b\u578b\n      if (id not exist) {\n        throw new SemanticError("id not found");\n      } else {\n        return t;\n      }\n    case EXP_TRUE:\n      return BOOL;\n    case EXP_FALSE:\n      return BOOL;\n    case EXP_ADD:\n      enum type t1 = check_exp_type(e->left);\n      enum type t2 = check_exp_type(e->right);\n      if (t1 != INT || t2 != INT) {\n        throw new SemanticError();\n        break;\n      } else {\n        return INT;\n      }\n    case EXP_AND:\n      enum type t1 = check_exp_type(e->left);\n      enum type t2 = check_exp_type(e->right);\n      if (t1 != BOOL || t2 != BOOL) {\n        throw new SemanticError();\n        break;\n      } else {\n        return BOOL;\n      }\n    default:\n      throw new SemanticError();\n      break;\n  }\n}\n')),(0,i.kt)("h3",{id:"\u4f5c\u7528\u57df\u68c0\u67e5"},"\u4f5c\u7528\u57df\u68c0\u67e5"),(0,i.kt)("p",null,"table:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u8fdb\u5165\u4f5c\u7528\u57df, \u63d2\u5165\u5143\u7d20(\u63d2\u5165\u54c8\u5e0c\u8868\u9996, \u5c4f\u853d\u5916\u90e8\u540c\u540d\u53d8\u91cf); \u79bb\u5f00\u4f5c\u7528\u57df, \u5220\u9664\u5143\u7d20"),(0,i.kt)("li",{parentName:"ul"},"\u8fdb\u5165\u4f5c\u7528\u57df, \u538b\u5165\u65b0\u7b26\u53f7\u8868; \u79bb\u5f00\u4f5c\u7528\u57df, \u5f39\u51fa\u6808\u9876\u7b26\u53f7\u8868")),(0,i.kt)("h3",{id:"\u7c7b\u578b\u76f8\u5bb9\u6027"},"\u7c7b\u578b\u76f8\u5bb9\u6027"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u540d\u5b57\u4e0d\u540c\u4f46\u7ed3\u6784\u76f8\u540c\u7684\u7c7b\u578b\u662f\u5426\u76f8\u7b49"),(0,i.kt)("li",{parentName:"ul"},"\u9762\u5411\u5bf9\u8c61\u7684\u7ee7\u627f\u7c7b: is-a \u5173\u7cfb Parent parent = child;")),(0,i.kt)("h3",{id:"\u9519\u8bef\u8bca\u65ad"},"\u9519\u8bef\u8bca\u65ad"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u51c6\u786e\u7684\u9519\u8bef\u4fe1\u606f: \u51fa\u9519\u4f4d\u7f6e\u7b49"),(0,i.kt)("li",{parentName:"ul"},"\u5927\u91cf\u7684\u9519\u8bef\u4fe1\u606f"),(0,i.kt)("li",{parentName:"ul"},"\u4e00\u5b9a\u7684\u81ea\u7ea0\u529f\u80fd")),(0,i.kt)("h2",{id:"immediate-representation"},"Immediate Representation"),(0,i.kt)("p",null,"IR:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6811\u4e0e\u6709\u5411\u65e0\u73af\u56fe(DAG)"),(0,i.kt)("li",{parentName:"ul"},"\u4e09\u5730\u5740\u7801(3-address code)"),(0,i.kt)("li",{parentName:"ul"},"\u63a7\u5236\u6d41\u56fe(CFG)"),(0,i.kt)("li",{parentName:"ul"},"\u9759\u6001\u5355\u8d4b\u503c\u5f62\u5f0f(SSA)"),(0,i.kt)("li",{parentName:"ul"},"\u8fde\u7eed\u4f20\u9012\u98ce\u683c(CPS)")),(0,i.kt)("h3",{id:"\u4e09\u5730\u5740\u7801"},"\u4e09\u5730\u5740\u7801"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u539f\u5b50\u8868\u8fbe\u5f0f"),(0,i.kt)("li",{parentName:"ul"},"\u7b80\u5355\u63a7\u5236\u6d41 cjmp/jmp"),(0,i.kt)("li",{parentName:"ul"},"\u62bd\u8c61\u7684\u673a\u5668\u4ee3\u7801(\u4f2a\u4ee3\u7801)")),(0,i.kt)("h3",{id:"\u63a7\u5236\u6d41\u56fe"},"\u63a7\u5236\u6d41\u56fe"),(0,i.kt)("h4",{id:"block"},"Block"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"block_t: { label_t; stm_list; jmp_t; }"),(0,i.kt)("li",{parentName:"ul"},"\u626b\u63cf\u4e09\u5730\u5740\u7801, \u751f\u6210 blocks"),(0,i.kt)("li",{parentName:"ul"},"\u56fe\u8bba\u7b97\u6cd5:\u7ed3\u70b9\u4e3a blocks, \u8fb9\u4e3a\u8df3\u8f6c\u8fb9")),(0,i.kt)("p",null,"\u6b7b\u57fa\u672c\u5757\u5220\u9664\u4f18\u5316\uff1a\u5220\u9664\u904d\u5386\u4e0d\u5230\u7684\u8bed\u53e5\u5757"),(0,i.kt)("h4",{id:"\u6570\u636e\u6d41\u5206\u6790\u4e0e\u7a0b\u5e8f\u91cd\u5199"},"\u6570\u636e\u6d41\u5206\u6790\u4e0e\u7a0b\u5e8f\u91cd\u5199"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6839\u636e\u6570\u636e\u6d41\u5206\u6790\u5f97\u5230\u7684\u4fe1\u606f, \u5bf9\u4e09\u5730\u5740\u7801/\u63a7\u5236\u6d41\u56fe\u8fdb\u884c\u91cd\u5199"),(0,i.kt)("li",{parentName:"ul"},"\u540e\u7aef\u7684\u6bcf\u4e00\u4e2a\u9636\u6bb5\u90fd\u53ef\u8fdb\u884c\u6570\u636e\u6d41\u5206\u6790")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u5e38\u91cf\u4f20\u64ad\u4f18\u5316: \u5c06\u8d4b\u503c\u8bed\u53e5\u53f3\u7aef\u53d8\u91cf\u76f4\u63a5\u66ff\u6362\u4e3a\u5e38\u91cf, \u51cf\u5c11\u8bbf\u5b58")),(0,i.kt)("h5",{id:"\u6570\u636e\u5206\u6790\u65b9\u6cd5"},"\u6570\u636e\u5206\u6790\u65b9\u6cd5"),(0,i.kt)("h6",{id:"\u5230\u8fbe\u5b9a\u4e49\u5206\u6790"},"\u5230\u8fbe\u5b9a\u4e49\u5206\u6790"),(0,i.kt)("p",null,"\u5206\u6790\u53d8\u91cf\u7684\u54ea\u4e9b\u5b9a\u4e49\u70b9\u53ef\u4ee5\u5230\u8fbe\u53d8\u91cf\u7684\u4f7f\u7528\u70b9\u5904, \u82e5\u53ef\u8fbe\u5b9a\u4e49\u552f\u4e00\u5219\u53ef\u8fdb\u884c\u5e38\u91cf\u4f20\u64ad\u4f18\u5316:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"in set = prior out set"),(0,i.kt)("li",{parentName:"ul"},"out set = self set + in set - kill set(\u91cd\u590d\u5b9a\u4e49\u70b9)")),(0,i.kt)("h6",{id:"\u6d3b\u6027\u5206\u6790"},"\u6d3b\u6027\u5206\u6790"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5bc4\u5b58\u5668\u5206\u914d\u4f18\u5316 \u6d3b\u8dc3\u533a\u95f4\u4e0d\u76f8\u4ea4\u7684\u53d8\u91cf\u53ef\u5171\u7528\u4e00\u4e2a\u5bc4\u5b58\u5668"),(0,i.kt)("li",{parentName:"ul"},"\u5e76\u884c\u4f18\u5316 \u4f7f\u7528\u533a\u95f4\u5e76\u884c\u7684\u8ba1\u7b97\u53ef\u5e76\u884c\u6267\u884c")),(0,i.kt)("h2",{id:"\u4ee3\u7801\u4f18\u5316"},"\u4ee3\u7801\u4f18\u5316"),(0,i.kt)("h3",{id:"\u7ec4\u7ec7\u7ba1\u7406"},"\u7ec4\u7ec7\u7ba1\u7406"),(0,i.kt)("h4",{id:"activation-record-and-frame"},"Activation Record and Frame"),(0,i.kt)("p",null,"AR:"),(0,i.kt)("p",null,"\u7528\u4e8e\u7ba1\u7406\u8fc7\u7a0b\u6d3b\u6027(procedure activation)\u7684\u4fe1\u606f:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"result: \u7f6e\u4e8e\u8bb0\u5f55\u7684\u9876\u5c42, \u4fbf\u4e8e\u8bbf\u95ee\u6b64\u7ed3\u679c"),(0,i.kt)("li",{parentName:"ul"},"argument"),(0,i.kt)("li",{parentName:"ul"},"return address"),(0,i.kt)("li",{parentName:"ul"},"control link: \u6307\u5411\u8c03\u7528\u8005(\u4e0a\u7ea7)")),(0,i.kt)("h4",{id:"\u5168\u5c40\u53d8\u91cf"},"\u5168\u5c40\u53d8\u91cf"),(0,i.kt)("p",null,"\u4e0d\u5b58\u4e8e AR \u4e2d, \u5b58\u4e8e\u9759\u6001\u6570\u636e\u6bb5"),(0,i.kt)("h4",{id:"\u5806\u533a"},"\u5806\u533a"),(0,i.kt)("p",null,"new/malloc \u5f97\u5230\u7684\u53d8\u91cf/\u5bf9\u8c61\u4e0d\u5b58\u4e8e AR \u4e2d, \u5b58\u4e8e\u5806\u533a"),(0,i.kt)("h3",{id:"\u4f18\u5316\u7c7b\u578b"},"\u4f18\u5316\u7c7b\u578b"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Local optimizations"),(0,i.kt)("li",{parentName:"ul"},"Global optimizations"),(0,i.kt)("li",{parentName:"ul"},"Inter-procedural optimizations")),(0,i.kt)("h3",{id:"\u5c40\u90e8\u4f18\u5316"},"\u5c40\u90e8\u4f18\u5316"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5e38\u91cf\u6298\u53e0\u4f18\u5316: \u6240\u6709\u4ee3\u5165\u5e38\u91cf\u7684\u5730\u65b9\u5168\u90e8\u4ee3\u5165\u5e38\u91cf ",(0,i.kt)("inlineCode",{parentName:"li"},"1 + 2 => 3")),(0,i.kt)("li",{parentName:"ul"},"\u4ee3\u6570\u5316\u7b80\u4f18\u5316: ",(0,i.kt)("inlineCode",{parentName:"li"},"a=1*b => a=b")," ",(0,i.kt)("inlineCode",{parentName:"li"},"2*a=>a<<1")," (all tips from CSAPP)"),(0,i.kt)("li",{parentName:"ul"},"\u590d\u5236\u4f20\u64ad(copy propagation)\u4f18\u5316: \u5229\u7528\u524d\u9762\u8ba1\u7b97\u51fa\u6765\u7684\u7ed3\u679c, \u76f4\u63a5\u66ff\u6362\u540e\u9762\u6240\u6709\u51fa\u73b0\u5728\u53f3\u8fb9\u7684\u5df2\u8ba1\u7b97\u5de6\u5f0f(\u5bc4\u5b58\u5668)")),(0,i.kt)("h3",{id:"\u5168\u5c40\u4f18\u5316"},"\u5168\u5c40\u4f18\u5316"),(0,i.kt)("h4",{id:"dead-code-elimination"},"Dead Code Elimination"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"CFG \u4e2d(\u63a7\u5236\u6d41\u5206\u6790) \u6b7b\u4ee3\u7801\u5757\u5220\u9664\u4f18\u5316")),(0,i.kt)("h4",{id:"constant-propagation"},"Constant Propagation"),(0,i.kt)("p",null,"CFG \u4e2d(\u6570\u636e\u6d41\u5206\u6790-\u53ef\u8fbe\u5b9a\u4e49\u5206\u6790) \u5e38\u91cf\u4f20\u64ad(constant propagation)\u4f18\u5316:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"forwards analysis")),(0,i.kt)("li",{parentName:"ul"},"C(stm, x, in) = value of x before stm ; C(stm, x, out) = value of x after stm"),(0,i.kt)("li",{parentName:"ul"},"bottom < c < top => C(stm, x, in) = least_upper_bound{ C(prev_stm_i, x, out) }:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"C(prev_stm, x, out) = top(nondeterministic) => C(stm, x, in) = top"),(0,i.kt)("li",{parentName:"ul"},"C(prev_stm1, x, out) != C(prev_stm2, x, out) => C(stm, x, in) = top"),(0,i.kt)("li",{parentName:"ul"},"C(prev_stm_i, x, out) = c/bottom(dead code) => C(stm, x, in) = c"))),(0,i.kt)("li",{parentName:"ul"},"C(stm, x, in) = bottom => C(stm, x, out) = bottom"),(0,i.kt)("li",{parentName:"ul"},"C(x := c, x, out) = c"),(0,i.kt)("li",{parentName:"ul"},"C(x := f(), x, out) = top"),(0,i.kt)("li",{parentName:"ul"},"init: set entry to C = top, set anywhere else to C = bottom")),(0,i.kt)("h4",{id:"liveness-analysis"},"Liveness Analysis"),(0,i.kt)("p",null,"CFG \u4e2d \u6570\u636e\u6d41\u5206\u6790-\u6d3b\u6027\u5206\u6790(liveness analysis), \u53ef\u7528\u4e8e\u590d\u5236\u4f20\u64ad\u4f18\u5316\u4e0e\u5bc4\u5b58\u5668\u5206\u914d\u4f18\u5316:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"backwards analysis"),(0,i.kt)("li",{parentName:"ul"},"L(stm, x, out) = V { L(next_stm, x, in)}"),(0,i.kt)("li",{parentName:"ul"},"L(... := f(x), x, in) = true"),(0,i.kt)("li",{parentName:"ul"},"L(x := e, x, in) = false"),(0,i.kt)("li",{parentName:"ul"},"L(none x, x, in) = L(none x, x, out)"),(0,i.kt)("li",{parentName:"ul"},"init: L(...) = false")),(0,i.kt)("h4",{id:"\u5bc4\u5b58\u5668\u5206\u914d"},"\u5bc4\u5b58\u5668\u5206\u914d"),(0,i.kt)("p",null,"Register Allocation and Graph Coloring:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u5f53 t1 \u4e0e t2 \u540c\u65f6\u5177\u6709\u6d3b\u6027\u65f6, \u4e0d\u53ef\u5171\u4eab\u5bc4\u5b58\u5668; \u53cd\u4e4b, t1 \u4e0e t2 \u4e0d\u540c\u65f6\u5177\u6709\u6d3b\u6027, \u53ef\u4ee5\u5171\u4eab\u5bc4\u5b58\u5668"),(0,i.kt)("li",{parentName:"ul"},"\u5f53 t1 \u4e0e t2 \u540c\u65f6\u5177\u6709\u6d3b\u6027\u65f6, \u6dfb\u52a0\u4e00\u6761\u8fb9\u8fde\u63a5 t1 \u4e0e t2, \u6784\u5efa register interference graph(RIG)"),(0,i.kt)("li",{parentName:"ul"},"colors number = registers number, k-colorable problem")),(0,i.kt)("h2",{id:"code-generation\u4ee3\u7801\u751f\u6210"},"Code Generation(\u4ee3\u7801\u751f\u6210)"),(0,i.kt)("p",null,"\u4e3a\u6570\u636e\u5206\u914d\u8ba1\u7b97\u8d44\u6e90:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6570\u636e: \u5168\u5c40\u53d8\u91cf, \u5c40\u90e8\u53d8\u91cf, \u52a8\u6001\u5206\u914d\u53d8\u91cf"),(0,i.kt)("li",{parentName:"ul"},"\u8d44\u6e90: \u5bc4\u5b58\u5668(register), \u6570\u636e\u533a(.data, .bss), \u4ee3\u7801\u533a(.code), \u6808\u533a(runtime stack), \u5806\u533a(user heap)")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u5f53\u524d\u5c40\u90e8\u53d8\u91cf\u5e94\u8be5\u653e\u5728\u5bc4\u5b58\u5668\u8fd8\u662f\u5185\u5b58\u533a?")),(0,i.kt)("p",null,"\u4e3a\u4ee3\u7801\u9009\u62e9\u8ba1\u7b97\u6307\u4ee4(\u7b49\u4ef7\u6027):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u4ee3\u7801: \u8868\u8fbe\u5f0f/\u8bed\u53e5/\u51fd\u6570\u4ee3\u7801"),(0,i.kt)("li",{parentName:"ul"},"\u6307\u4ee4: \u7b97\u672f/\u6bd4\u8f83/\u8df3\u8f6c/\u8c03\u7528/\u8fd4\u56de\u6307\u4ee4")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"P: D S\n ;\n\nD: T id ';' D\n |\n ;\n\nT: int\n | bool\n ;\n\nS: id = E\n | printi (E)\n | printb (E)\n ;\n\nE: n\n | id\n | true\n | false\n | E + E\n | E && E\n ;\n")),(0,i.kt)("h3",{id:"\u9012\u5f52\u4e0b\u964d\u4ee3\u7801\u751f\u6210\u7b97\u6cd5"},"\u9012\u5f52\u4e0b\u964d\u4ee3\u7801\u751f\u6210\u7b97\u6cd5"),(0,i.kt)("h4",{id:"\u57fa\u4e8e\u6808\u8ba1\u7b97\u673a"},"\u57fa\u4e8e\u6808\u8ba1\u7b97\u673a"),(0,i.kt)("p",null,"Mem + Stack + ALU"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"JVM(Java Virtual Machine)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"s: push NUM\n | load x\n | store x\n | add\n | sub\n | times\n | div\n ;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'gen_prog(dec_t d, stm_t s) {\n  gen_dec(d);\n  gen_stm(s);\n}\n\ngen_dec(T id; D) {\n  // stack_code(".int id")\n  gen_type(T);\n  emit(" id");\n\n  gen_dec(D);\n}\n\ngen_type(type_t t) {\n  switch(t-kind) {\n    case INT:// fall through\n    case BOOL:\n      emit(".int");\n      break;\n  }\n}\n\ngen_stm(stm_t s) {\n  switch (s->kind) {\n    STM_ASSIGN:\n      gen_exp(s->exp);\n      emit("store s->id");\n      break;\n    STM_PRINTI:\n      gen_exp(s->exp);\n      emit("printi");\n      break;\n    STM_PRINTB:\n      gen_exp(s->exp);\n      emit("printb");\n      break;\n  }\n}\n\ngen_exp(exp_t e) {\n  switch (e->kind) {\n    case EXP_INT:\n      emit("push e->value");// n\n      break;\n    case EXP_ID:\n      emit("load e->value");// id\n      break;\n    case EXP_BOOL:\n      emit("push e->value");// 1/0\n      break;\n    case EXP_ADD:\n      gen_exp(e->left);\n      gen_exp(e->right);\n      emit("add");\n      break;\n    case EXP_AND:\n      gen_exp(e->left);\n      gen_exp(e->right);\n      emit("and");\n      break;\n  }\n}\n')),(0,i.kt)("h4",{id:"\u57fa\u4e8e\u5bc4\u5b58\u5668\u8ba1\u7b97\u673a-risc"},"\u57fa\u4e8e\u5bc4\u5b58\u5668\u8ba1\u7b97\u673a (RISC)"),(0,i.kt)("p",null,"Mem + Reg + ALU"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"MIPS ISA")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// src -> dist\ns: mov_n n, r\n | mov r1, r2\n | load [x], r\n | store r, [x]\n | add r1, r2, r3\n | sub r1, r2, r3\n | times r1, r2, r3\n | div r1, r2, r3\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'void gen_prog(dec_t d, stm_t s) {\n  gen_dec(d);\n  gen_stm(s);\n}\n\nvoid gen_dec(T id; D) {\n  // reg_code(".int id")\n  // \u4e3a\u53d8\u91cf\u5206\u914d\u5bc4\u5b58\u5668\n  gen_type(T);\n  emit(" id");\n\n  gen_dec(D);\n}\n\nvoid gen_type(type_t t) {\n  switch(t-kind) {\n    case INT:// fall through\n    case BOOL:\n      emit(".int");\n      break;\n  }\n}\n\nvoid gen_stm(stm_t s) {\n  switch (s->kind) {\n    STM_ASSIGN:\n      r = gen_exp(s->exp);\n      emit("mov r, e->id");\n      break;\n    STM_PRINTI:\n      r = gen_exp(s->exp);\n      emit("printi r");\n      break;\n    STM_PRINTB:\n      r = gen_exp(s->exp);\n      emit("printb r");\n      break;\n  }\n}\n\nreg_t gen_exp(exp_t e) {\n  switch (e->kind) {\n    case EXP_INT:\n      r = random_reg();\n      emit("mov_n e->value, r");// n\n      return r;\n    case EXP_ID:\n      r = random_reg();\n      emit("mov e->value, r");// id\n      return r;\n    case EXP_BOOL:\n      r = random_reg();\n      emit("mov_n e->value, r");// 1/0\n      return r;\n    case EXP_ADD:\n      r1 = gen_exp(e->left);\n      r2 = gen_exp(e->right);\n      r = random_reg();\n      emit("add r1, r2, r");\n      return r;\n    case EXP_AND:\n      r1 = gen_exp(e->left);\n      r2 = gen_exp(e->right);\n      r = random_reg();\n      emit("and r1, r2, r");\n      return r;\n  }\n}\n')),(0,i.kt)("h2",{id:"garbage-collection"},"Garbage Collection"),(0,i.kt)("h3",{id:"mark-and-sweep"},"Mark and Sweep"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"mark phase: traces reachable objects (mark_bit |= 1)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"let todo = {all roots}\nwhile todo != nil do\n    pick v <- todo\n    todo -= {v}\n    if mark(v) == 0 then\n        mark(v) |= 1\n        let v1, ..., vn be the pointers contained in v\n        todo += {v1, ..., vn}\n    fi\nod\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"sweep phase: collects garbage objects (mark_bit == 0)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"p = bottom of heap\nwhile p < top of heap do\n    if mark(p) == 1 then\n        mark(p) = 0\n    else\n        add block p...(p + sizeof(p) - 1)  to freeList\n    fi\n    p += sizeof(p)\nod\n")),(0,i.kt)("h3",{id:"stop-and-copy"},"Stop and Copy"),(0,i.kt)("p",null,"Copy all reachable objects in old space to new space(reserved for GC):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Copied objects"),(0,i.kt)("li",{parentName:"ul"},"Scanned objects: pointers have been restored")),(0,i.kt)("h2",{id:"compilers-exercise"},"Compilers Exercise"),(0,i.kt)("h3",{id:"c-declaration-interpreter"},"C Declaration Interpreter"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#define MAX_TOKENS 100\n#define MAX_TOKEN_LEN 64\n\nenum type_tag {\n    IDENTIFIER,\n    QUALIFIER,\n    TYPE,\n};\n\nstruct token {\n    char type;\n    char string[MAX_TOKEN_LEN];\n};\n\nint top = -1;\nstruct token stack[MAX_TOKENS];\nstruct token ts;\n\n#define pop stack[top--]\n#define push(s) stack[++top] = s\n\nenum type_tag classify_string(void) {\n    char *s = ts.string;\n\n    if (!strcmp(s, "const")) {\n        strcpy(s, "read-only ");\n        return QUALIFIER;\n    }\n\n    if (!strcmp(s, "volatile")) return QUALIFIER;\n    if (!strcmp(s, "void")) return TYPE;\n    if (!strcmp(s, "char")) return TYPE;\n    if (!strcmp(s, "signed")) return TYPE;\n    if (!strcmp(s, "unsigned")) return TYPE;\n    if (!strcmp(s, "short")) return TYPE;\n    if (!strcmp(s, "int")) return TYPE;\n    if (!strcmp(s, "long")) return TYPE;\n    if (!strcmp(s, "float")) return TYPE;\n    if (!strcmp(s, "double")) return TYPE;\n    if (!strcmp(s, "struct")) return TYPE;\n    if (!strcmp(s, "union")) return TYPE;\n    if (!strcmp(s, "enum")) return TYPE;\n\n    return IDENTIFIER;\n}\n\nvoid get_token(void) {\n    char *p = ts.string;\n\n    /* \u7565\u8fc7\u7a7a\u767d\u5b57\u7b26 */\n    while ((*p = getchar()) == \' \');\n\n    if (isalnum(*p)) {\n        /* \u8bfb\u5165\u5f97\u6807\u8bc6\u7b26\u4ee5\uff41\uff0d\uff3a\uff0c\uff10\uff0d\uff19\u5f00\u5934 */\n        while (isalnum(*++p = getchar()));\n        ungetc(*p, stdin);\n        *p = \'\\0\';\n        ts.type = classify_string();\n        return;\n    }\n\n    if (*p == \'*\') {\n        strcpy(ts.string, "pointer to");\n        ts.type = \'*\';\n        return;\n    }\n\n    ts.string[1] = \'\\0\';\n    ts.type = *p;\n    return;\n}\n\nvoid read_to_first_identifier(void) {\n    get_token();\n\n  // read til identifier\n    while (ts.type != IDENTIFIER) {\n        push(ts);\n        get_token();\n    }\n\n    printf("%s is ", ts.string);\n    get_token();\n}\n\nvoid deal_with_arrays(void) {\n    while (ts.type == \'[\') {\n        printf("array ");\n        get_token();\n\n    /* \u6570\u5b57\u6216\']\' */\n        if (isdigit(ts.string[0])) {\n            printf("0..%d ", atoi(ts.string) - 1);\n            get_token();\n        }\n\n        get_token();\n        printf("of ");\n    }\n}\n\nvoid deal_with_pointers(void) {\n    while (stack[top].type == \'*\')\n    {\n        printf("%s ", pop.string);\n    }\n}\n\nvoid deal_with_function_args(void) {\n    while (ts.type != \')\') {\n        get_token();\n    }\n\n    get_token();\n    printf("function returning ");\n}\n\nvoid deal_with_declarator(void) {\n    /* \u5904\u7406\u6807\u8bc6\u7b26\u4e4b\u540e\u53ef\u80fd\u5b58\u5728\u7684\u6570\u7ec4/\u51fd\u6570 */\n\n    switch (ts.type) {\n      case \'[\':\n          deal_with_arrays();\n          break;\n      case \'(\':\n          deal_with_function_args();\n          break;\n    }\n\n    deal_with_pointers();\n\n    /* \u5904\u7406\u5728\u8bfb\u5165\u5230\u6807\u8bc6\u7b26\u4e4b\u524d\u538b\u5165\u5230\u5806\u6808\u4e2d\u7684\u7b26\u53f7 */\n    while (top >= 0) {\n        if (stack[top].type == \'(\') {\n            pop;\n            get_token();  //\u8bfb\u53d6\')\'\u4e4b\u540e\u7684\u7b26\u53f7\n            deal_with_declarator();\n        } else {\n            printf("%s", pop.string);\n        }\n    }\n}\n\nint main(void) {\n    /* \u5c06\u6807\u8bb0\u538b\u5165\u5806\u6808\u4e2d, \u76f4\u5230\u9047\u89c1\u6807\u8bc6\u7b26 */\n    read_to_first_identifier();\n    deal_with_declarator();\n    printf("\\n");\n\n    system("pause");\n    return 0;\n}\n')),(0,i.kt)("h3",{id:"cool-language"},"Cool Language"),(0,i.kt)("p",null,"Classroom Object-Oriented Language:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://web.stanford.edu/class/cs143/materials/cool-manual.pdf"},"Awesome Reference"))),(0,i.kt)("h3",{id:"parser-implementation"},"Parser Implementation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// \u8fd4\u56de\u4e0b\u4e00\u4e2aToken(\u53ea\u6d4b\u8bd5\u8be5Token\uff0c\u4e0d\u5411\u524d\u79fb\u52a8Token List\u7684offset\u6307\u9488)\nToken Peek(void);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// \u6d88\u8d39\u4e0b\u4e00\u4e2aToken\nToken Next(void);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// void Expect(expectedToken)\nif (Peek() != expectedToken) {\n    Error("expect %s, but got %s\\n", expectedToken, Peek());\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// void Try(expectedToken)\nif (Peek() == expectedToken) {\n    Next(); // \u6d88\u8d39\u4e4b\n    return true;\n}\n\nreturn false;\n")))}m.isMDXComponent=!0}}]);