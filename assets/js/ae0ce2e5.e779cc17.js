"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[1114],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(t),d=l,g=c["".concat(s,".").concat(d)]||c[d]||m[d]||i;return t?a.createElement(g,r(r({ref:n},p),{},{components:t})):a.createElement(g,r({ref:n},p))}));function d(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var u=2;u<i;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},6364:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return m}});var a=t(7462),l=t(3366),i=(t(7294),t(3905)),r=["components"],o={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Programming","Functional Programming"]},s="Functional Programming Basic Notes",u={unversionedId:"programming/functionalProgramming/functionalProgrammingBasicNotes",id:"programming/functionalProgramming/functionalProgrammingBasicNotes",title:"Functional Programming Basic Notes",description:"Lambda Calculus",source:"@site/notes/programming/functionalProgramming/functionalProgrammingBasicNotes.md",sourceDirName:"programming/functionalProgramming",slug:"/programming/functionalProgramming/functionalProgrammingBasicNotes",permalink:"/awesome-notes/programming/functionalProgramming/functionalProgrammingBasicNotes",editUrl:"https://github.com/sabertazimi/awesome-notes/edit/main/notes/programming/functionalProgramming/functionalProgrammingBasicNotes.md",tags:[{label:"Programming",permalink:"/awesome-notes/tags/programming"},{label:"Functional Programming",permalink:"/awesome-notes/tags/functional-programming"}],version:"current",lastUpdatedBy:"sabertazimi",lastUpdatedAt:1648310706,formattedLastUpdatedAt:"3/26/2022",frontMatter:{author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Programming","Functional Programming"]},sidebar:"sidebar",previous:{title:"Software Testing Basic Notes",permalink:"/awesome-notes/programming/devops/softwareTestingBasicNotes"},next:{title:"Game Design Basic Notes",permalink:"/awesome-notes/programming/game/gameDesignBasicNotes"}},p={},m=[{value:"Lambda Calculus",id:"lambda-calculus",level:2},{value:"Lambda Expression (Lambda-Term)",id:"lambda-expression-lambda-term",level:3},{value:"Lambda Reduction",id:"lambda-reduction",level:3},{value:"\u03b1 \u8f6c\u6362",id:"\u03b1-\u8f6c\u6362",level:4},{value:"\u03b2 \u5f52\u7ea6",id:"\u03b2-\u5f52\u7ea6",level:4},{value:"\u03b7 \u5f52\u7ea6",id:"\u03b7-\u5f52\u7ea6",level:4},{value:"Church Numerals",id:"church-numerals",level:3},{value:"Definition for Functional Programming",id:"definition-for-functional-programming",level:2},{value:"Datatype",id:"datatype",level:2},{value:"Datatype Binding",id:"datatype-binding",level:3},{value:"Built-in Tagged Constructor",id:"built-in-tagged-constructor",level:3},{value:"Type Constructor",id:"type-constructor",level:3},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Tail Position, Tail expression, Tail Call and Tail Recursion",id:"tail-position-tail-expression-tail-call-and-tail-recursion",level:2},{value:"Rules for expressions",id:"rules-for-expressions",level:2},{value:"samples",id:"samples",level:3},{value:"Standard ML",id:"standard-ml",level:2},{value:"functions",id:"functions",level:3},{value:"tuples",id:"tuples",level:3},{value:"lists",id:"lists",level:3},{value:"let expressions",id:"let-expressions",level:3},{value:"options",id:"options",level:3},{value:"boolean operations",id:"boolean-operations",level:3},{value:"closure",id:"closure",level:3},{value:"lexical scope vs dynamic scope",id:"lexical-scope-vs-dynamic-scope",level:4},{value:"compose and pipeline",id:"compose-and-pipeline",level:4},{value:"curry and unCurry",id:"curry-and-uncurry",level:4},{value:"Type inference",id:"type-inference",level:2}],c={toc:m};function d(e){var n=e.components,t=(0,l.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"functional-programming-basic-notes"},"Functional Programming Basic Notes"),(0,i.kt)("h2",{id:"lambda-calculus"},"Lambda Calculus"),(0,i.kt)("h3",{id:"lambda-expression-lambda-term"},"Lambda Expression (Lambda-Term)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Variable: x"),(0,i.kt)("li",{parentName:"ul"},"Abstraction: \u03bbx.M"),(0,i.kt)("li",{parentName:"ul"},"Application: M N")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"e.g. \u03bbx.y \u03bbx.(\u03bby.xy)")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u53d8\u91cf x \u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u6709\u6548\u7684 lambda \u9879"),(0,i.kt)("li",{parentName:"ul"},"\u5982\u679c t \u662f\u4e00\u4e2a lambda \u9879\uff0c\u800c x \u662f\u4e00\u4e2a\u53d8\u91cf\uff0c\u5219 \u03bbx.t \u662f\u4e00\u4e2a lambda \u9879\uff08\u79f0\u4e3a lambda \u62bd\u8c61\uff09"),(0,i.kt)("li",{parentName:"ul"},"\u5982\u679c t \u548c s \u662f lambda \u9879\uff0c\u90a3\u4e48 (ts) \u662f\u4e00\u4e2a lambda \u9879\uff08\u79f0\u4e3a\u5e94\u7528\uff09")),(0,i.kt)("h3",{id:"lambda-reduction"},"Lambda Reduction"),(0,i.kt)("h4",{id:"\u03b1-\u8f6c\u6362"},"\u03b1 \u8f6c\u6362"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"\u03b1: \u03bbx.x \u2261 \u03bby.y")," \u7b49\u4ef7\u53d8\u91cf\u66ff\u6362"),(0,i.kt)("h4",{id:"\u03b2-\u5f52\u7ea6"},"\u03b2 \u5f52\u7ea6"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"\u03b2: ((\u03bbV.E) E\u2032) \u2261 E[V := E\u2032]")," \u51fd\u6570\u62bd\u8c61\u5e94\u7528(apply)\u4e8e\u53c2\u6570\u7684\u8fc7\u7a0b"),(0,i.kt)("h4",{id:"\u03b7-\u5f52\u7ea6"},"\u03b7 \u5f52\u7ea6"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"\u03bbx.M x \u2261 M")," \u7528\u4e8e\u6e05\u9664 lambda \u8868\u8fbe\u5f0f\u4e2d\u5b58\u5728\u7684\u5197\u4f59\u51fd\u6570\u62bd\u8c61"),(0,i.kt)("h3",{id:"church-numerals"},"Church Numerals"),(0,i.kt)("p",null,"\u6309\u7167\u76ae\u4e9a\u8bfa\u516c\u7406\u53ef\u5f97\u81ea\u7136\u6570\u96c6\u5408\u8868\u793a\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"{0, S(0), S(S(0)), ...}"),", \u4e8e\u662f\u5f97\u5230\u5982\u4e0b\u5b9a\u4e49:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"S \u2261 \u03bbn.\u03bbf.\u03bbx.f (n f x)\n\n0 \u2261 \u03bbf.\u03bbx.x\n1 \u2261 \u03bbf.\u03bbx.f x\n2 \u2261 \u03bbf.\u03bbx.f (f x)\n3 \u2261 \u03bbf.\u03bbx.f (f (f x))\n...\n")),(0,i.kt)("p",null,"\u5bf9\u540e\u7ee7\u51fd\u6570 S \u548c\u4e18\u5947\u6570\u7684\u7b80\u5355\u9a8c\u8bc1\u5982\u4e0b\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"S 0\n\u2261 (\u03bbn.\u03bbf.\u03bbx.f (n f x)) \u03bbf.\u03bbx.x\n= (\u03bbn.\u03bbg.\u03bby.g (n g y)) \u03bbf.\u03bbx.x    // alpha\n= (\u03bbf.\u03bbx.f (n f x))[n := \u03bbf.\u03bbx.x] // beta\n= \u03bbg.\u03bby.g ((\u03bbf.\u03bbx.x) g y)         // substitute\n= \u03bbg.\u03bby.g (x[f := g, x := y])     // beta\n= \u03bbg.\u03bby.g y                       // substitute\n= \u03bbf.\u03bbx.f x                       // alpha\n\u2261 1\n")),(0,i.kt)("h2",{id:"definition-for-functional-programming"},"Definition for Functional Programming"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"avoid mutation"),(0,i.kt)("li",{parentName:"ul"},"first class functions"),(0,i.kt)("li",{parentName:"ul"},"recursive data structures and recursive functions"),(0,i.kt)("li",{parentName:"ul"},"laziness")),(0,i.kt)("h2",{id:"datatype"},"Datatype"),(0,i.kt)("h3",{id:"datatype-binding"},"Datatype Binding"),(0,i.kt)("p",null,"tagged union, every constructor name as tag,\nfields for different constructors can't exist at the same time"),(0,i.kt)("h3",{id:"built-in-tagged-constructor"},"Built-in Tagged Constructor"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"NONE"),(0,i.kt)("li",{parentName:"ul"},"SOME i"),(0,i.kt)("li",{parentName:"ul"},"[]"),(0,i.kt)("li",{parentName:"ul"},"x :: xs (infix constructor)"),(0,i.kt)("li",{parentName:"ul"},"()")),(0,i.kt)("h3",{id:"type-constructor"},"Type Constructor"),(0,i.kt)("p",null,"type constructor: datatype bindings with variables"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"datatype 'a myList = EMPTY | CONS of 'a * 'a myList\nmyList isn't a type, int list is a type\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"'a , 'a equivalent/different"),(0,i.kt)("li",{parentName:"ul"},"'a, 'b different"),(0,i.kt)("li",{parentName:"ul"},"''a, ''a equivalent")),(0,i.kt)("h2",{id:"pattern-matching"},"Pattern Matching"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"null/isSome check tag part\uff08variant\uff09"),(0,i.kt)("li",{parentName:"ul"},"hd/tl/valOf check data part (extract data)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"case e of\n      p1 => e1\n    | pn => en\n\nval p = e (* declare multiple variables once time in p(pattern) *)\n\n(* declare multiple callee arguments(hidden to caller) once time in p(pattern) *)\nfun foo p = e\n")),(0,i.kt)("p",null,"In SML, all functions only take 1 argument, a tuple/record:"),(0,i.kt)("p",null,"fun f (x, y, z) = x + y + z seems that takes 3 arguments,\nbut truly owing to pattern matching only takes 1 tuple argument\nLikewise, fun f () = 0 takes 1 empty tuple argument."),(0,i.kt)("p",null,"Further more, tuples is syntactic sugar for records."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"As a whole: all functions only take 1 record argument owing to pattern matching.")),(0,i.kt)("h2",{id:"tail-position-tail-expression-tail-call-and-tail-recursion"},"Tail Position, Tail expression, Tail Call and Tail Recursion"),(0,i.kt)("p",null,"recursive definition for Tail Position:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if E isn't in tail position, then sub expressions of E aren't in tail position"),(0,i.kt)("li",{parentName:"ul"},"if E is in tail position, then some sub expressions of E are in tail position")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"if eb then e1 else e2\n")),(0,i.kt)("p",null,"is in tail position, then e1 and e2 are in tail position, not eb"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"f (x, e)\n")),(0,i.kt)("p",null,"is in tail position, then f is in tail position(tail call), not x and e"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fun factorial n =\n    let\n        fun aux(n, acc) =\n            if\n                n = 0\n            then\n                acc\n            else\n                aux (n-1, n*acc)\n    in\n        aux (n,1)\n    end\n")),(0,i.kt)("h2",{id:"rules-for-expressions"},"Rules for expressions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Syntactic: syntax rules"),(0,i.kt)("li",{parentName:"ul"},"Semantic: type checking rules"),(0,i.kt)("li",{parentName:"ul"},"Runtime: evaluation rules")),(0,i.kt)("h3",{id:"samples"},"samples"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"syntax: if e1 then e2 else e3\ntype: e1 = bool,  e2 = e3 = any\nevaluation: e1 ? e2 : e3\n")),(0,i.kt)("h2",{id:"standard-ml"},"Standard ML"),(0,i.kt)("h3",{id:"functions"},"functions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"syntax: fun name (arg1: type1, .., argN: typeN) = body\ntype: name = type1 * ... * typeN -> body_type\nlazy evaluation\n")),(0,i.kt)("h3",{id:"tuples"},"tuples"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"(* tuples *)\nsyntax: e = (e1, ..., en)\ntype: e1 * ... * en (can become fun's arguments list)\nevaluation: #1 e, #2 e, ..., #n e\n")),(0,i.kt)("h3",{id:"lists"},"lists"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"(* lists *)\nsyntax: l = [e1, ..., en]\ntype: [] = elem_type list; hd(head) l = elem_type, tl(tail) x = elem_type list\nevaluation: cons = e :: l; null [] = false;\n\n> 6 :: [1, 3, 5]\n")),(0,i.kt)("h3",{id:"let-expressions"},"let expressions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"syntax: let\n            b1 b2 ... bn\n        in\n            body\n        end\ntype: whole let type = body_type\nevaluation: whole let result = body_result\n")),(0,i.kt)("h3",{id:"options"},"options"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"NONE : type = 'a option"),(0,i.kt)("li",{parentName:"ul"},"SOME e: type = ",(0,i.kt)("inlineCode",{parentName:"li"},"e_type")," option"),(0,i.kt)("li",{parentName:"ul"},"isSome: type = 'a option -> bool"),(0,i.kt)("li",{parentName:"ul"},"valOf : type = 'a option -> 'a")),(0,i.kt)("h3",{id:"boolean-operations"},"boolean operations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"e1 andalso e2: keyword"),(0,i.kt)("li",{parentName:"ul"},"e1 orelse e2 : keyword"),(0,i.kt)("li",{parentName:"ul"},"not e1 : bool -> bool"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"="),"(equal) ",(0,i.kt)("inlineCode",{parentName:"li"},"<>"),"(not equal) ",(0,i.kt)("inlineCode",{parentName:"li"},">")," ",(0,i.kt)("inlineCode",{parentName:"li"},"<")," ",(0,i.kt)("inlineCode",{parentName:"li"},">=")," ",(0,i.kt)("inlineCode",{parentName:"li"},"<="),": require two same type elem")),(0,i.kt)("h3",{id:"closure"},"closure"),(0,i.kt)("h4",{id:"lexical-scope-vs-dynamic-scope"},"lexical scope vs dynamic scope"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"lexical scope: function where defined"),(0,i.kt)("li",{parentName:"ul"},"dynamic scope: function where called")),(0,i.kt)("h4",{id:"compose-and-pipeline"},"compose and pipeline"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fun sqrt_of_abs = Math.sqrt o Real.fromInt o abs\n\ninfix !>\nfun x !> f = f x\n\nfun sqrt_of_abs i = i !> abs !> Real.fromInt !> Math.sqrt\n")),(0,i.kt)("h4",{id:"curry-and-uncurry"},"curry and unCurry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fun carry f x y = f (x, y)\nfun unCarry f (x, y) = f x y\n\nfun range (i, j) = if i > j then [] else i :: range(i+1, j)\nfun countUp = curry range 1\n\nval arr = countUp 7 (* maps to [1, 2, ..., 7] *)\n")),(0,i.kt)("h2",{id:"type-inference"},"Type inference"))}d.isMDXComponent=!0}}]);